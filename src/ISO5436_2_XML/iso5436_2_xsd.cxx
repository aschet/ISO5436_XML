// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
/***************************************************************************
 *   Copyright by                                                          *
 *   Georg Wiora (NanoFocus AG) 2007                                       *
 *   Jörg Seewig (Uni Hannover),                                           *
 *   Andreas Walther (NanoFocus AG),                                       *
 *   Mark A. Weber (NanoFocus AG) 2007                                     *
 *   Johannes Herwig (Uni-Duisburg-Essen) 2007                             *
 *   This file is part of the openGPS (R)[TM] software library.            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License (LGPL)    *
 *   as published by the Free Software Foundation; either version 3 of     *
 *   the License, or (at your option) any later version.                   *
 *   for detail see the files "licence_LGPL-3.0.txt" and                   *
 *   "licence_GPL-3.0.txt".                                                *
 *                                                                         *
 *   openGPS is distributed in the hope that it will be useful,            *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU Lesser General Public License for more details.                   *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 *                                                                         *
 *   The name "openGPS" and the logo are registered as                     *
 *   European trade mark No. 006178354 for                                 *
 *   Physikalisch Technische Bundesanstalt (PTB)                           *
 *   http://www.ptb.de/                                                    *
 *                                                                         *
 *   More information about openGPS can be found at                        *
 *   http://www.opengps.eu/                                                *
 ***************************************************************************/

//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ISO5436_2_xsd.hxx"

namespace xsd
{
  // Record1Type
  // 

  const Record1Type::Revision_type& Record1Type::
  Revision () const
  {
    return this->Revision_.get ();
  }

  Record1Type::Revision_type& Record1Type::
  Revision ()
  {
    return this->Revision_.get ();
  }

  void Record1Type::
  Revision (const Revision_type& Revision)
  {
    this->Revision_.set (Revision);
  }

  void Record1Type::
  Revision (::std::auto_ptr< Revision_type > Revision)
  {
    this->Revision_.set (Revision);
  }

  const Record1Type::FeatureType_type& Record1Type::
  FeatureType () const
  {
    return this->FeatureType_.get ();
  }

  Record1Type::FeatureType_type& Record1Type::
  FeatureType ()
  {
    return this->FeatureType_.get ();
  }

  void Record1Type::
  FeatureType (const FeatureType_type& FeatureType)
  {
    this->FeatureType_.set (FeatureType);
  }

  void Record1Type::
  FeatureType (::std::auto_ptr< FeatureType_type > FeatureType)
  {
    this->FeatureType_.set (FeatureType);
  }

  const Record1Type::Axes_type& Record1Type::
  Axes () const
  {
    return this->Axes_.get ();
  }

  Record1Type::Axes_type& Record1Type::
  Axes ()
  {
    return this->Axes_.get ();
  }

  void Record1Type::
  Axes (const Axes_type& Axes)
  {
    this->Axes_.set (Axes);
  }

  void Record1Type::
  Axes (::std::auto_ptr< Axes_type > Axes)
  {
    this->Axes_.set (Axes);
  }


  // ISO5436_2Type
  // 

  const ISO5436_2Type::Record1_type& ISO5436_2Type::
  Record1 () const
  {
    return this->Record1_.get ();
  }

  ISO5436_2Type::Record1_type& ISO5436_2Type::
  Record1 ()
  {
    return this->Record1_.get ();
  }

  void ISO5436_2Type::
  Record1 (const Record1_type& Record1)
  {
    this->Record1_.set (Record1);
  }

  void ISO5436_2Type::
  Record1 (::std::auto_ptr< Record1_type > Record1)
  {
    this->Record1_.set (Record1);
  }

  const ISO5436_2Type::Record2_optional& ISO5436_2Type::
  Record2 () const
  {
    return this->Record2_;
  }

  ISO5436_2Type::Record2_optional& ISO5436_2Type::
  Record2 ()
  {
    return this->Record2_;
  }

  void ISO5436_2Type::
  Record2 (const Record2_type& Record2)
  {
    this->Record2_.set (Record2);
  }

  void ISO5436_2Type::
  Record2 (const Record2_optional& Record2)
  {
    this->Record2_ = Record2;
  }

  void ISO5436_2Type::
  Record2 (::std::auto_ptr< Record2_type > Record2)
  {
    this->Record2_.set (Record2);
  }

  const ISO5436_2Type::Record3_type& ISO5436_2Type::
  Record3 () const
  {
    return this->Record3_.get ();
  }

  ISO5436_2Type::Record3_type& ISO5436_2Type::
  Record3 ()
  {
    return this->Record3_.get ();
  }

  void ISO5436_2Type::
  Record3 (const Record3_type& Record3)
  {
    this->Record3_.set (Record3);
  }

  void ISO5436_2Type::
  Record3 (::std::auto_ptr< Record3_type > Record3)
  {
    this->Record3_.set (Record3);
  }

  const ISO5436_2Type::Record4_type& ISO5436_2Type::
  Record4 () const
  {
    return this->Record4_.get ();
  }

  ISO5436_2Type::Record4_type& ISO5436_2Type::
  Record4 ()
  {
    return this->Record4_.get ();
  }

  void ISO5436_2Type::
  Record4 (const Record4_type& Record4)
  {
    this->Record4_.set (Record4);
  }

  void ISO5436_2Type::
  Record4 (::std::auto_ptr< Record4_type > Record4)
  {
    this->Record4_.set (Record4);
  }

  const ISO5436_2Type::VendorSpecific_sequence& ISO5436_2Type::
  VendorSpecific () const
  {
    return this->VendorSpecific_;
  }

  ISO5436_2Type::VendorSpecific_sequence& ISO5436_2Type::
  VendorSpecific ()
  {
    return this->VendorSpecific_;
  }

  void ISO5436_2Type::
  VendorSpecific (const VendorSpecific_sequence& VendorSpecific)
  {
    this->VendorSpecific_ = VendorSpecific;
  }


  // Record2Type
  // 

  const Record2Type::Date_type& Record2Type::
  Date () const
  {
    return this->Date_.get ();
  }

  Record2Type::Date_type& Record2Type::
  Date ()
  {
    return this->Date_.get ();
  }

  void Record2Type::
  Date (const Date_type& Date)
  {
    this->Date_.set (Date);
  }

  void Record2Type::
  Date (::std::auto_ptr< Date_type > Date)
  {
    this->Date_.set (Date);
  }

  const Record2Type::Creator_optional& Record2Type::
  Creator () const
  {
    return this->Creator_;
  }

  Record2Type::Creator_optional& Record2Type::
  Creator ()
  {
    return this->Creator_;
  }

  void Record2Type::
  Creator (const Creator_type& Creator)
  {
    this->Creator_.set (Creator);
  }

  void Record2Type::
  Creator (const Creator_optional& Creator)
  {
    this->Creator_ = Creator;
  }

  void Record2Type::
  Creator (::std::auto_ptr< Creator_type > Creator)
  {
    this->Creator_.set (Creator);
  }

  const Record2Type::Instrument_type& Record2Type::
  Instrument () const
  {
    return this->Instrument_.get ();
  }

  Record2Type::Instrument_type& Record2Type::
  Instrument ()
  {
    return this->Instrument_.get ();
  }

  void Record2Type::
  Instrument (const Instrument_type& Instrument)
  {
    this->Instrument_.set (Instrument);
  }

  void Record2Type::
  Instrument (::std::auto_ptr< Instrument_type > Instrument)
  {
    this->Instrument_.set (Instrument);
  }

  const Record2Type::CalibrationDate_type& Record2Type::
  CalibrationDate () const
  {
    return this->CalibrationDate_.get ();
  }

  Record2Type::CalibrationDate_type& Record2Type::
  CalibrationDate ()
  {
    return this->CalibrationDate_.get ();
  }

  void Record2Type::
  CalibrationDate (const CalibrationDate_type& CalibrationDate)
  {
    this->CalibrationDate_.set (CalibrationDate);
  }

  void Record2Type::
  CalibrationDate (::std::auto_ptr< CalibrationDate_type > CalibrationDate)
  {
    this->CalibrationDate_.set (CalibrationDate);
  }

  const Record2Type::ProbingSystem_type& Record2Type::
  ProbingSystem () const
  {
    return this->ProbingSystem_.get ();
  }

  Record2Type::ProbingSystem_type& Record2Type::
  ProbingSystem ()
  {
    return this->ProbingSystem_.get ();
  }

  void Record2Type::
  ProbingSystem (const ProbingSystem_type& ProbingSystem)
  {
    this->ProbingSystem_.set (ProbingSystem);
  }

  void Record2Type::
  ProbingSystem (::std::auto_ptr< ProbingSystem_type > ProbingSystem)
  {
    this->ProbingSystem_.set (ProbingSystem);
  }

  const Record2Type::Comment_optional& Record2Type::
  Comment () const
  {
    return this->Comment_;
  }

  Record2Type::Comment_optional& Record2Type::
  Comment ()
  {
    return this->Comment_;
  }

  void Record2Type::
  Comment (const Comment_type& Comment)
  {
    this->Comment_.set (Comment);
  }

  void Record2Type::
  Comment (const Comment_optional& Comment)
  {
    this->Comment_ = Comment;
  }

  void Record2Type::
  Comment (::std::auto_ptr< Comment_type > Comment)
  {
    this->Comment_.set (Comment);
  }


  // Record3Type
  // 

  const Record3Type::MatrixDimension_optional& Record3Type::
  MatrixDimension () const
  {
    return this->MatrixDimension_;
  }

  Record3Type::MatrixDimension_optional& Record3Type::
  MatrixDimension ()
  {
    return this->MatrixDimension_;
  }

  void Record3Type::
  MatrixDimension (const MatrixDimension_type& MatrixDimension)
  {
    this->MatrixDimension_.set (MatrixDimension);
  }

  void Record3Type::
  MatrixDimension (const MatrixDimension_optional& MatrixDimension)
  {
    this->MatrixDimension_ = MatrixDimension;
  }

  void Record3Type::
  MatrixDimension (::std::auto_ptr< MatrixDimension_type > MatrixDimension)
  {
    this->MatrixDimension_.set (MatrixDimension);
  }

  const Record3Type::ListDimension_optional& Record3Type::
  ListDimension () const
  {
    return this->ListDimension_;
  }

  Record3Type::ListDimension_optional& Record3Type::
  ListDimension ()
  {
    return this->ListDimension_;
  }

  void Record3Type::
  ListDimension (const ListDimension_type& ListDimension)
  {
    this->ListDimension_.set (ListDimension);
  }

  void Record3Type::
  ListDimension (const ListDimension_optional& ListDimension)
  {
    this->ListDimension_ = ListDimension;
  }

  const Record3Type::DataLink_optional& Record3Type::
  DataLink () const
  {
    return this->DataLink_;
  }

  Record3Type::DataLink_optional& Record3Type::
  DataLink ()
  {
    return this->DataLink_;
  }

  void Record3Type::
  DataLink (const DataLink_type& DataLink)
  {
    this->DataLink_.set (DataLink);
  }

  void Record3Type::
  DataLink (const DataLink_optional& DataLink)
  {
    this->DataLink_ = DataLink;
  }

  void Record3Type::
  DataLink (::std::auto_ptr< DataLink_type > DataLink)
  {
    this->DataLink_.set (DataLink);
  }

  const Record3Type::DataList_optional& Record3Type::
  DataList () const
  {
    return this->DataList_;
  }

  Record3Type::DataList_optional& Record3Type::
  DataList ()
  {
    return this->DataList_;
  }

  void Record3Type::
  DataList (const DataList_type& DataList)
  {
    this->DataList_.set (DataList);
  }

  void Record3Type::
  DataList (const DataList_optional& DataList)
  {
    this->DataList_ = DataList;
  }

  void Record3Type::
  DataList (::std::auto_ptr< DataList_type > DataList)
  {
    this->DataList_.set (DataList);
  }


  // Record4Type
  // 

  const Record4Type::ChecksumFile_type& Record4Type::
  ChecksumFile () const
  {
    return this->ChecksumFile_.get ();
  }

  Record4Type::ChecksumFile_type& Record4Type::
  ChecksumFile ()
  {
    return this->ChecksumFile_.get ();
  }

  void Record4Type::
  ChecksumFile (const ChecksumFile_type& ChecksumFile)
  {
    this->ChecksumFile_.set (ChecksumFile);
  }

  void Record4Type::
  ChecksumFile (::std::auto_ptr< ChecksumFile_type > ChecksumFile)
  {
    this->ChecksumFile_.set (ChecksumFile);
  }


  // AxesType
  // 

  const AxesType::CX_type& AxesType::
  CX () const
  {
    return this->CX_.get ();
  }

  AxesType::CX_type& AxesType::
  CX ()
  {
    return this->CX_.get ();
  }

  void AxesType::
  CX (const CX_type& CX)
  {
    this->CX_.set (CX);
  }

  void AxesType::
  CX (::std::auto_ptr< CX_type > CX)
  {
    this->CX_.set (CX);
  }

  const AxesType::CY_type& AxesType::
  CY () const
  {
    return this->CY_.get ();
  }

  AxesType::CY_type& AxesType::
  CY ()
  {
    return this->CY_.get ();
  }

  void AxesType::
  CY (const CY_type& CY)
  {
    this->CY_.set (CY);
  }

  void AxesType::
  CY (::std::auto_ptr< CY_type > CY)
  {
    this->CY_.set (CY);
  }

  const AxesType::CZ_type& AxesType::
  CZ () const
  {
    return this->CZ_.get ();
  }

  AxesType::CZ_type& AxesType::
  CZ ()
  {
    return this->CZ_.get ();
  }

  void AxesType::
  CZ (const CZ_type& CZ)
  {
    this->CZ_.set (CZ);
  }

  void AxesType::
  CZ (::std::auto_ptr< CZ_type > CZ)
  {
    this->CZ_.set (CZ);
  }

  const AxesType::Rotation_optional& AxesType::
  Rotation () const
  {
    return this->Rotation_;
  }

  AxesType::Rotation_optional& AxesType::
  Rotation ()
  {
    return this->Rotation_;
  }

  void AxesType::
  Rotation (const Rotation_type& Rotation)
  {
    this->Rotation_.set (Rotation);
  }

  void AxesType::
  Rotation (const Rotation_optional& Rotation)
  {
    this->Rotation_ = Rotation;
  }

  void AxesType::
  Rotation (::std::auto_ptr< Rotation_type > Rotation)
  {
    this->Rotation_.set (Rotation);
  }


  // AxisDescriptionType
  // 

  const AxisDescriptionType::AxisType_type& AxisDescriptionType::
  AxisType () const
  {
    return this->AxisType_.get ();
  }

  AxisDescriptionType::AxisType_type& AxisDescriptionType::
  AxisType ()
  {
    return this->AxisType_.get ();
  }

  void AxisDescriptionType::
  AxisType (const AxisType_type& AxisType)
  {
    this->AxisType_.set (AxisType);
  }

  void AxisDescriptionType::
  AxisType (::std::auto_ptr< AxisType_type > AxisType)
  {
    this->AxisType_.set (AxisType);
  }

  const AxisDescriptionType::DataType_optional& AxisDescriptionType::
  DataType () const
  {
    return this->DataType_;
  }

  AxisDescriptionType::DataType_optional& AxisDescriptionType::
  DataType ()
  {
    return this->DataType_;
  }

  void AxisDescriptionType::
  DataType (const DataType_type& DataType)
  {
    this->DataType_.set (DataType);
  }

  void AxisDescriptionType::
  DataType (const DataType_optional& DataType)
  {
    this->DataType_ = DataType;
  }

  void AxisDescriptionType::
  DataType (::std::auto_ptr< DataType_type > DataType)
  {
    this->DataType_.set (DataType);
  }

  const AxisDescriptionType::Increment_optional& AxisDescriptionType::
  Increment () const
  {
    return this->Increment_;
  }

  AxisDescriptionType::Increment_optional& AxisDescriptionType::
  Increment ()
  {
    return this->Increment_;
  }

  void AxisDescriptionType::
  Increment (const Increment_type& Increment)
  {
    this->Increment_.set (Increment);
  }

  void AxisDescriptionType::
  Increment (const Increment_optional& Increment)
  {
    this->Increment_ = Increment;
  }

  const AxisDescriptionType::Offset_optional& AxisDescriptionType::
  Offset () const
  {
    return this->Offset_;
  }

  AxisDescriptionType::Offset_optional& AxisDescriptionType::
  Offset ()
  {
    return this->Offset_;
  }

  void AxisDescriptionType::
  Offset (const Offset_type& Offset)
  {
    this->Offset_.set (Offset);
  }

  void AxisDescriptionType::
  Offset (const Offset_optional& Offset)
  {
    this->Offset_ = Offset;
  }


  // InstrumentType
  // 

  const InstrumentType::Manufacturer_type& InstrumentType::
  Manufacturer () const
  {
    return this->Manufacturer_.get ();
  }

  InstrumentType::Manufacturer_type& InstrumentType::
  Manufacturer ()
  {
    return this->Manufacturer_.get ();
  }

  void InstrumentType::
  Manufacturer (const Manufacturer_type& Manufacturer)
  {
    this->Manufacturer_.set (Manufacturer);
  }

  void InstrumentType::
  Manufacturer (::std::auto_ptr< Manufacturer_type > Manufacturer)
  {
    this->Manufacturer_.set (Manufacturer);
  }

  const InstrumentType::Model_type& InstrumentType::
  Model () const
  {
    return this->Model_.get ();
  }

  InstrumentType::Model_type& InstrumentType::
  Model ()
  {
    return this->Model_.get ();
  }

  void InstrumentType::
  Model (const Model_type& Model)
  {
    this->Model_.set (Model);
  }

  void InstrumentType::
  Model (::std::auto_ptr< Model_type > Model)
  {
    this->Model_.set (Model);
  }

  const InstrumentType::Serial_type& InstrumentType::
  Serial () const
  {
    return this->Serial_.get ();
  }

  InstrumentType::Serial_type& InstrumentType::
  Serial ()
  {
    return this->Serial_.get ();
  }

  void InstrumentType::
  Serial (const Serial_type& Serial)
  {
    this->Serial_.set (Serial);
  }

  void InstrumentType::
  Serial (::std::auto_ptr< Serial_type > Serial)
  {
    this->Serial_.set (Serial);
  }

  const InstrumentType::Version_type& InstrumentType::
  Version () const
  {
    return this->Version_.get ();
  }

  InstrumentType::Version_type& InstrumentType::
  Version ()
  {
    return this->Version_.get ();
  }

  void InstrumentType::
  Version (const Version_type& Version)
  {
    this->Version_.set (Version);
  }

  void InstrumentType::
  Version (::std::auto_ptr< Version_type > Version)
  {
    this->Version_.set (Version);
  }


  // ProbingSystemType
  // 

  const ProbingSystemType::Type_type& ProbingSystemType::
  Type () const
  {
    return this->Type_.get ();
  }

  ProbingSystemType::Type_type& ProbingSystemType::
  Type ()
  {
    return this->Type_.get ();
  }

  void ProbingSystemType::
  Type (const Type_type& Type)
  {
    this->Type_.set (Type);
  }

  void ProbingSystemType::
  Type (::std::auto_ptr< Type_type > Type)
  {
    this->Type_.set (Type);
  }

  const ProbingSystemType::Identification_type& ProbingSystemType::
  Identification () const
  {
    return this->Identification_.get ();
  }

  ProbingSystemType::Identification_type& ProbingSystemType::
  Identification ()
  {
    return this->Identification_.get ();
  }

  void ProbingSystemType::
  Identification (const Identification_type& Identification)
  {
    this->Identification_.set (Identification);
  }

  void ProbingSystemType::
  Identification (::std::auto_ptr< Identification_type > Identification)
  {
    this->Identification_.set (Identification);
  }


  // DataListType
  // 

  const DataListType::Datum_sequence& DataListType::
  Datum () const
  {
    return this->Datum_;
  }

  DataListType::Datum_sequence& DataListType::
  Datum ()
  {
    return this->Datum_;
  }

  void DataListType::
  Datum (const Datum_sequence& Datum)
  {
    this->Datum_ = Datum;
  }


  // DataLinkType
  // 

  const DataLinkType::PointDataLink_type& DataLinkType::
  PointDataLink () const
  {
    return this->PointDataLink_.get ();
  }

  DataLinkType::PointDataLink_type& DataLinkType::
  PointDataLink ()
  {
    return this->PointDataLink_.get ();
  }

  void DataLinkType::
  PointDataLink (const PointDataLink_type& PointDataLink)
  {
    this->PointDataLink_.set (PointDataLink);
  }

  void DataLinkType::
  PointDataLink (::std::auto_ptr< PointDataLink_type > PointDataLink)
  {
    this->PointDataLink_.set (PointDataLink);
  }

  const DataLinkType::MD5ChecksumPointData_type& DataLinkType::
  MD5ChecksumPointData () const
  {
    return this->MD5ChecksumPointData_.get ();
  }

  DataLinkType::MD5ChecksumPointData_type& DataLinkType::
  MD5ChecksumPointData ()
  {
    return this->MD5ChecksumPointData_.get ();
  }

  void DataLinkType::
  MD5ChecksumPointData (const MD5ChecksumPointData_type& MD5ChecksumPointData)
  {
    this->MD5ChecksumPointData_.set (MD5ChecksumPointData);
  }

  void DataLinkType::
  MD5ChecksumPointData (::std::auto_ptr< MD5ChecksumPointData_type > MD5ChecksumPointData)
  {
    this->MD5ChecksumPointData_.set (MD5ChecksumPointData);
  }

  const DataLinkType::ValidPointsLink_optional& DataLinkType::
  ValidPointsLink () const
  {
    return this->ValidPointsLink_;
  }

  DataLinkType::ValidPointsLink_optional& DataLinkType::
  ValidPointsLink ()
  {
    return this->ValidPointsLink_;
  }

  void DataLinkType::
  ValidPointsLink (const ValidPointsLink_type& ValidPointsLink)
  {
    this->ValidPointsLink_.set (ValidPointsLink);
  }

  void DataLinkType::
  ValidPointsLink (const ValidPointsLink_optional& ValidPointsLink)
  {
    this->ValidPointsLink_ = ValidPointsLink;
  }

  void DataLinkType::
  ValidPointsLink (::std::auto_ptr< ValidPointsLink_type > ValidPointsLink)
  {
    this->ValidPointsLink_.set (ValidPointsLink);
  }

  const DataLinkType::MD5ChecksumValidPoints_optional& DataLinkType::
  MD5ChecksumValidPoints () const
  {
    return this->MD5ChecksumValidPoints_;
  }

  DataLinkType::MD5ChecksumValidPoints_optional& DataLinkType::
  MD5ChecksumValidPoints ()
  {
    return this->MD5ChecksumValidPoints_;
  }

  void DataLinkType::
  MD5ChecksumValidPoints (const MD5ChecksumValidPoints_type& MD5ChecksumValidPoints)
  {
    this->MD5ChecksumValidPoints_.set (MD5ChecksumValidPoints);
  }

  void DataLinkType::
  MD5ChecksumValidPoints (const MD5ChecksumValidPoints_optional& MD5ChecksumValidPoints)
  {
    this->MD5ChecksumValidPoints_ = MD5ChecksumValidPoints;
  }

  void DataLinkType::
  MD5ChecksumValidPoints (::std::auto_ptr< MD5ChecksumValidPoints_type > MD5ChecksumValidPoints)
  {
    this->MD5ChecksumValidPoints_.set (MD5ChecksumValidPoints);
  }


  // MatrixDimensionType
  // 

  const MatrixDimensionType::SizeX_type& MatrixDimensionType::
  SizeX () const
  {
    return this->SizeX_.get ();
  }

  MatrixDimensionType::SizeX_type& MatrixDimensionType::
  SizeX ()
  {
    return this->SizeX_.get ();
  }

  void MatrixDimensionType::
  SizeX (const SizeX_type& SizeX)
  {
    this->SizeX_.set (SizeX);
  }

  const MatrixDimensionType::SizeY_type& MatrixDimensionType::
  SizeY () const
  {
    return this->SizeY_.get ();
  }

  MatrixDimensionType::SizeY_type& MatrixDimensionType::
  SizeY ()
  {
    return this->SizeY_.get ();
  }

  void MatrixDimensionType::
  SizeY (const SizeY_type& SizeY)
  {
    this->SizeY_.set (SizeY);
  }

  const MatrixDimensionType::SizeZ_type& MatrixDimensionType::
  SizeZ () const
  {
    return this->SizeZ_.get ();
  }

  MatrixDimensionType::SizeZ_type& MatrixDimensionType::
  SizeZ ()
  {
    return this->SizeZ_.get ();
  }

  void MatrixDimensionType::
  SizeZ (const SizeZ_type& SizeZ)
  {
    this->SizeZ_.set (SizeZ);
  }


  // RotationType
  // 

  const RotationType::r11_type& RotationType::
  r11 () const
  {
    return this->r11_.get ();
  }

  RotationType::r11_type& RotationType::
  r11 ()
  {
    return this->r11_.get ();
  }

  void RotationType::
  r11 (const r11_type& r11)
  {
    this->r11_.set (r11);
  }

  void RotationType::
  r11 (::std::auto_ptr< r11_type > r11)
  {
    this->r11_.set (r11);
  }

  const RotationType::r12_type& RotationType::
  r12 () const
  {
    return this->r12_.get ();
  }

  RotationType::r12_type& RotationType::
  r12 ()
  {
    return this->r12_.get ();
  }

  void RotationType::
  r12 (const r12_type& r12)
  {
    this->r12_.set (r12);
  }

  void RotationType::
  r12 (::std::auto_ptr< r12_type > r12)
  {
    this->r12_.set (r12);
  }

  const RotationType::r13_type& RotationType::
  r13 () const
  {
    return this->r13_.get ();
  }

  RotationType::r13_type& RotationType::
  r13 ()
  {
    return this->r13_.get ();
  }

  void RotationType::
  r13 (const r13_type& r13)
  {
    this->r13_.set (r13);
  }

  void RotationType::
  r13 (::std::auto_ptr< r13_type > r13)
  {
    this->r13_.set (r13);
  }

  const RotationType::r21_type& RotationType::
  r21 () const
  {
    return this->r21_.get ();
  }

  RotationType::r21_type& RotationType::
  r21 ()
  {
    return this->r21_.get ();
  }

  void RotationType::
  r21 (const r21_type& r21)
  {
    this->r21_.set (r21);
  }

  void RotationType::
  r21 (::std::auto_ptr< r21_type > r21)
  {
    this->r21_.set (r21);
  }

  const RotationType::r22_type& RotationType::
  r22 () const
  {
    return this->r22_.get ();
  }

  RotationType::r22_type& RotationType::
  r22 ()
  {
    return this->r22_.get ();
  }

  void RotationType::
  r22 (const r22_type& r22)
  {
    this->r22_.set (r22);
  }

  void RotationType::
  r22 (::std::auto_ptr< r22_type > r22)
  {
    this->r22_.set (r22);
  }

  const RotationType::r23_type& RotationType::
  r23 () const
  {
    return this->r23_.get ();
  }

  RotationType::r23_type& RotationType::
  r23 ()
  {
    return this->r23_.get ();
  }

  void RotationType::
  r23 (const r23_type& r23)
  {
    this->r23_.set (r23);
  }

  void RotationType::
  r23 (::std::auto_ptr< r23_type > r23)
  {
    this->r23_.set (r23);
  }

  const RotationType::r31_type& RotationType::
  r31 () const
  {
    return this->r31_.get ();
  }

  RotationType::r31_type& RotationType::
  r31 ()
  {
    return this->r31_.get ();
  }

  void RotationType::
  r31 (const r31_type& r31)
  {
    this->r31_.set (r31);
  }

  void RotationType::
  r31 (::std::auto_ptr< r31_type > r31)
  {
    this->r31_.set (r31);
  }

  const RotationType::r32_type& RotationType::
  r32 () const
  {
    return this->r32_.get ();
  }

  RotationType::r32_type& RotationType::
  r32 ()
  {
    return this->r32_.get ();
  }

  void RotationType::
  r32 (const r32_type& r32)
  {
    this->r32_.set (r32);
  }

  void RotationType::
  r32 (::std::auto_ptr< r32_type > r32)
  {
    this->r32_.set (r32);
  }

  const RotationType::r33_type& RotationType::
  r33 () const
  {
    return this->r33_.get ();
  }

  RotationType::r33_type& RotationType::
  r33 ()
  {
    return this->r33_.get ();
  }

  void RotationType::
  r33 (const r33_type& r33)
  {
    this->r33_.set (r33);
  }

  void RotationType::
  r33 (::std::auto_ptr< r33_type > r33)
  {
    this->r33_.set (r33);
  }


  // RotationMatrixElementType
  // 


  // FeatureType
  // 


  // AxisType
  // 

  AxisType::
  AxisType (value v)
  : ::xml_schema::token (_xsd_AxisType_literals_[v])
  {
  }

  AxisType::
  AxisType (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  AxisType::
  AxisType (const AxisType& v,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  AxisType& AxisType::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_AxisType_literals_[v]);

    return *this;
  }


  // DataType
  // 

  DataType::
  DataType (value v)
  : ::xml_schema::token (_xsd_DataType_literals_[v])
  {
  }

  DataType::
  DataType (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  DataType::
  DataType (const DataType& v,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  DataType& DataType::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_DataType_literals_[v]);

    return *this;
  }


  // Type
  // 

  Type::
  Type (value v)
  : ::xml_schema::token (_xsd_Type_literals_[v])
  {
  }

  Type::
  Type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  Type::
  Type (const Type& v,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  Type& Type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_Type_literals_[v]);

    return *this;
  }


  // Datum
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xsd
{
  // Record1Type
  //

  Record1Type::
  Record1Type (const Revision_type& Revision,
               const FeatureType_type& FeatureType,
               const Axes_type& Axes)
  : ::xml_schema::type (),
    Revision_ (Revision, ::xml_schema::flags (), this),
    FeatureType_ (FeatureType, ::xml_schema::flags (), this),
    Axes_ (Axes, ::xml_schema::flags (), this)
  {
  }

  Record1Type::
  Record1Type (const Record1Type& x,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    Revision_ (x.Revision_, f, this),
    FeatureType_ (x.FeatureType_, f, this),
    Axes_ (x.Axes_, f, this)
  {
  }

  Record1Type::
  Record1Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Revision_ (f, this),
    FeatureType_ (f, this),
    Axes_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void Record1Type::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Revision
      //
      if (n.name () == L"Revision" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Revision_type > r (
          Revision_traits::create (i, f, this));

        if (!Revision_.present ())
        {
          this->Revision (r);
          continue;
        }
      }

      // FeatureType
      //
      if (n.name () == L"FeatureType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< FeatureType_type > r (
          FeatureType_traits::create (i, f, this));

        if (!FeatureType_.present ())
        {
          this->FeatureType (r);
          continue;
        }
      }

      // Axes
      //
      if (n.name () == L"Axes" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Axes_type > r (
          Axes_traits::create (i, f, this));

        if (!Axes_.present ())
        {
          this->Axes (r);
          continue;
        }
      }

      break;
    }

    if (!Revision_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Revision",
        L"");
    }

    if (!FeatureType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"FeatureType",
        L"");
    }

    if (!Axes_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Axes",
        L"");
    }
  }

  Record1Type* Record1Type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new Record1Type (*this, f, c);
  }

  bool
  operator== (const Record1Type& x, const Record1Type& y)
  {
    return x.Revision () == y.Revision () &&
    x.FeatureType () == y.FeatureType () &&
    x.Axes () == y.Axes ();
  }

  bool
  operator!= (const Record1Type& x, const Record1Type& y)
  {
    return !(x == y);
  }

  // ISO5436_2Type
  //

  ISO5436_2Type::
  ISO5436_2Type (const Record1_type& Record1,
                 const Record3_type& Record3,
                 const Record4_type& Record4)
  : ::xml_schema::type (),
    Record1_ (Record1, ::xml_schema::flags (), this),
    Record2_ (::xml_schema::flags (), this),
    Record3_ (Record3, ::xml_schema::flags (), this),
    Record4_ (Record4, ::xml_schema::flags (), this),
    VendorSpecific_ (::xml_schema::flags (), this)
  {
  }

  ISO5436_2Type::
  ISO5436_2Type (const ISO5436_2Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    Record1_ (x.Record1_, f, this),
    Record2_ (x.Record2_, f, this),
    Record3_ (x.Record3_, f, this),
    Record4_ (x.Record4_, f, this),
    VendorSpecific_ (x.VendorSpecific_, f, this)
  {
  }

  ISO5436_2Type::
  ISO5436_2Type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Record1_ (f, this),
    Record2_ (f, this),
    Record3_ (f, this),
    Record4_ (f, this),
    VendorSpecific_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void ISO5436_2Type::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Record1
      //
      if (n.name () == L"Record1" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Record1_type > r (
          Record1_traits::create (i, f, this));

        if (!Record1_.present ())
        {
          this->Record1 (r);
          continue;
        }
      }

      // Record2
      //
      if (n.name () == L"Record2" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Record2_type > r (
          Record2_traits::create (i, f, this));

        if (!this->Record2 ())
        {
          this->Record2 (r);
          continue;
        }
      }

      // Record3
      //
      if (n.name () == L"Record3" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Record3_type > r (
          Record3_traits::create (i, f, this));

        if (!Record3_.present ())
        {
          this->Record3 (r);
          continue;
        }
      }

      // Record4
      //
      if (n.name () == L"Record4" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Record4_type > r (
          Record4_traits::create (i, f, this));

        if (!Record4_.present ())
        {
          this->Record4 (r);
          continue;
        }
      }

      // VendorSpecific
      //
      if (n.name () == L"VendorSpecific" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< VendorSpecific_type > r (
          VendorSpecific_traits::create (i, f, this));

        this->VendorSpecific ().push_back (r);
        continue;
      }

      break;
    }

    if (!Record1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Record1",
        L"");
    }

    if (!Record3_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Record3",
        L"");
    }

    if (!Record4_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Record4",
        L"");
    }
  }

  ISO5436_2Type* ISO5436_2Type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ISO5436_2Type (*this, f, c);
  }

  bool
  operator== (const ISO5436_2Type& x, const ISO5436_2Type& y)
  {
    return x.Record1 () == y.Record1 () &&
    x.Record2 () == y.Record2 () &&
    x.Record3 () == y.Record3 () &&
    x.Record4 () == y.Record4 () &&
    x.VendorSpecific () == y.VendorSpecific ();
  }

  bool
  operator!= (const ISO5436_2Type& x, const ISO5436_2Type& y)
  {
    return !(x == y);
  }

  // Record2Type
  //

  Record2Type::
  Record2Type (const Date_type& Date,
               const Instrument_type& Instrument,
               const CalibrationDate_type& CalibrationDate,
               const ProbingSystem_type& ProbingSystem)
  : ::xml_schema::type (),
    Date_ (Date, ::xml_schema::flags (), this),
    Creator_ (::xml_schema::flags (), this),
    Instrument_ (Instrument, ::xml_schema::flags (), this),
    CalibrationDate_ (CalibrationDate, ::xml_schema::flags (), this),
    ProbingSystem_ (ProbingSystem, ::xml_schema::flags (), this),
    Comment_ (::xml_schema::flags (), this)
  {
  }

  Record2Type::
  Record2Type (const Record2Type& x,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    Date_ (x.Date_, f, this),
    Creator_ (x.Creator_, f, this),
    Instrument_ (x.Instrument_, f, this),
    CalibrationDate_ (x.CalibrationDate_, f, this),
    ProbingSystem_ (x.ProbingSystem_, f, this),
    Comment_ (x.Comment_, f, this)
  {
  }

  Record2Type::
  Record2Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Date_ (f, this),
    Creator_ (f, this),
    Instrument_ (f, this),
    CalibrationDate_ (f, this),
    ProbingSystem_ (f, this),
    Comment_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void Record2Type::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Date
      //
      if (n.name () == L"Date" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Date_type > r (
          Date_traits::create (i, f, this));

        if (!Date_.present ())
        {
          this->Date (r);
          continue;
        }
      }

      // Creator
      //
      if (n.name () == L"Creator" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Creator_type > r (
          Creator_traits::create (i, f, this));

        if (!this->Creator ())
        {
          this->Creator (r);
          continue;
        }
      }

      // Instrument
      //
      if (n.name () == L"Instrument" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Instrument_type > r (
          Instrument_traits::create (i, f, this));

        if (!Instrument_.present ())
        {
          this->Instrument (r);
          continue;
        }
      }

      // CalibrationDate
      //
      if (n.name () == L"CalibrationDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CalibrationDate_type > r (
          CalibrationDate_traits::create (i, f, this));

        if (!CalibrationDate_.present ())
        {
          this->CalibrationDate (r);
          continue;
        }
      }

      // ProbingSystem
      //
      if (n.name () == L"ProbingSystem" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ProbingSystem_type > r (
          ProbingSystem_traits::create (i, f, this));

        if (!ProbingSystem_.present ())
        {
          this->ProbingSystem (r);
          continue;
        }
      }

      // Comment
      //
      if (n.name () == L"Comment" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Comment_type > r (
          Comment_traits::create (i, f, this));

        if (!this->Comment ())
        {
          this->Comment (r);
          continue;
        }
      }

      break;
    }

    if (!Date_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Date",
        L"");
    }

    if (!Instrument_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Instrument",
        L"");
    }

    if (!CalibrationDate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"CalibrationDate",
        L"");
    }

    if (!ProbingSystem_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"ProbingSystem",
        L"");
    }
  }

  Record2Type* Record2Type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new Record2Type (*this, f, c);
  }

  bool
  operator== (const Record2Type& x, const Record2Type& y)
  {
    return x.Date () == y.Date () &&
    x.Creator () == y.Creator () &&
    x.Instrument () == y.Instrument () &&
    x.CalibrationDate () == y.CalibrationDate () &&
    x.ProbingSystem () == y.ProbingSystem () &&
    x.Comment () == y.Comment ();
  }

  bool
  operator!= (const Record2Type& x, const Record2Type& y)
  {
    return !(x == y);
  }

  // Record3Type
  //

  Record3Type::
  Record3Type ()
  : ::xml_schema::type (),
    MatrixDimension_ (::xml_schema::flags (), this),
    ListDimension_ (::xml_schema::flags (), this),
    DataLink_ (::xml_schema::flags (), this),
    DataList_ (::xml_schema::flags (), this)
  {
  }

  Record3Type::
  Record3Type (const Record3Type& x,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    MatrixDimension_ (x.MatrixDimension_, f, this),
    ListDimension_ (x.ListDimension_, f, this),
    DataLink_ (x.DataLink_, f, this),
    DataList_ (x.DataList_, f, this)
  {
  }

  Record3Type::
  Record3Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MatrixDimension_ (f, this),
    ListDimension_ (f, this),
    DataLink_ (f, this),
    DataList_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void Record3Type::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // MatrixDimension
      //
      if (n.name () == L"MatrixDimension" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MatrixDimension_type > r (
          MatrixDimension_traits::create (i, f, this));

        if (!this->MatrixDimension ())
        {
          this->MatrixDimension (r);
          continue;
        }
      }

      // ListDimension
      //
      if (n.name () == L"ListDimension" && n.namespace_ ().empty ())
      {
        if (!this->ListDimension ())
        {
          this->ListDimension (ListDimension_traits::create (i, f, this));
          continue;
        }
      }

      // DataLink
      //
      if (n.name () == L"DataLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DataLink_type > r (
          DataLink_traits::create (i, f, this));

        if (!this->DataLink ())
        {
          this->DataLink (r);
          continue;
        }
      }

      // DataList
      //
      if (n.name () == L"DataList" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DataList_type > r (
          DataList_traits::create (i, f, this));

        if (!this->DataList ())
        {
          this->DataList (r);
          continue;
        }
      }

      break;
    }
  }

  Record3Type* Record3Type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new Record3Type (*this, f, c);
  }

  bool
  operator== (const Record3Type& x, const Record3Type& y)
  {
    return x.MatrixDimension () == y.MatrixDimension () &&
    x.ListDimension () == y.ListDimension () &&
    x.DataLink () == y.DataLink () &&
    x.DataList () == y.DataList ();
  }

  bool
  operator!= (const Record3Type& x, const Record3Type& y)
  {
    return !(x == y);
  }

  // Record4Type
  //

  Record4Type::
  Record4Type (const ChecksumFile_type& ChecksumFile)
  : ::xml_schema::type (),
    ChecksumFile_ (ChecksumFile, ::xml_schema::flags (), this)
  {
  }

  Record4Type::
  Record4Type (const Record4Type& x,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    ChecksumFile_ (x.ChecksumFile_, f, this)
  {
  }

  Record4Type::
  Record4Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ChecksumFile_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void Record4Type::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // ChecksumFile
      //
      if (n.name () == L"ChecksumFile" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ChecksumFile_type > r (
          ChecksumFile_traits::create (i, f, this));

        if (!ChecksumFile_.present ())
        {
          this->ChecksumFile (r);
          continue;
        }
      }

      break;
    }

    if (!ChecksumFile_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"ChecksumFile",
        L"");
    }
  }

  Record4Type* Record4Type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new Record4Type (*this, f, c);
  }

  bool
  operator== (const Record4Type& x, const Record4Type& y)
  {
    return x.ChecksumFile () == y.ChecksumFile ();
  }

  bool
  operator!= (const Record4Type& x, const Record4Type& y)
  {
    return !(x == y);
  }

  // AxesType
  //

  AxesType::
  AxesType (const CX_type& CX,
            const CY_type& CY,
            const CZ_type& CZ)
  : ::xml_schema::type (),
    CX_ (CX, ::xml_schema::flags (), this),
    CY_ (CY, ::xml_schema::flags (), this),
    CZ_ (CZ, ::xml_schema::flags (), this),
    Rotation_ (::xml_schema::flags (), this)
  {
  }

  AxesType::
  AxesType (const AxesType& x,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    CX_ (x.CX_, f, this),
    CY_ (x.CY_, f, this),
    CZ_ (x.CZ_, f, this),
    Rotation_ (x.Rotation_, f, this)
  {
  }

  AxesType::
  AxesType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CX_ (f, this),
    CY_ (f, this),
    CZ_ (f, this),
    Rotation_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void AxesType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // CX
      //
      if (n.name () == L"CX" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CX_type > r (
          CX_traits::create (i, f, this));

        if (!CX_.present ())
        {
          this->CX (r);
          continue;
        }
      }

      // CY
      //
      if (n.name () == L"CY" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CY_type > r (
          CY_traits::create (i, f, this));

        if (!CY_.present ())
        {
          this->CY (r);
          continue;
        }
      }

      // CZ
      //
      if (n.name () == L"CZ" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CZ_type > r (
          CZ_traits::create (i, f, this));

        if (!CZ_.present ())
        {
          this->CZ (r);
          continue;
        }
      }

      // Rotation
      //
      if (n.name () == L"Rotation" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Rotation_type > r (
          Rotation_traits::create (i, f, this));

        if (!this->Rotation ())
        {
          this->Rotation (r);
          continue;
        }
      }

      break;
    }

    if (!CX_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"CX",
        L"");
    }

    if (!CY_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"CY",
        L"");
    }

    if (!CZ_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"CZ",
        L"");
    }
  }

  AxesType* AxesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new AxesType (*this, f, c);
  }

  bool
  operator== (const AxesType& x, const AxesType& y)
  {
    return x.CX () == y.CX () &&
    x.CY () == y.CY () &&
    x.CZ () == y.CZ () &&
    x.Rotation () == y.Rotation ();
  }

  bool
  operator!= (const AxesType& x, const AxesType& y)
  {
    return !(x == y);
  }

  // AxisDescriptionType
  //

  AxisDescriptionType::
  AxisDescriptionType (const AxisType_type& AxisType)
  : ::xml_schema::type (),
    AxisType_ (AxisType, ::xml_schema::flags (), this),
    DataType_ (::xml_schema::flags (), this),
    Increment_ (::xml_schema::flags (), this),
    Offset_ (::xml_schema::flags (), this)
  {
  }

  AxisDescriptionType::
  AxisDescriptionType (const AxisDescriptionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    AxisType_ (x.AxisType_, f, this),
    DataType_ (x.DataType_, f, this),
    Increment_ (x.Increment_, f, this),
    Offset_ (x.Offset_, f, this)
  {
  }

  AxisDescriptionType::
  AxisDescriptionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AxisType_ (f, this),
    DataType_ (f, this),
    Increment_ (f, this),
    Offset_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void AxisDescriptionType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // AxisType
      //
      if (n.name () == L"AxisType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AxisType_type > r (
          AxisType_traits::create (i, f, this));

        if (!AxisType_.present ())
        {
          this->AxisType (r);
          continue;
        }
      }

      // DataType
      //
      if (n.name () == L"DataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DataType_type > r (
          DataType_traits::create (i, f, this));

        if (!this->DataType ())
        {
          this->DataType (r);
          continue;
        }
      }

      // Increment
      //
      if (n.name () == L"Increment" && n.namespace_ ().empty ())
      {
        if (!this->Increment ())
        {
          this->Increment (Increment_traits::create (i, f, this));
          continue;
        }
      }

      // Offset
      //
      if (n.name () == L"Offset" && n.namespace_ ().empty ())
      {
        if (!this->Offset ())
        {
          this->Offset (Offset_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!AxisType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"AxisType",
        L"");
    }
  }

  AxisDescriptionType* AxisDescriptionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new AxisDescriptionType (*this, f, c);
  }

  bool
  operator== (const AxisDescriptionType& x, const AxisDescriptionType& y)
  {
    return x.AxisType () == y.AxisType () &&
    x.DataType () == y.DataType () &&
    x.Increment () == y.Increment () &&
    x.Offset () == y.Offset ();
  }

  bool
  operator!= (const AxisDescriptionType& x, const AxisDescriptionType& y)
  {
    return !(x == y);
  }

  // InstrumentType
  //

  InstrumentType::
  InstrumentType (const Manufacturer_type& Manufacturer,
                  const Model_type& Model,
                  const Serial_type& Serial,
                  const Version_type& Version)
  : ::xml_schema::type (),
    Manufacturer_ (Manufacturer, ::xml_schema::flags (), this),
    Model_ (Model, ::xml_schema::flags (), this),
    Serial_ (Serial, ::xml_schema::flags (), this),
    Version_ (Version, ::xml_schema::flags (), this)
  {
  }

  InstrumentType::
  InstrumentType (const InstrumentType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    Manufacturer_ (x.Manufacturer_, f, this),
    Model_ (x.Model_, f, this),
    Serial_ (x.Serial_, f, this),
    Version_ (x.Version_, f, this)
  {
  }

  InstrumentType::
  InstrumentType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Manufacturer_ (f, this),
    Model_ (f, this),
    Serial_ (f, this),
    Version_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void InstrumentType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Manufacturer
      //
      if (n.name () == L"Manufacturer" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Manufacturer_type > r (
          Manufacturer_traits::create (i, f, this));

        if (!Manufacturer_.present ())
        {
          this->Manufacturer (r);
          continue;
        }
      }

      // Model
      //
      if (n.name () == L"Model" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Model_type > r (
          Model_traits::create (i, f, this));

        if (!Model_.present ())
        {
          this->Model (r);
          continue;
        }
      }

      // Serial
      //
      if (n.name () == L"Serial" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Serial_type > r (
          Serial_traits::create (i, f, this));

        if (!Serial_.present ())
        {
          this->Serial (r);
          continue;
        }
      }

      // Version
      //
      if (n.name () == L"Version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Version_type > r (
          Version_traits::create (i, f, this));

        if (!Version_.present ())
        {
          this->Version (r);
          continue;
        }
      }

      break;
    }

    if (!Manufacturer_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Manufacturer",
        L"");
    }

    if (!Model_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Model",
        L"");
    }

    if (!Serial_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Serial",
        L"");
    }

    if (!Version_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Version",
        L"");
    }
  }

  InstrumentType* InstrumentType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new InstrumentType (*this, f, c);
  }

  bool
  operator== (const InstrumentType& x, const InstrumentType& y)
  {
    return x.Manufacturer () == y.Manufacturer () &&
    x.Model () == y.Model () &&
    x.Serial () == y.Serial () &&
    x.Version () == y.Version ();
  }

  bool
  operator!= (const InstrumentType& x, const InstrumentType& y)
  {
    return !(x == y);
  }

  // ProbingSystemType
  //

  ProbingSystemType::
  ProbingSystemType (const Type_type& Type,
                     const Identification_type& Identification)
  : ::xml_schema::type (),
    Type_ (Type, ::xml_schema::flags (), this),
    Identification_ (Identification, ::xml_schema::flags (), this)
  {
  }

  ProbingSystemType::
  ProbingSystemType (const ProbingSystemType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    Type_ (x.Type_, f, this),
    Identification_ (x.Identification_, f, this)
  {
  }

  ProbingSystemType::
  ProbingSystemType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Type_ (f, this),
    Identification_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void ProbingSystemType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Type
      //
      if (n.name () == L"Type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Type_type > r (
          Type_traits::create (i, f, this));

        if (!Type_.present ())
        {
          this->Type (r);
          continue;
        }
      }

      // Identification
      //
      if (n.name () == L"Identification" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Identification_type > r (
          Identification_traits::create (i, f, this));

        if (!Identification_.present ())
        {
          this->Identification (r);
          continue;
        }
      }

      break;
    }

    if (!Type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Type",
        L"");
    }

    if (!Identification_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Identification",
        L"");
    }
  }

  ProbingSystemType* ProbingSystemType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ProbingSystemType (*this, f, c);
  }

  bool
  operator== (const ProbingSystemType& x, const ProbingSystemType& y)
  {
    return x.Type () == y.Type () &&
    x.Identification () == y.Identification ();
  }

  bool
  operator!= (const ProbingSystemType& x, const ProbingSystemType& y)
  {
    return !(x == y);
  }

  // DataListType
  //

  DataListType::
  DataListType ()
  : ::xml_schema::type (),
    Datum_ (::xml_schema::flags (), this)
  {
  }

  DataListType::
  DataListType (const DataListType& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    Datum_ (x.Datum_, f, this)
  {
  }

  DataListType::
  DataListType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Datum_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void DataListType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Datum
      //
      if (n.name () == L"Datum" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Datum_type > r (
          Datum_traits::create (i, f, this));

        this->Datum ().push_back (r);
        continue;
      }

      break;
    }
  }

  DataListType* DataListType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new DataListType (*this, f, c);
  }

  bool
  operator== (const DataListType& x, const DataListType& y)
  {
    return x.Datum () == y.Datum ();
  }

  bool
  operator!= (const DataListType& x, const DataListType& y)
  {
    return !(x == y);
  }

  // DataLinkType
  //

  DataLinkType::
  DataLinkType (const PointDataLink_type& PointDataLink,
                const MD5ChecksumPointData_type& MD5ChecksumPointData)
  : ::xml_schema::type (),
    PointDataLink_ (PointDataLink, ::xml_schema::flags (), this),
    MD5ChecksumPointData_ (MD5ChecksumPointData, ::xml_schema::flags (), this),
    ValidPointsLink_ (::xml_schema::flags (), this),
    MD5ChecksumValidPoints_ (::xml_schema::flags (), this)
  {
  }

  DataLinkType::
  DataLinkType (const DataLinkType& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    PointDataLink_ (x.PointDataLink_, f, this),
    MD5ChecksumPointData_ (x.MD5ChecksumPointData_, f, this),
    ValidPointsLink_ (x.ValidPointsLink_, f, this),
    MD5ChecksumValidPoints_ (x.MD5ChecksumValidPoints_, f, this)
  {
  }

  DataLinkType::
  DataLinkType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    PointDataLink_ (f, this),
    MD5ChecksumPointData_ (f, this),
    ValidPointsLink_ (f, this),
    MD5ChecksumValidPoints_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void DataLinkType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // PointDataLink
      //
      if (n.name () == L"PointDataLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PointDataLink_type > r (
          PointDataLink_traits::create (i, f, this));

        if (!PointDataLink_.present ())
        {
          this->PointDataLink (r);
          continue;
        }
      }

      // MD5ChecksumPointData
      //
      if (n.name () == L"MD5ChecksumPointData" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MD5ChecksumPointData_type > r (
          MD5ChecksumPointData_traits::create (i, f, this));

        if (!MD5ChecksumPointData_.present ())
        {
          this->MD5ChecksumPointData (r);
          continue;
        }
      }

      // ValidPointsLink
      //
      if (n.name () == L"ValidPointsLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ValidPointsLink_type > r (
          ValidPointsLink_traits::create (i, f, this));

        if (!this->ValidPointsLink ())
        {
          this->ValidPointsLink (r);
          continue;
        }
      }

      // MD5ChecksumValidPoints
      //
      if (n.name () == L"MD5ChecksumValidPoints" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MD5ChecksumValidPoints_type > r (
          MD5ChecksumValidPoints_traits::create (i, f, this));

        if (!this->MD5ChecksumValidPoints ())
        {
          this->MD5ChecksumValidPoints (r);
          continue;
        }
      }

      break;
    }

    if (!PointDataLink_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"PointDataLink",
        L"");
    }

    if (!MD5ChecksumPointData_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"MD5ChecksumPointData",
        L"");
    }
  }

  DataLinkType* DataLinkType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new DataLinkType (*this, f, c);
  }

  bool
  operator== (const DataLinkType& x, const DataLinkType& y)
  {
    return x.PointDataLink () == y.PointDataLink () &&
    x.MD5ChecksumPointData () == y.MD5ChecksumPointData () &&
    x.ValidPointsLink () == y.ValidPointsLink () &&
    x.MD5ChecksumValidPoints () == y.MD5ChecksumValidPoints ();
  }

  bool
  operator!= (const DataLinkType& x, const DataLinkType& y)
  {
    return !(x == y);
  }

  // MatrixDimensionType
  //

  MatrixDimensionType::
  MatrixDimensionType (const SizeX_type& SizeX,
                       const SizeY_type& SizeY,
                       const SizeZ_type& SizeZ)
  : ::xml_schema::type (),
    SizeX_ (SizeX, ::xml_schema::flags (), this),
    SizeY_ (SizeY, ::xml_schema::flags (), this),
    SizeZ_ (SizeZ, ::xml_schema::flags (), this)
  {
  }

  MatrixDimensionType::
  MatrixDimensionType (const MatrixDimensionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    SizeX_ (x.SizeX_, f, this),
    SizeY_ (x.SizeY_, f, this),
    SizeZ_ (x.SizeZ_, f, this)
  {
  }

  MatrixDimensionType::
  MatrixDimensionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SizeX_ (f, this),
    SizeY_ (f, this),
    SizeZ_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void MatrixDimensionType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // SizeX
      //
      if (n.name () == L"SizeX" && n.namespace_ ().empty ())
      {
        if (!SizeX_.present ())
        {
          this->SizeX (SizeX_traits::create (i, f, this));
          continue;
        }
      }

      // SizeY
      //
      if (n.name () == L"SizeY" && n.namespace_ ().empty ())
      {
        if (!SizeY_.present ())
        {
          this->SizeY (SizeY_traits::create (i, f, this));
          continue;
        }
      }

      // SizeZ
      //
      if (n.name () == L"SizeZ" && n.namespace_ ().empty ())
      {
        if (!SizeZ_.present ())
        {
          this->SizeZ (SizeZ_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!SizeX_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SizeX",
        L"");
    }

    if (!SizeY_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SizeY",
        L"");
    }

    if (!SizeZ_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SizeZ",
        L"");
    }
  }

  MatrixDimensionType* MatrixDimensionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new MatrixDimensionType (*this, f, c);
  }

  bool
  operator== (const MatrixDimensionType& x, const MatrixDimensionType& y)
  {
    return x.SizeX () == y.SizeX () &&
    x.SizeY () == y.SizeY () &&
    x.SizeZ () == y.SizeZ ();
  }

  bool
  operator!= (const MatrixDimensionType& x, const MatrixDimensionType& y)
  {
    return !(x == y);
  }

  // RotationType
  //

  RotationType::
  RotationType (const r11_type& r11,
                const r12_type& r12,
                const r13_type& r13,
                const r21_type& r21,
                const r22_type& r22,
                const r23_type& r23,
                const r31_type& r31,
                const r32_type& r32,
                const r33_type& r33)
  : ::xml_schema::type (),
    r11_ (r11, ::xml_schema::flags (), this),
    r12_ (r12, ::xml_schema::flags (), this),
    r13_ (r13, ::xml_schema::flags (), this),
    r21_ (r21, ::xml_schema::flags (), this),
    r22_ (r22, ::xml_schema::flags (), this),
    r23_ (r23, ::xml_schema::flags (), this),
    r31_ (r31, ::xml_schema::flags (), this),
    r32_ (r32, ::xml_schema::flags (), this),
    r33_ (r33, ::xml_schema::flags (), this)
  {
  }

  RotationType::
  RotationType (const RotationType& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::type (x, f, c),
    r11_ (x.r11_, f, this),
    r12_ (x.r12_, f, this),
    r13_ (x.r13_, f, this),
    r21_ (x.r21_, f, this),
    r22_ (x.r22_, f, this),
    r23_ (x.r23_, f, this),
    r31_ (x.r31_, f, this),
    r32_ (x.r32_, f, this),
    r33_ (x.r33_, f, this)
  {
  }

  RotationType::
  RotationType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    r11_ (f, this),
    r12_ (f, this),
    r13_ (f, this),
    r21_ (f, this),
    r22_ (f, this),
    r23_ (f, this),
    r31_ (f, this),
    r32_ (f, this),
    r33_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
      this->parse (p, f);
    }
  }

  void RotationType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // r11
      //
      if (n.name () == L"r11" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< r11_type > r (
          r11_traits::create (i, f, this));

        if (!r11_.present ())
        {
          this->r11 (r);
          continue;
        }
      }

      // r12
      //
      if (n.name () == L"r12" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< r12_type > r (
          r12_traits::create (i, f, this));

        if (!r12_.present ())
        {
          this->r12 (r);
          continue;
        }
      }

      // r13
      //
      if (n.name () == L"r13" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< r13_type > r (
          r13_traits::create (i, f, this));

        if (!r13_.present ())
        {
          this->r13 (r);
          continue;
        }
      }

      // r21
      //
      if (n.name () == L"r21" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< r21_type > r (
          r21_traits::create (i, f, this));

        if (!r21_.present ())
        {
          this->r21 (r);
          continue;
        }
      }

      // r22
      //
      if (n.name () == L"r22" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< r22_type > r (
          r22_traits::create (i, f, this));

        if (!r22_.present ())
        {
          this->r22 (r);
          continue;
        }
      }

      // r23
      //
      if (n.name () == L"r23" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< r23_type > r (
          r23_traits::create (i, f, this));

        if (!r23_.present ())
        {
          this->r23 (r);
          continue;
        }
      }

      // r31
      //
      if (n.name () == L"r31" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< r31_type > r (
          r31_traits::create (i, f, this));

        if (!r31_.present ())
        {
          this->r31 (r);
          continue;
        }
      }

      // r32
      //
      if (n.name () == L"r32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< r32_type > r (
          r32_traits::create (i, f, this));

        if (!r32_.present ())
        {
          this->r32 (r);
          continue;
        }
      }

      // r33
      //
      if (n.name () == L"r33" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< r33_type > r (
          r33_traits::create (i, f, this));

        if (!r33_.present ())
        {
          this->r33 (r);
          continue;
        }
      }

      break;
    }

    if (!r11_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"r11",
        L"");
    }

    if (!r12_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"r12",
        L"");
    }

    if (!r13_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"r13",
        L"");
    }

    if (!r21_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"r21",
        L"");
    }

    if (!r22_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"r22",
        L"");
    }

    if (!r23_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"r23",
        L"");
    }

    if (!r31_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"r31",
        L"");
    }

    if (!r32_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"r32",
        L"");
    }

    if (!r33_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"r33",
        L"");
    }
  }

  RotationType* RotationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new RotationType (*this, f, c);
  }

  bool
  operator== (const RotationType& x, const RotationType& y)
  {
    return x.r11 () == y.r11 () &&
    x.r12 () == y.r12 () &&
    x.r13 () == y.r13 () &&
    x.r21 () == y.r21 () &&
    x.r22 () == y.r22 () &&
    x.r23 () == y.r23 () &&
    x.r31 () == y.r31 () &&
    x.r32 () == y.r32 () &&
    x.r33 () == y.r33 ();
  }

  bool
  operator!= (const RotationType& x, const RotationType& y)
  {
    return !(x == y);
  }

  // RotationMatrixElementType
  //

  RotationMatrixElementType::
  RotationMatrixElementType (const ::xml_schema::double_& double_)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (double_)
  {
  }

  RotationMatrixElementType::
  RotationMatrixElementType (const RotationMatrixElementType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (x, f, c)
  {
  }

  RotationMatrixElementType::
  RotationMatrixElementType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (e, f, c)
  {
  }

  RotationMatrixElementType::
  RotationMatrixElementType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (a, f, c)
  {
  }

  RotationMatrixElementType::
  RotationMatrixElementType (const ::std::wstring& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  RotationMatrixElementType* RotationMatrixElementType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new RotationMatrixElementType (*this, f, c);
  }

  // FeatureType
  //

  FeatureType::
  FeatureType ()
  : ::xml_schema::token ()
  {
  }

  FeatureType::
  FeatureType (const ::xml_schema::token& token)
  : ::xml_schema::token (token)
  {
  }

  FeatureType::
  FeatureType (const FeatureType& x,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  FeatureType::
  FeatureType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  FeatureType::
  FeatureType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  FeatureType::
  FeatureType (const ::std::wstring& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  FeatureType* FeatureType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new FeatureType (*this, f, c);
  }

  // AxisType
  //

  AxisType::
  AxisType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_AxisType_convert ();
  }

  AxisType::
  AxisType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_AxisType_convert ();
  }

  AxisType::
  AxisType (const ::std::wstring& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_AxisType_convert ();
  }

  AxisType* AxisType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new AxisType (*this, f, c);
  }

  AxisType::value AxisType::
  _xsd_AxisType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AxisType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_AxisType_indexes_,
                      _xsd_AxisType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_AxisType_indexes_ + 2 || _xsd_AxisType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
    }

    return *i;
  }

  const wchar_t* const AxisType::
  _xsd_AxisType_literals_[2] =
  {
    L"A",
    L"I"
  };

  const AxisType::value AxisType::
  _xsd_AxisType_indexes_[2] =
  {
    ::xsd::AxisType::A,
    ::xsd::AxisType::I
  };

  // DataType
  //

  DataType::
  DataType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_DataType_convert ();
  }

  DataType::
  DataType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_DataType_convert ();
  }

  DataType::
  DataType (const ::std::wstring& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_DataType_convert ();
  }

  DataType* DataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new DataType (*this, f, c);
  }

  DataType::value DataType::
  _xsd_DataType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DataType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_DataType_indexes_,
                      _xsd_DataType_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_DataType_indexes_ + 4 || _xsd_DataType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
    }

    return *i;
  }

  const wchar_t* const DataType::
  _xsd_DataType_literals_[4] =
  {
    L"I",
    L"L",
    L"F",
    L"D"
  };

  const DataType::value DataType::
  _xsd_DataType_indexes_[4] =
  {
    ::xsd::DataType::D,
    ::xsd::DataType::F,
    ::xsd::DataType::I,
    ::xsd::DataType::L
  };

  // Type
  //

  Type::
  Type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_Type_convert ();
  }

  Type::
  Type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_Type_convert ();
  }

  Type::
  Type (const ::std::wstring& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_Type_convert ();
  }

  Type* Type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new Type (*this, f, c);
  }

  Type::value Type::
  _xsd_Type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_Type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_Type_indexes_,
                      _xsd_Type_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Type_indexes_ + 2 || _xsd_Type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
    }

    return *i;
  }

  const wchar_t* const Type::
  _xsd_Type_literals_[2] =
  {
    L"Contacting",
    L"NonContacting"
  };

  const Type::value Type::
  _xsd_Type_indexes_[2] =
  {
    ::xsd::Type::Contacting,
    ::xsd::Type::NonContacting
  };

  // Datum
  //

  Datum::
  Datum ()
  : ::xml_schema::token ()
  {
  }

  Datum::
  Datum (const ::xml_schema::token& token)
  : ::xml_schema::token (token)
  {
  }

  Datum::
  Datum (const Datum& x,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  Datum::
  Datum (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  Datum::
  Datum (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  Datum::
  Datum (const ::std::wstring& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  Datum* Datum::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new Datum (*this, f, c);
  }
}

#include <ostream>

namespace xsd
{
  ::std::wostream&
  operator<< (::std::wostream& o, const Record1Type& i)
  {
    o << ::std::endl << L"Revision: " << i.Revision ();
    o << ::std::endl << L"FeatureType: " << i.FeatureType ();
    o << ::std::endl << L"Axes: " << i.Axes ();
    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const ISO5436_2Type& i)
  {
    o << ::std::endl << L"Record1: " << i.Record1 ();
    if (i.Record2 ())
    {
      o << ::std::endl << L"Record2: " << *i.Record2 ();
    }

    o << ::std::endl << L"Record3: " << i.Record3 ();
    o << ::std::endl << L"Record4: " << i.Record4 ();
    for (ISO5436_2Type::VendorSpecific_const_iterator
         b (i.VendorSpecific ().begin ()), e (i.VendorSpecific ().end ());
         b != e; ++b)
    {
      o << ::std::endl << L"VendorSpecific: " << *b;
    }

    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const Record2Type& i)
  {
    o << ::std::endl << L"Date: " << i.Date ();
    if (i.Creator ())
    {
      o << ::std::endl << L"Creator: " << *i.Creator ();
    }

    o << ::std::endl << L"Instrument: " << i.Instrument ();
    o << ::std::endl << L"CalibrationDate: " << i.CalibrationDate ();
    o << ::std::endl << L"ProbingSystem: " << i.ProbingSystem ();
    if (i.Comment ())
    {
      o << ::std::endl << L"Comment: " << *i.Comment ();
    }

    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const Record3Type& i)
  {
    if (i.MatrixDimension ())
    {
      o << ::std::endl << L"MatrixDimension: " << *i.MatrixDimension ();
    }

    if (i.ListDimension ())
    {
      o << ::std::endl << L"ListDimension: " << *i.ListDimension ();
    }

    if (i.DataLink ())
    {
      o << ::std::endl << L"DataLink: " << *i.DataLink ();
    }

    if (i.DataList ())
    {
      o << ::std::endl << L"DataList: " << *i.DataList ();
    }

    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const Record4Type& i)
  {
    o << ::std::endl << L"ChecksumFile: " << i.ChecksumFile ();
    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const AxesType& i)
  {
    o << ::std::endl << L"CX: " << i.CX ();
    o << ::std::endl << L"CY: " << i.CY ();
    o << ::std::endl << L"CZ: " << i.CZ ();
    if (i.Rotation ())
    {
      o << ::std::endl << L"Rotation: " << *i.Rotation ();
    }

    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const AxisDescriptionType& i)
  {
    o << ::std::endl << L"AxisType: " << i.AxisType ();
    if (i.DataType ())
    {
      o << ::std::endl << L"DataType: " << *i.DataType ();
    }

    if (i.Increment ())
    {
      o << ::std::endl << L"Increment: " << *i.Increment ();
    }

    if (i.Offset ())
    {
      o << ::std::endl << L"Offset: " << *i.Offset ();
    }

    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const InstrumentType& i)
  {
    o << ::std::endl << L"Manufacturer: " << i.Manufacturer ();
    o << ::std::endl << L"Model: " << i.Model ();
    o << ::std::endl << L"Serial: " << i.Serial ();
    o << ::std::endl << L"Version: " << i.Version ();
    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const ProbingSystemType& i)
  {
    o << ::std::endl << L"Type: " << i.Type ();
    o << ::std::endl << L"Identification: " << i.Identification ();
    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const DataListType& i)
  {
    for (DataListType::Datum_const_iterator
         b (i.Datum ().begin ()), e (i.Datum ().end ());
         b != e; ++b)
    {
      o << ::std::endl << L"Datum: " << *b;
    }

    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const DataLinkType& i)
  {
    o << ::std::endl << L"PointDataLink: " << i.PointDataLink ();
    o << ::std::endl << L"MD5ChecksumPointData: " << i.MD5ChecksumPointData ();
    if (i.ValidPointsLink ())
    {
      o << ::std::endl << L"ValidPointsLink: " << *i.ValidPointsLink ();
    }

    if (i.MD5ChecksumValidPoints ())
    {
      o << ::std::endl << L"MD5ChecksumValidPoints: " << *i.MD5ChecksumValidPoints ();
    }

    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const MatrixDimensionType& i)
  {
    o << ::std::endl << L"SizeX: " << i.SizeX ();
    o << ::std::endl << L"SizeY: " << i.SizeY ();
    o << ::std::endl << L"SizeZ: " << i.SizeZ ();
    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const RotationType& i)
  {
    o << ::std::endl << L"r11: " << i.r11 ();
    o << ::std::endl << L"r12: " << i.r12 ();
    o << ::std::endl << L"r13: " << i.r13 ();
    o << ::std::endl << L"r21: " << i.r21 ();
    o << ::std::endl << L"r22: " << i.r22 ();
    o << ::std::endl << L"r23: " << i.r23 ();
    o << ::std::endl << L"r31: " << i.r31 ();
    o << ::std::endl << L"r32: " << i.r32 ();
    o << ::std::endl << L"r33: " << i.r33 ();
    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const RotationMatrixElementType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type >& > (i);
    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const FeatureType& i)
  {
    o << static_cast< const ::xml_schema::token& > (i);
    return o;
  }

  ::std::wostream&
  operator<< (::std::wostream& o, AxisType::value i)
  {
    return o << AxisType::_xsd_AxisType_literals_[i];
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const AxisType& i)
  {
    return o << static_cast< const ::xml_schema::token& > (i);
  }

  ::std::wostream&
  operator<< (::std::wostream& o, DataType::value i)
  {
    return o << DataType::_xsd_DataType_literals_[i];
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const DataType& i)
  {
    return o << static_cast< const ::xml_schema::token& > (i);
  }

  ::std::wostream&
  operator<< (::std::wostream& o, Type::value i)
  {
    return o << Type::_xsd_Type_literals_[i];
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const Type& i)
  {
    return o << static_cast< const ::xml_schema::token& > (i);
  }

  ::std::wostream&
  operator<< (::std::wostream& o, const Datum& i)
  {
    o << static_cast< const ::xml_schema::token& > (i);
    return o;
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< wchar_t > h;

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

    ::std::auto_ptr< ::xsd::ISO5436_2Type > r (
      ::xsd::ISO5436_2 (
        d.get (), f | ::xml_schema::flags::own_dom, p));

    if (f & ::xml_schema::flags::keep_dom)
      d.release ();

    return r;
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

    if (!d)
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    ::std::auto_ptr< ::xsd::ISO5436_2Type > r (
      ::xsd::ISO5436_2 (
        d.get (), f | ::xml_schema::flags::own_dom, p));

    if (f & ::xml_schema::flags::keep_dom)
      d.release ();

    return r;
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

    if (!d)
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    ::std::auto_ptr< ::xsd::ISO5436_2Type > r (
      ::xsd::ISO5436_2 (
        d.get (), f | ::xml_schema::flags::own_dom, p));

    if (f & ::xml_schema::flags::keep_dom)
      d.release ();

    return r;
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::xsd::ISO5436_2 (wrap, f, p);
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::xsd::ISO5436_2 (wrap, h, f, p);
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::xsd::ISO5436_2 (wrap, h, f, p);
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::xsd::ISO5436_2 (wrap, f, p);
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::xsd::ISO5436_2 (wrap, h, f, p);
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::xsd::ISO5436_2 (wrap, h, f, p);
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (const ::xercesc::DOMInputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< wchar_t > h;

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

    ::std::auto_ptr< ::xsd::ISO5436_2Type > r (
      ::xsd::ISO5436_2 (
        d.get (), f | ::xml_schema::flags::own_dom, p));

    if (f & ::xml_schema::flags::keep_dom)
      d.release ();

    return r;
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (const ::xercesc::DOMInputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

    if (!d)
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    ::std::auto_ptr< ::xsd::ISO5436_2Type > r (
      ::xsd::ISO5436_2 (
        d.get (), f | ::xml_schema::flags::own_dom, p));

    if (f & ::xml_schema::flags::keep_dom)
      d.release ();

    return r;
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (const ::xercesc::DOMInputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

    if (!d)
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    ::std::auto_ptr< ::xsd::ISO5436_2Type > r (
      ::xsd::ISO5436_2 (
        d.get (), f | ::xml_schema::flags::own_dom, p));

    if (f & ::xml_schema::flags::keep_dom)
      d.release ();

    return r;
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xsd::ISO5436_2Type > r (
        ::xsd::ISO5436_2 (
          c.get (), f | ::xml_schema::flags::own_dom, p));

      c.release ();
      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (e));

    if (n.name () == L"ISO5436_2" &&
        n.namespace_ () == L"http://www.opengps.eu/xsd/")
    {
      ::std::auto_ptr< ::xsd::ISO5436_2Type > r (
        ::xsd::cxx::tree::traits< ::xsd::ISO5436_2Type, wchar_t >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
      n.name (),
      n.namespace_ (),
      L"ISO5436_2",
      L"http://www.opengps.eu/xsd/");
  }

  ::std::auto_ptr< ::xsd::ISO5436_2Type >
  ISO5436_2 (::xercesc::DOMDocument* d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    const ::xercesc::DOMElement& e (
      c.get ()
      ? *c->getDocumentElement ()
      : *d->getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (e));

    if (n.name () == L"ISO5436_2" &&
        n.namespace_ () == L"http://www.opengps.eu/xsd/")
    {
      ::std::auto_ptr< ::xsd::ISO5436_2Type > r (
        ::xsd::cxx::tree::traits< ::xsd::ISO5436_2Type, wchar_t >::create (
          e, f, 0));
      c.release ();
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
      n.name (),
      n.namespace_ (),
      L"ISO5436_2",
      L"http://www.opengps.eu/xsd/");
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  void
  ISO5436_2 (::std::ostream& o,
             const ::xsd::ISO5436_2Type& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::ISO5436_2 (s, m, f));

    ::xsd::cxx::tree::error_handler< wchar_t > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
    }
  }

  void
  ISO5436_2 (::std::ostream& o,
             const ::xsd::ISO5436_2Type& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::ISO5436_2 (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  ISO5436_2 (::std::ostream& o,
             const ::xsd::ISO5436_2Type& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::ISO5436_2 (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  ISO5436_2 (::xercesc::XMLFormatTarget& t,
             const ::xsd::ISO5436_2Type& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::ISO5436_2 (s, m, f));

    ::xsd::cxx::tree::error_handler< wchar_t > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
    }
  }

  void
  ISO5436_2 (::xercesc::XMLFormatTarget& t,
             const ::xsd::ISO5436_2Type& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::ISO5436_2 (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  ISO5436_2 (::xercesc::XMLFormatTarget& t,
             const ::xsd::ISO5436_2Type& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::ISO5436_2 (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  ISO5436_2 (::xercesc::DOMDocument& d,
             const ::xsd::ISO5436_2Type& s,
             ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (e));

    if (n.name () == L"ISO5436_2" &&
        n.namespace_ () == L"http://www.opengps.eu/xsd/")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ISO5436_2",
        L"http://www.opengps.eu/xsd/");
    }
  }

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
  ISO5436_2 (const ::xsd::ISO5436_2Type& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
  {
    try
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< wchar_t > (
          L"ISO5436_2",
          L"http://www.opengps.eu/xsd/",
          m, f));

      ::xsd::ISO5436_2 (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Record1Type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Revision
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Revision",
          e));

      s << i.Revision ();
    }

    // FeatureType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"FeatureType",
          e));

      s << i.FeatureType ();
    }

    // Axes
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Axes",
          e));

      s << i.Axes ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ISO5436_2Type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Record1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Record1",
          e));

      s << i.Record1 ();
    }

    // Record2
    //
    if (i.Record2 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Record2",
          e));

      s << *i.Record2 ();
    }

    // Record3
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Record3",
          e));

      s << i.Record3 ();
    }

    // Record4
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Record4",
          e));

      s << i.Record4 ();
    }

    // VendorSpecific
    //
    for (ISO5436_2Type::VendorSpecific_const_iterator
         b (i.VendorSpecific ().begin ()), n (i.VendorSpecific ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"VendorSpecific",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Record2Type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Date
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Date",
          e));

      s << i.Date ();
    }

    // Creator
    //
    if (i.Creator ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Creator",
          e));

      s << *i.Creator ();
    }

    // Instrument
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Instrument",
          e));

      s << i.Instrument ();
    }

    // CalibrationDate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"CalibrationDate",
          e));

      s << i.CalibrationDate ();
    }

    // ProbingSystem
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"ProbingSystem",
          e));

      s << i.ProbingSystem ();
    }

    // Comment
    //
    if (i.Comment ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Comment",
          e));

      s << *i.Comment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Record3Type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // MatrixDimension
    //
    if (i.MatrixDimension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"MatrixDimension",
          e));

      s << *i.MatrixDimension ();
    }

    // ListDimension
    //
    if (i.ListDimension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"ListDimension",
          e));

      s << *i.ListDimension ();
    }

    // DataLink
    //
    if (i.DataLink ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"DataLink",
          e));

      s << *i.DataLink ();
    }

    // DataList
    //
    if (i.DataList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"DataList",
          e));

      s << *i.DataList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Record4Type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ChecksumFile
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"ChecksumFile",
          e));

      s << i.ChecksumFile ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AxesType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CX
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"CX",
          e));

      s << i.CX ();
    }

    // CY
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"CY",
          e));

      s << i.CY ();
    }

    // CZ
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"CZ",
          e));

      s << i.CZ ();
    }

    // Rotation
    //
    if (i.Rotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Rotation",
          e));

      s << *i.Rotation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AxisDescriptionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // AxisType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"AxisType",
          e));

      s << i.AxisType ();
    }

    // DataType
    //
    if (i.DataType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"DataType",
          e));

      s << *i.DataType ();
    }

    // Increment
    //
    if (i.Increment ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Increment",
          e));

      s << *i.Increment ();
    }

    // Offset
    //
    if (i.Offset ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Offset",
          e));

      s << *i.Offset ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InstrumentType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Manufacturer
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Manufacturer",
          e));

      s << i.Manufacturer ();
    }

    // Model
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Model",
          e));

      s << i.Model ();
    }

    // Serial
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Serial",
          e));

      s << i.Serial ();
    }

    // Version
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Version",
          e));

      s << i.Version ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProbingSystemType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Type",
          e));

      s << i.Type ();
    }

    // Identification
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Identification",
          e));

      s << i.Identification ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DataListType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Datum
    //
    for (DataListType::Datum_const_iterator
         b (i.Datum ().begin ()), n (i.Datum ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Datum",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DataLinkType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // PointDataLink
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"PointDataLink",
          e));

      s << i.PointDataLink ();
    }

    // MD5ChecksumPointData
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"MD5ChecksumPointData",
          e));

      s << i.MD5ChecksumPointData ();
    }

    // ValidPointsLink
    //
    if (i.ValidPointsLink ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"ValidPointsLink",
          e));

      s << *i.ValidPointsLink ();
    }

    // MD5ChecksumValidPoints
    //
    if (i.MD5ChecksumValidPoints ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"MD5ChecksumValidPoints",
          e));

      s << *i.MD5ChecksumValidPoints ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MatrixDimensionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SizeX
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SizeX",
          e));

      s << i.SizeX ();
    }

    // SizeY
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SizeY",
          e));

      s << i.SizeY ();
    }

    // SizeZ
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SizeZ",
          e));

      s << i.SizeZ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RotationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // r11
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"r11",
          e));

      s << i.r11 ();
    }

    // r12
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"r12",
          e));

      s << i.r12 ();
    }

    // r13
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"r13",
          e));

      s << i.r13 ();
    }

    // r21
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"r21",
          e));

      s << i.r21 ();
    }

    // r22
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"r22",
          e));

      s << i.r22 ();
    }

    // r23
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"r23",
          e));

      s << i.r23 ();
    }

    // r31
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"r31",
          e));

      s << i.r31 ();
    }

    // r32
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"r32",
          e));

      s << i.r32 ();
    }

    // r33
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"r33",
          e));

      s << i.r33 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RotationMatrixElementType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,const RotationMatrixElementType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
              const RotationMatrixElementType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const FeatureType& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,const FeatureType& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
              const FeatureType& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const AxisType& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AxisType& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
              const AxisType& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DataType& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DataType& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
              const DataType& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Type& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Type& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
              const Type& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Datum& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,const Datum& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
              const Datum& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

