// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
/***************************************************************************
 *   Copyright by                                                          *
 *   Georg Wiora (NanoFocus AG) 2007                                       *
 *   Jörg Seewig (Uni Hannover),                                           *
 *   Andreas Walther (NanoFocus AG),                                       *
 *   Mark A. Weber (NanoFocus AG) 2007                                     *
 *   Johannes Herwig (Uni Duisburg-Essen) 2007                             *
 *                                                                         *
 *   This file is part of the openGPS (R)[TM] software library.            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License (LGPL)    *
 *   as published by the Free Software Foundation; either version 3 of     *
 *   the License, or (at your option) any later version.                   *
 *   for detail see the files "licence_LGPL-3.0.txt" and                   *
 *   "licence_GPL-3.0.txt".                                                *
 *                                                                         *
 *   openGPS is distributed in the hope that it will be useful,            *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU Lesser General Public License for more details.                   *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 *                                                                         *
 *   The name "openGPS" and the logo are registered as                     *
 *   European trade mark No. 006178354 for                                 *
 *   Physikalisch Technische Bundesanstalt (PTB)                           *
 *   http://www.ptb.de/                                                    *
 *                                                                         *
 *   More information about openGPS can be found at                        *
 *   http://www.opengps.eu/                                                *
 ***************************************************************************/

#include <opengps/opengps.h>
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "iso5436_2_xsd.hxx"

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      // Record1Type
      // 

      const Record1Type::Revision_type& Record1Type::
      Revision () const
      {
        return this->Revision_.get ();
      }

      Record1Type::Revision_type& Record1Type::
      Revision ()
      {
        return this->Revision_.get ();
      }

      void Record1Type::
      Revision (const Revision_type& Revision)
      {
        this->Revision_.set (Revision);
      }

      void Record1Type::
      Revision (::std::auto_ptr< Revision_type > Revision)
      {
        this->Revision_.set (Revision);
      }

      const Record1Type::FeatureType_type& Record1Type::
      FeatureType () const
      {
        return this->FeatureType_.get ();
      }

      Record1Type::FeatureType_type& Record1Type::
      FeatureType ()
      {
        return this->FeatureType_.get ();
      }

      void Record1Type::
      FeatureType (const FeatureType_type& FeatureType)
      {
        this->FeatureType_.set (FeatureType);
      }

      void Record1Type::
      FeatureType (::std::auto_ptr< FeatureType_type > FeatureType)
      {
        this->FeatureType_.set (FeatureType);
      }

      const Record1Type::Axes_type& Record1Type::
      Axes () const
      {
        return this->Axes_.get ();
      }

      Record1Type::Axes_type& Record1Type::
      Axes ()
      {
        return this->Axes_.get ();
      }

      void Record1Type::
      Axes (const Axes_type& Axes)
      {
        this->Axes_.set (Axes);
      }

      void Record1Type::
      Axes (::std::auto_ptr< Axes_type > Axes)
      {
        this->Axes_.set (Axes);
      }


      // ISO5436_2Type
      // 

      const ISO5436_2Type::Record1_type& ISO5436_2Type::
      Record1 () const
      {
        return this->Record1_.get ();
      }

      ISO5436_2Type::Record1_type& ISO5436_2Type::
      Record1 ()
      {
        return this->Record1_.get ();
      }

      void ISO5436_2Type::
      Record1 (const Record1_type& Record1)
      {
        this->Record1_.set (Record1);
      }

      void ISO5436_2Type::
      Record1 (::std::auto_ptr< Record1_type > Record1)
      {
        this->Record1_.set (Record1);
      }

      const ISO5436_2Type::Record2_optional& ISO5436_2Type::
      Record2 () const
      {
        return this->Record2_;
      }

      ISO5436_2Type::Record2_optional& ISO5436_2Type::
      Record2 ()
      {
        return this->Record2_;
      }

      void ISO5436_2Type::
      Record2 (const Record2_type& Record2)
      {
        this->Record2_.set (Record2);
      }

      void ISO5436_2Type::
      Record2 (const Record2_optional& Record2)
      {
        this->Record2_ = Record2;
      }

      void ISO5436_2Type::
      Record2 (::std::auto_ptr< Record2_type > Record2)
      {
        this->Record2_.set (Record2);
      }

      const ISO5436_2Type::Record3_type& ISO5436_2Type::
      Record3 () const
      {
        return this->Record3_.get ();
      }

      ISO5436_2Type::Record3_type& ISO5436_2Type::
      Record3 ()
      {
        return this->Record3_.get ();
      }

      void ISO5436_2Type::
      Record3 (const Record3_type& Record3)
      {
        this->Record3_.set (Record3);
      }

      void ISO5436_2Type::
      Record3 (::std::auto_ptr< Record3_type > Record3)
      {
        this->Record3_.set (Record3);
      }

      const ISO5436_2Type::Record4_type& ISO5436_2Type::
      Record4 () const
      {
        return this->Record4_.get ();
      }

      ISO5436_2Type::Record4_type& ISO5436_2Type::
      Record4 ()
      {
        return this->Record4_.get ();
      }

      void ISO5436_2Type::
      Record4 (const Record4_type& Record4)
      {
        this->Record4_.set (Record4);
      }

      void ISO5436_2Type::
      Record4 (::std::auto_ptr< Record4_type > Record4)
      {
        this->Record4_.set (Record4);
      }

      const ISO5436_2Type::VendorSpecificID_optional& ISO5436_2Type::
      VendorSpecificID () const
      {
        return this->VendorSpecificID_;
      }

      ISO5436_2Type::VendorSpecificID_optional& ISO5436_2Type::
      VendorSpecificID ()
      {
        return this->VendorSpecificID_;
      }

      void ISO5436_2Type::
      VendorSpecificID (const VendorSpecificID_type& VendorSpecificID)
      {
        this->VendorSpecificID_.set (VendorSpecificID);
      }

      void ISO5436_2Type::
      VendorSpecificID (const VendorSpecificID_optional& VendorSpecificID)
      {
        this->VendorSpecificID_ = VendorSpecificID;
      }

      void ISO5436_2Type::
      VendorSpecificID (::std::auto_ptr< VendorSpecificID_type > VendorSpecificID)
      {
        this->VendorSpecificID_.set (VendorSpecificID);
      }


      // Record2Type
      // 

      const Record2Type::Date_type& Record2Type::
      Date () const
      {
        return this->Date_.get ();
      }

      Record2Type::Date_type& Record2Type::
      Date ()
      {
        return this->Date_.get ();
      }

      void Record2Type::
      Date (const Date_type& Date)
      {
        this->Date_.set (Date);
      }

      void Record2Type::
      Date (::std::auto_ptr< Date_type > Date)
      {
        this->Date_.set (Date);
      }

      const Record2Type::Creator_optional& Record2Type::
      Creator () const
      {
        return this->Creator_;
      }

      Record2Type::Creator_optional& Record2Type::
      Creator ()
      {
        return this->Creator_;
      }

      void Record2Type::
      Creator (const Creator_type& Creator)
      {
        this->Creator_.set (Creator);
      }

      void Record2Type::
      Creator (const Creator_optional& Creator)
      {
        this->Creator_ = Creator;
      }

      void Record2Type::
      Creator (::std::auto_ptr< Creator_type > Creator)
      {
        this->Creator_.set (Creator);
      }

      const Record2Type::Instrument_type& Record2Type::
      Instrument () const
      {
        return this->Instrument_.get ();
      }

      Record2Type::Instrument_type& Record2Type::
      Instrument ()
      {
        return this->Instrument_.get ();
      }

      void Record2Type::
      Instrument (const Instrument_type& Instrument)
      {
        this->Instrument_.set (Instrument);
      }

      void Record2Type::
      Instrument (::std::auto_ptr< Instrument_type > Instrument)
      {
        this->Instrument_.set (Instrument);
      }

      const Record2Type::CalibrationDate_type& Record2Type::
      CalibrationDate () const
      {
        return this->CalibrationDate_.get ();
      }

      Record2Type::CalibrationDate_type& Record2Type::
      CalibrationDate ()
      {
        return this->CalibrationDate_.get ();
      }

      void Record2Type::
      CalibrationDate (const CalibrationDate_type& CalibrationDate)
      {
        this->CalibrationDate_.set (CalibrationDate);
      }

      void Record2Type::
      CalibrationDate (::std::auto_ptr< CalibrationDate_type > CalibrationDate)
      {
        this->CalibrationDate_.set (CalibrationDate);
      }

      const Record2Type::ProbingSystem_type& Record2Type::
      ProbingSystem () const
      {
        return this->ProbingSystem_.get ();
      }

      Record2Type::ProbingSystem_type& Record2Type::
      ProbingSystem ()
      {
        return this->ProbingSystem_.get ();
      }

      void Record2Type::
      ProbingSystem (const ProbingSystem_type& ProbingSystem)
      {
        this->ProbingSystem_.set (ProbingSystem);
      }

      void Record2Type::
      ProbingSystem (::std::auto_ptr< ProbingSystem_type > ProbingSystem)
      {
        this->ProbingSystem_.set (ProbingSystem);
      }

      const Record2Type::Comment_optional& Record2Type::
      Comment () const
      {
        return this->Comment_;
      }

      Record2Type::Comment_optional& Record2Type::
      Comment ()
      {
        return this->Comment_;
      }

      void Record2Type::
      Comment (const Comment_type& Comment)
      {
        this->Comment_.set (Comment);
      }

      void Record2Type::
      Comment (const Comment_optional& Comment)
      {
        this->Comment_ = Comment;
      }

      void Record2Type::
      Comment (::std::auto_ptr< Comment_type > Comment)
      {
        this->Comment_.set (Comment);
      }


      // Record3Type
      // 

      const Record3Type::MatrixDimension_optional& Record3Type::
      MatrixDimension () const
      {
        return this->MatrixDimension_;
      }

      Record3Type::MatrixDimension_optional& Record3Type::
      MatrixDimension ()
      {
        return this->MatrixDimension_;
      }

      void Record3Type::
      MatrixDimension (const MatrixDimension_type& MatrixDimension)
      {
        this->MatrixDimension_.set (MatrixDimension);
      }

      void Record3Type::
      MatrixDimension (const MatrixDimension_optional& MatrixDimension)
      {
        this->MatrixDimension_ = MatrixDimension;
      }

      void Record3Type::
      MatrixDimension (::std::auto_ptr< MatrixDimension_type > MatrixDimension)
      {
        this->MatrixDimension_.set (MatrixDimension);
      }

      const Record3Type::ListDimension_optional& Record3Type::
      ListDimension () const
      {
        return this->ListDimension_;
      }

      Record3Type::ListDimension_optional& Record3Type::
      ListDimension ()
      {
        return this->ListDimension_;
      }

      void Record3Type::
      ListDimension (const ListDimension_type& ListDimension)
      {
        this->ListDimension_.set (ListDimension);
      }

      void Record3Type::
      ListDimension (const ListDimension_optional& ListDimension)
      {
        this->ListDimension_ = ListDimension;
      }

      const Record3Type::DataLink_optional& Record3Type::
      DataLink () const
      {
        return this->DataLink_;
      }

      Record3Type::DataLink_optional& Record3Type::
      DataLink ()
      {
        return this->DataLink_;
      }

      void Record3Type::
      DataLink (const DataLink_type& DataLink)
      {
        this->DataLink_.set (DataLink);
      }

      void Record3Type::
      DataLink (const DataLink_optional& DataLink)
      {
        this->DataLink_ = DataLink;
      }

      void Record3Type::
      DataLink (::std::auto_ptr< DataLink_type > DataLink)
      {
        this->DataLink_.set (DataLink);
      }

      const Record3Type::DataList_optional& Record3Type::
      DataList () const
      {
        return this->DataList_;
      }

      Record3Type::DataList_optional& Record3Type::
      DataList ()
      {
        return this->DataList_;
      }

      void Record3Type::
      DataList (const DataList_type& DataList)
      {
        this->DataList_.set (DataList);
      }

      void Record3Type::
      DataList (const DataList_optional& DataList)
      {
        this->DataList_ = DataList;
      }

      void Record3Type::
      DataList (::std::auto_ptr< DataList_type > DataList)
      {
        this->DataList_.set (DataList);
      }


      // Record4Type
      // 

      const Record4Type::ChecksumFile_type& Record4Type::
      ChecksumFile () const
      {
        return this->ChecksumFile_.get ();
      }

      Record4Type::ChecksumFile_type& Record4Type::
      ChecksumFile ()
      {
        return this->ChecksumFile_.get ();
      }

      void Record4Type::
      ChecksumFile (const ChecksumFile_type& ChecksumFile)
      {
        this->ChecksumFile_.set (ChecksumFile);
      }

      void Record4Type::
      ChecksumFile (::std::auto_ptr< ChecksumFile_type > ChecksumFile)
      {
        this->ChecksumFile_.set (ChecksumFile);
      }


      // AxesType
      // 

      const AxesType::CX_type& AxesType::
      CX () const
      {
        return this->CX_.get ();
      }

      AxesType::CX_type& AxesType::
      CX ()
      {
        return this->CX_.get ();
      }

      void AxesType::
      CX (const CX_type& CX)
      {
        this->CX_.set (CX);
      }

      void AxesType::
      CX (::std::auto_ptr< CX_type > CX)
      {
        this->CX_.set (CX);
      }

      const AxesType::CY_type& AxesType::
      CY () const
      {
        return this->CY_.get ();
      }

      AxesType::CY_type& AxesType::
      CY ()
      {
        return this->CY_.get ();
      }

      void AxesType::
      CY (const CY_type& CY)
      {
        this->CY_.set (CY);
      }

      void AxesType::
      CY (::std::auto_ptr< CY_type > CY)
      {
        this->CY_.set (CY);
      }

      const AxesType::CZ_type& AxesType::
      CZ () const
      {
        return this->CZ_.get ();
      }

      AxesType::CZ_type& AxesType::
      CZ ()
      {
        return this->CZ_.get ();
      }

      void AxesType::
      CZ (const CZ_type& CZ)
      {
        this->CZ_.set (CZ);
      }

      void AxesType::
      CZ (::std::auto_ptr< CZ_type > CZ)
      {
        this->CZ_.set (CZ);
      }

      const AxesType::Rotation_optional& AxesType::
      Rotation () const
      {
        return this->Rotation_;
      }

      AxesType::Rotation_optional& AxesType::
      Rotation ()
      {
        return this->Rotation_;
      }

      void AxesType::
      Rotation (const Rotation_type& Rotation)
      {
        this->Rotation_.set (Rotation);
      }

      void AxesType::
      Rotation (const Rotation_optional& Rotation)
      {
        this->Rotation_ = Rotation;
      }

      void AxesType::
      Rotation (::std::auto_ptr< Rotation_type > Rotation)
      {
        this->Rotation_.set (Rotation);
      }


      // AxisDescriptionType
      // 

      const AxisDescriptionType::AxisType_type& AxisDescriptionType::
      AxisType () const
      {
        return this->AxisType_.get ();
      }

      AxisDescriptionType::AxisType_type& AxisDescriptionType::
      AxisType ()
      {
        return this->AxisType_.get ();
      }

      void AxisDescriptionType::
      AxisType (const AxisType_type& AxisType)
      {
        this->AxisType_.set (AxisType);
      }

      void AxisDescriptionType::
      AxisType (::std::auto_ptr< AxisType_type > AxisType)
      {
        this->AxisType_.set (AxisType);
      }

      const AxisDescriptionType::DataType_optional& AxisDescriptionType::
      DataType () const
      {
        return this->DataType_;
      }

      AxisDescriptionType::DataType_optional& AxisDescriptionType::
      DataType ()
      {
        return this->DataType_;
      }

      void AxisDescriptionType::
      DataType (const DataType_type& DataType)
      {
        this->DataType_.set (DataType);
      }

      void AxisDescriptionType::
      DataType (const DataType_optional& DataType)
      {
        this->DataType_ = DataType;
      }

      void AxisDescriptionType::
      DataType (::std::auto_ptr< DataType_type > DataType)
      {
        this->DataType_.set (DataType);
      }

      const AxisDescriptionType::Increment_optional& AxisDescriptionType::
      Increment () const
      {
        return this->Increment_;
      }

      AxisDescriptionType::Increment_optional& AxisDescriptionType::
      Increment ()
      {
        return this->Increment_;
      }

      void AxisDescriptionType::
      Increment (const Increment_type& Increment)
      {
        this->Increment_.set (Increment);
      }

      void AxisDescriptionType::
      Increment (const Increment_optional& Increment)
      {
        this->Increment_ = Increment;
      }

      const AxisDescriptionType::Offset_optional& AxisDescriptionType::
      Offset () const
      {
        return this->Offset_;
      }

      AxisDescriptionType::Offset_optional& AxisDescriptionType::
      Offset ()
      {
        return this->Offset_;
      }

      void AxisDescriptionType::
      Offset (const Offset_type& Offset)
      {
        this->Offset_.set (Offset);
      }

      void AxisDescriptionType::
      Offset (const Offset_optional& Offset)
      {
        this->Offset_ = Offset;
      }


      // InstrumentType
      // 

      const InstrumentType::Manufacturer_type& InstrumentType::
      Manufacturer () const
      {
        return this->Manufacturer_.get ();
      }

      InstrumentType::Manufacturer_type& InstrumentType::
      Manufacturer ()
      {
        return this->Manufacturer_.get ();
      }

      void InstrumentType::
      Manufacturer (const Manufacturer_type& Manufacturer)
      {
        this->Manufacturer_.set (Manufacturer);
      }

      void InstrumentType::
      Manufacturer (::std::auto_ptr< Manufacturer_type > Manufacturer)
      {
        this->Manufacturer_.set (Manufacturer);
      }

      const InstrumentType::Model_type& InstrumentType::
      Model () const
      {
        return this->Model_.get ();
      }

      InstrumentType::Model_type& InstrumentType::
      Model ()
      {
        return this->Model_.get ();
      }

      void InstrumentType::
      Model (const Model_type& Model)
      {
        this->Model_.set (Model);
      }

      void InstrumentType::
      Model (::std::auto_ptr< Model_type > Model)
      {
        this->Model_.set (Model);
      }

      const InstrumentType::Serial_type& InstrumentType::
      Serial () const
      {
        return this->Serial_.get ();
      }

      InstrumentType::Serial_type& InstrumentType::
      Serial ()
      {
        return this->Serial_.get ();
      }

      void InstrumentType::
      Serial (const Serial_type& Serial)
      {
        this->Serial_.set (Serial);
      }

      void InstrumentType::
      Serial (::std::auto_ptr< Serial_type > Serial)
      {
        this->Serial_.set (Serial);
      }

      const InstrumentType::Version_type& InstrumentType::
      Version () const
      {
        return this->Version_.get ();
      }

      InstrumentType::Version_type& InstrumentType::
      Version ()
      {
        return this->Version_.get ();
      }

      void InstrumentType::
      Version (const Version_type& Version)
      {
        this->Version_.set (Version);
      }

      void InstrumentType::
      Version (::std::auto_ptr< Version_type > Version)
      {
        this->Version_.set (Version);
      }


      // ProbingSystemType
      // 

      const ProbingSystemType::Type_type& ProbingSystemType::
      Type () const
      {
        return this->Type_.get ();
      }

      ProbingSystemType::Type_type& ProbingSystemType::
      Type ()
      {
        return this->Type_.get ();
      }

      void ProbingSystemType::
      Type (const Type_type& Type)
      {
        this->Type_.set (Type);
      }

      void ProbingSystemType::
      Type (::std::auto_ptr< Type_type > Type)
      {
        this->Type_.set (Type);
      }

      const ProbingSystemType::Identification_type& ProbingSystemType::
      Identification () const
      {
        return this->Identification_.get ();
      }

      ProbingSystemType::Identification_type& ProbingSystemType::
      Identification ()
      {
        return this->Identification_.get ();
      }

      void ProbingSystemType::
      Identification (const Identification_type& Identification)
      {
        this->Identification_.set (Identification);
      }

      void ProbingSystemType::
      Identification (::std::auto_ptr< Identification_type > Identification)
      {
        this->Identification_.set (Identification);
      }


      // DataListType
      // 

      const DataListType::Datum_sequence& DataListType::
      Datum () const
      {
        return this->Datum_;
      }

      DataListType::Datum_sequence& DataListType::
      Datum ()
      {
        return this->Datum_;
      }

      void DataListType::
      Datum (const Datum_sequence& Datum)
      {
        this->Datum_ = Datum;
      }


      // DataLinkType
      // 

      const DataLinkType::PointDataLink_type& DataLinkType::
      PointDataLink () const
      {
        return this->PointDataLink_.get ();
      }

      DataLinkType::PointDataLink_type& DataLinkType::
      PointDataLink ()
      {
        return this->PointDataLink_.get ();
      }

      void DataLinkType::
      PointDataLink (const PointDataLink_type& PointDataLink)
      {
        this->PointDataLink_.set (PointDataLink);
      }

      void DataLinkType::
      PointDataLink (::std::auto_ptr< PointDataLink_type > PointDataLink)
      {
        this->PointDataLink_.set (PointDataLink);
      }

      const DataLinkType::MD5ChecksumPointData_type& DataLinkType::
      MD5ChecksumPointData () const
      {
        return this->MD5ChecksumPointData_.get ();
      }

      DataLinkType::MD5ChecksumPointData_type& DataLinkType::
      MD5ChecksumPointData ()
      {
        return this->MD5ChecksumPointData_.get ();
      }

      void DataLinkType::
      MD5ChecksumPointData (const MD5ChecksumPointData_type& MD5ChecksumPointData)
      {
        this->MD5ChecksumPointData_.set (MD5ChecksumPointData);
      }

      void DataLinkType::
      MD5ChecksumPointData (::std::auto_ptr< MD5ChecksumPointData_type > MD5ChecksumPointData)
      {
        this->MD5ChecksumPointData_.set (MD5ChecksumPointData);
      }

      const DataLinkType::ValidPointsLink_optional& DataLinkType::
      ValidPointsLink () const
      {
        return this->ValidPointsLink_;
      }

      DataLinkType::ValidPointsLink_optional& DataLinkType::
      ValidPointsLink ()
      {
        return this->ValidPointsLink_;
      }

      void DataLinkType::
      ValidPointsLink (const ValidPointsLink_type& ValidPointsLink)
      {
        this->ValidPointsLink_.set (ValidPointsLink);
      }

      void DataLinkType::
      ValidPointsLink (const ValidPointsLink_optional& ValidPointsLink)
      {
        this->ValidPointsLink_ = ValidPointsLink;
      }

      void DataLinkType::
      ValidPointsLink (::std::auto_ptr< ValidPointsLink_type > ValidPointsLink)
      {
        this->ValidPointsLink_.set (ValidPointsLink);
      }

      const DataLinkType::MD5ChecksumValidPoints_optional& DataLinkType::
      MD5ChecksumValidPoints () const
      {
        return this->MD5ChecksumValidPoints_;
      }

      DataLinkType::MD5ChecksumValidPoints_optional& DataLinkType::
      MD5ChecksumValidPoints ()
      {
        return this->MD5ChecksumValidPoints_;
      }

      void DataLinkType::
      MD5ChecksumValidPoints (const MD5ChecksumValidPoints_type& MD5ChecksumValidPoints)
      {
        this->MD5ChecksumValidPoints_.set (MD5ChecksumValidPoints);
      }

      void DataLinkType::
      MD5ChecksumValidPoints (const MD5ChecksumValidPoints_optional& MD5ChecksumValidPoints)
      {
        this->MD5ChecksumValidPoints_ = MD5ChecksumValidPoints;
      }

      void DataLinkType::
      MD5ChecksumValidPoints (::std::auto_ptr< MD5ChecksumValidPoints_type > MD5ChecksumValidPoints)
      {
        this->MD5ChecksumValidPoints_.set (MD5ChecksumValidPoints);
      }


      // MatrixDimensionType
      // 

      const MatrixDimensionType::SizeX_type& MatrixDimensionType::
      SizeX () const
      {
        return this->SizeX_.get ();
      }

      MatrixDimensionType::SizeX_type& MatrixDimensionType::
      SizeX ()
      {
        return this->SizeX_.get ();
      }

      void MatrixDimensionType::
      SizeX (const SizeX_type& SizeX)
      {
        this->SizeX_.set (SizeX);
      }

      const MatrixDimensionType::SizeY_type& MatrixDimensionType::
      SizeY () const
      {
        return this->SizeY_.get ();
      }

      MatrixDimensionType::SizeY_type& MatrixDimensionType::
      SizeY ()
      {
        return this->SizeY_.get ();
      }

      void MatrixDimensionType::
      SizeY (const SizeY_type& SizeY)
      {
        this->SizeY_.set (SizeY);
      }

      const MatrixDimensionType::SizeZ_type& MatrixDimensionType::
      SizeZ () const
      {
        return this->SizeZ_.get ();
      }

      MatrixDimensionType::SizeZ_type& MatrixDimensionType::
      SizeZ ()
      {
        return this->SizeZ_.get ();
      }

      void MatrixDimensionType::
      SizeZ (const SizeZ_type& SizeZ)
      {
        this->SizeZ_.set (SizeZ);
      }


      // RotationType
      // 

      const RotationType::r11_type& RotationType::
      r11 () const
      {
        return this->r11_.get ();
      }

      RotationType::r11_type& RotationType::
      r11 ()
      {
        return this->r11_.get ();
      }

      void RotationType::
      r11 (const r11_type& r11)
      {
        this->r11_.set (r11);
      }

      void RotationType::
      r11 (::std::auto_ptr< r11_type > r11)
      {
        this->r11_.set (r11);
      }

      const RotationType::r12_type& RotationType::
      r12 () const
      {
        return this->r12_.get ();
      }

      RotationType::r12_type& RotationType::
      r12 ()
      {
        return this->r12_.get ();
      }

      void RotationType::
      r12 (const r12_type& r12)
      {
        this->r12_.set (r12);
      }

      void RotationType::
      r12 (::std::auto_ptr< r12_type > r12)
      {
        this->r12_.set (r12);
      }

      const RotationType::r13_type& RotationType::
      r13 () const
      {
        return this->r13_.get ();
      }

      RotationType::r13_type& RotationType::
      r13 ()
      {
        return this->r13_.get ();
      }

      void RotationType::
      r13 (const r13_type& r13)
      {
        this->r13_.set (r13);
      }

      void RotationType::
      r13 (::std::auto_ptr< r13_type > r13)
      {
        this->r13_.set (r13);
      }

      const RotationType::r21_type& RotationType::
      r21 () const
      {
        return this->r21_.get ();
      }

      RotationType::r21_type& RotationType::
      r21 ()
      {
        return this->r21_.get ();
      }

      void RotationType::
      r21 (const r21_type& r21)
      {
        this->r21_.set (r21);
      }

      void RotationType::
      r21 (::std::auto_ptr< r21_type > r21)
      {
        this->r21_.set (r21);
      }

      const RotationType::r22_type& RotationType::
      r22 () const
      {
        return this->r22_.get ();
      }

      RotationType::r22_type& RotationType::
      r22 ()
      {
        return this->r22_.get ();
      }

      void RotationType::
      r22 (const r22_type& r22)
      {
        this->r22_.set (r22);
      }

      void RotationType::
      r22 (::std::auto_ptr< r22_type > r22)
      {
        this->r22_.set (r22);
      }

      const RotationType::r23_type& RotationType::
      r23 () const
      {
        return this->r23_.get ();
      }

      RotationType::r23_type& RotationType::
      r23 ()
      {
        return this->r23_.get ();
      }

      void RotationType::
      r23 (const r23_type& r23)
      {
        this->r23_.set (r23);
      }

      void RotationType::
      r23 (::std::auto_ptr< r23_type > r23)
      {
        this->r23_.set (r23);
      }

      const RotationType::r31_type& RotationType::
      r31 () const
      {
        return this->r31_.get ();
      }

      RotationType::r31_type& RotationType::
      r31 ()
      {
        return this->r31_.get ();
      }

      void RotationType::
      r31 (const r31_type& r31)
      {
        this->r31_.set (r31);
      }

      void RotationType::
      r31 (::std::auto_ptr< r31_type > r31)
      {
        this->r31_.set (r31);
      }

      const RotationType::r32_type& RotationType::
      r32 () const
      {
        return this->r32_.get ();
      }

      RotationType::r32_type& RotationType::
      r32 ()
      {
        return this->r32_.get ();
      }

      void RotationType::
      r32 (const r32_type& r32)
      {
        this->r32_.set (r32);
      }

      void RotationType::
      r32 (::std::auto_ptr< r32_type > r32)
      {
        this->r32_.set (r32);
      }

      const RotationType::r33_type& RotationType::
      r33 () const
      {
        return this->r33_.get ();
      }

      RotationType::r33_type& RotationType::
      r33 ()
      {
        return this->r33_.get ();
      }

      void RotationType::
      r33 (const r33_type& r33)
      {
        this->r33_.set (r33);
      }

      void RotationType::
      r33 (::std::auto_ptr< r33_type > r33)
      {
        this->r33_.set (r33);
      }


      // RotationMatrixElementType
      // 


      // FeatureType
      // 


      // AxisType
      // 

      AxisType::
      AxisType (value v)
      : ::xml_schema::token (_xsd_AxisType_literals_[v])
      {
      }

      AxisType::
      AxisType (const ::xml_schema::token& v)
      : ::xml_schema::token (v)
      {
      }

      AxisType::
      AxisType (const AxisType& v,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::token (v, f, c)
      {
      }

      AxisType& AxisType::
      operator= (value v)
      {
        static_cast< ::xml_schema::token& > (*this) = 
        ::xml_schema::token (_xsd_AxisType_literals_[v]);

        return *this;
      }


      // DataType
      // 

      DataType::
      DataType (value v)
      : ::xml_schema::token (_xsd_DataType_literals_[v])
      {
      }

      DataType::
      DataType (const ::xml_schema::token& v)
      : ::xml_schema::token (v)
      {
      }

      DataType::
      DataType (const DataType& v,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::token (v, f, c)
      {
      }

      DataType& DataType::
      operator= (value v)
      {
        static_cast< ::xml_schema::token& > (*this) = 
        ::xml_schema::token (_xsd_DataType_literals_[v]);

        return *this;
      }


      // Type
      // 

      Type::
      Type (value v)
      : ::xml_schema::token (_xsd_Type_literals_[v])
      {
      }

      Type::
      Type (const ::xml_schema::token& v)
      : ::xml_schema::token (v)
      {
      }

      Type::
      Type (const Type& v,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::token (v, f, c)
      {
      }

      Type& Type::
      operator= (value v)
      {
        static_cast< ::xml_schema::token& > (*this) = 
        ::xml_schema::token (_xsd_Type_literals_[v]);

        return *this;
      }


      // Datum
      // 
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      // Record1Type
      //

      Record1Type::
      Record1Type (const Revision_type& Revision,
                   const FeatureType_type& FeatureType,
                   const Axes_type& Axes)
      : ::xml_schema::type (),
        Revision_ (Revision, ::xml_schema::flags (), this),
        FeatureType_ (FeatureType, ::xml_schema::flags (), this),
        Axes_ (Axes, ::xml_schema::flags (), this)
      {
      }

      Record1Type::
      Record1Type (const Record1Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        Revision_ (x.Revision_, f, this),
        FeatureType_ (x.FeatureType_, f, this),
        Axes_ (x.Axes_, f, this)
      {
      }

      Record1Type::
      Record1Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Revision_ (f, this),
        FeatureType_ (f, this),
        Axes_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void Record1Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Revision
          //
          if (n.name () == L"Revision" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Revision_type > r (
              Revision_traits::create (i, f, this));

            if (!Revision_.present ())
            {
              this->Revision (r);
              continue;
            }
          }

          // FeatureType
          //
          if (n.name () == L"FeatureType" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< FeatureType_type > r (
              FeatureType_traits::create (i, f, this));

            if (!FeatureType_.present ())
            {
              this->FeatureType (r);
              continue;
            }
          }

          // Axes
          //
          if (n.name () == L"Axes" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Axes_type > r (
              Axes_traits::create (i, f, this));

            if (!Axes_.present ())
            {
              this->Axes (r);
              continue;
            }
          }

          break;
        }

        if (!Revision_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Revision",
            L"");
        }

        if (!FeatureType_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"FeatureType",
            L"");
        }

        if (!Axes_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Axes",
            L"");
        }
      }

      Record1Type* Record1Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Record1Type (*this, f, c);
      }

      bool
      operator== (const Record1Type& x, const Record1Type& y)
      {
        return x.Revision () == y.Revision () &&
        x.FeatureType () == y.FeatureType () &&
        x.Axes () == y.Axes ();
      }

      bool
      operator!= (const Record1Type& x, const Record1Type& y)
      {
        return !(x == y);
      }

      // ISO5436_2Type
      //

      ISO5436_2Type::
      ISO5436_2Type (const Record1_type& Record1,
                     const Record3_type& Record3,
                     const Record4_type& Record4)
      : ::xml_schema::type (),
        Record1_ (Record1, ::xml_schema::flags (), this),
        Record2_ (::xml_schema::flags (), this),
        Record3_ (Record3, ::xml_schema::flags (), this),
        Record4_ (Record4, ::xml_schema::flags (), this),
        VendorSpecificID_ (::xml_schema::flags (), this)
      {
      }

      ISO5436_2Type::
      ISO5436_2Type (const ISO5436_2Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        Record1_ (x.Record1_, f, this),
        Record2_ (x.Record2_, f, this),
        Record3_ (x.Record3_, f, this),
        Record4_ (x.Record4_, f, this),
        VendorSpecificID_ (x.VendorSpecificID_, f, this)
      {
      }

      ISO5436_2Type::
      ISO5436_2Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Record1_ (f, this),
        Record2_ (f, this),
        Record3_ (f, this),
        Record4_ (f, this),
        VendorSpecificID_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void ISO5436_2Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Record1
          //
          if (n.name () == L"Record1" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Record1_type > r (
              Record1_traits::create (i, f, this));

            if (!Record1_.present ())
            {
              this->Record1 (r);
              continue;
            }
          }

          // Record2
          //
          if (n.name () == L"Record2" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Record2_type > r (
              Record2_traits::create (i, f, this));

            if (!this->Record2 ())
            {
              this->Record2 (r);
              continue;
            }
          }

          // Record3
          //
          if (n.name () == L"Record3" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Record3_type > r (
              Record3_traits::create (i, f, this));

            if (!Record3_.present ())
            {
              this->Record3 (r);
              continue;
            }
          }

          // Record4
          //
          if (n.name () == L"Record4" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Record4_type > r (
              Record4_traits::create (i, f, this));

            if (!Record4_.present ())
            {
              this->Record4 (r);
              continue;
            }
          }

          // VendorSpecificID
          //
          if (n.name () == L"VendorSpecificID" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< VendorSpecificID_type > r (
              VendorSpecificID_traits::create (i, f, this));

            if (!this->VendorSpecificID ())
            {
              this->VendorSpecificID (r);
              continue;
            }
          }

          break;
        }

        if (!Record1_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Record1",
            L"");
        }

        if (!Record3_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Record3",
            L"");
        }

        if (!Record4_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Record4",
            L"");
        }
      }

      ISO5436_2Type* ISO5436_2Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new ISO5436_2Type (*this, f, c);
      }

      bool
      operator== (const ISO5436_2Type& x, const ISO5436_2Type& y)
      {
        return x.Record1 () == y.Record1 () &&
        x.Record2 () == y.Record2 () &&
        x.Record3 () == y.Record3 () &&
        x.Record4 () == y.Record4 () &&
        x.VendorSpecificID () == y.VendorSpecificID ();
      }

      bool
      operator!= (const ISO5436_2Type& x, const ISO5436_2Type& y)
      {
        return !(x == y);
      }

      // Record2Type
      //

      Record2Type::
      Record2Type (const Date_type& Date,
                   const Instrument_type& Instrument,
                   const CalibrationDate_type& CalibrationDate,
                   const ProbingSystem_type& ProbingSystem)
      : ::xml_schema::type (),
        Date_ (Date, ::xml_schema::flags (), this),
        Creator_ (::xml_schema::flags (), this),
        Instrument_ (Instrument, ::xml_schema::flags (), this),
        CalibrationDate_ (CalibrationDate, ::xml_schema::flags (), this),
        ProbingSystem_ (ProbingSystem, ::xml_schema::flags (), this),
        Comment_ (::xml_schema::flags (), this)
      {
      }

      Record2Type::
      Record2Type (const Record2Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        Date_ (x.Date_, f, this),
        Creator_ (x.Creator_, f, this),
        Instrument_ (x.Instrument_, f, this),
        CalibrationDate_ (x.CalibrationDate_, f, this),
        ProbingSystem_ (x.ProbingSystem_, f, this),
        Comment_ (x.Comment_, f, this)
      {
      }

      Record2Type::
      Record2Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Date_ (f, this),
        Creator_ (f, this),
        Instrument_ (f, this),
        CalibrationDate_ (f, this),
        ProbingSystem_ (f, this),
        Comment_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void Record2Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Date
          //
          if (n.name () == L"Date" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Date_type > r (
              Date_traits::create (i, f, this));

            if (!Date_.present ())
            {
              this->Date (r);
              continue;
            }
          }

          // Creator
          //
          if (n.name () == L"Creator" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Creator_type > r (
              Creator_traits::create (i, f, this));

            if (!this->Creator ())
            {
              this->Creator (r);
              continue;
            }
          }

          // Instrument
          //
          if (n.name () == L"Instrument" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Instrument_type > r (
              Instrument_traits::create (i, f, this));

            if (!Instrument_.present ())
            {
              this->Instrument (r);
              continue;
            }
          }

          // CalibrationDate
          //
          if (n.name () == L"CalibrationDate" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< CalibrationDate_type > r (
              CalibrationDate_traits::create (i, f, this));

            if (!CalibrationDate_.present ())
            {
              this->CalibrationDate (r);
              continue;
            }
          }

          // ProbingSystem
          //
          if (n.name () == L"ProbingSystem" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< ProbingSystem_type > r (
              ProbingSystem_traits::create (i, f, this));

            if (!ProbingSystem_.present ())
            {
              this->ProbingSystem (r);
              continue;
            }
          }

          // Comment
          //
          if (n.name () == L"Comment" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Comment_type > r (
              Comment_traits::create (i, f, this));

            if (!this->Comment ())
            {
              this->Comment (r);
              continue;
            }
          }

          break;
        }

        if (!Date_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Date",
            L"");
        }

        if (!Instrument_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Instrument",
            L"");
        }

        if (!CalibrationDate_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"CalibrationDate",
            L"");
        }

        if (!ProbingSystem_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"ProbingSystem",
            L"");
        }
      }

      Record2Type* Record2Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Record2Type (*this, f, c);
      }

      bool
      operator== (const Record2Type& x, const Record2Type& y)
      {
        return x.Date () == y.Date () &&
        x.Creator () == y.Creator () &&
        x.Instrument () == y.Instrument () &&
        x.CalibrationDate () == y.CalibrationDate () &&
        x.ProbingSystem () == y.ProbingSystem () &&
        x.Comment () == y.Comment ();
      }

      bool
      operator!= (const Record2Type& x, const Record2Type& y)
      {
        return !(x == y);
      }

      // Record3Type
      //

      Record3Type::
      Record3Type ()
      : ::xml_schema::type (),
        MatrixDimension_ (::xml_schema::flags (), this),
        ListDimension_ (::xml_schema::flags (), this),
        DataLink_ (::xml_schema::flags (), this),
        DataList_ (::xml_schema::flags (), this)
      {
      }

      Record3Type::
      Record3Type (const Record3Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        MatrixDimension_ (x.MatrixDimension_, f, this),
        ListDimension_ (x.ListDimension_, f, this),
        DataLink_ (x.DataLink_, f, this),
        DataList_ (x.DataList_, f, this)
      {
      }

      Record3Type::
      Record3Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        MatrixDimension_ (f, this),
        ListDimension_ (f, this),
        DataLink_ (f, this),
        DataList_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void Record3Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // MatrixDimension
          //
          if (n.name () == L"MatrixDimension" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< MatrixDimension_type > r (
              MatrixDimension_traits::create (i, f, this));

            if (!this->MatrixDimension ())
            {
              this->MatrixDimension (r);
              continue;
            }
          }

          // ListDimension
          //
          if (n.name () == L"ListDimension" && n.namespace_ ().empty ())
          {
            if (!this->ListDimension ())
            {
              this->ListDimension (ListDimension_traits::create (i, f, this));
              continue;
            }
          }

          // DataLink
          //
          if (n.name () == L"DataLink" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< DataLink_type > r (
              DataLink_traits::create (i, f, this));

            if (!this->DataLink ())
            {
              this->DataLink (r);
              continue;
            }
          }

          // DataList
          //
          if (n.name () == L"DataList" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< DataList_type > r (
              DataList_traits::create (i, f, this));

            if (!this->DataList ())
            {
              this->DataList (r);
              continue;
            }
          }

          break;
        }
      }

      Record3Type* Record3Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Record3Type (*this, f, c);
      }

      bool
      operator== (const Record3Type& x, const Record3Type& y)
      {
        return x.MatrixDimension () == y.MatrixDimension () &&
        x.ListDimension () == y.ListDimension () &&
        x.DataLink () == y.DataLink () &&
        x.DataList () == y.DataList ();
      }

      bool
      operator!= (const Record3Type& x, const Record3Type& y)
      {
        return !(x == y);
      }

      // Record4Type
      //

      Record4Type::
      Record4Type (const ChecksumFile_type& ChecksumFile)
      : ::xml_schema::type (),
        ChecksumFile_ (ChecksumFile, ::xml_schema::flags (), this)
      {
      }

      Record4Type::
      Record4Type (const Record4Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        ChecksumFile_ (x.ChecksumFile_, f, this)
      {
      }

      Record4Type::
      Record4Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        ChecksumFile_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void Record4Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // ChecksumFile
          //
          if (n.name () == L"ChecksumFile" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< ChecksumFile_type > r (
              ChecksumFile_traits::create (i, f, this));

            if (!ChecksumFile_.present ())
            {
              this->ChecksumFile (r);
              continue;
            }
          }

          break;
        }

        if (!ChecksumFile_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"ChecksumFile",
            L"");
        }
      }

      Record4Type* Record4Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Record4Type (*this, f, c);
      }

      bool
      operator== (const Record4Type& x, const Record4Type& y)
      {
        return x.ChecksumFile () == y.ChecksumFile ();
      }

      bool
      operator!= (const Record4Type& x, const Record4Type& y)
      {
        return !(x == y);
      }

      // AxesType
      //

      AxesType::
      AxesType (const CX_type& CX,
                const CY_type& CY,
                const CZ_type& CZ)
      : ::xml_schema::type (),
        CX_ (CX, ::xml_schema::flags (), this),
        CY_ (CY, ::xml_schema::flags (), this),
        CZ_ (CZ, ::xml_schema::flags (), this),
        Rotation_ (::xml_schema::flags (), this)
      {
      }

      AxesType::
      AxesType (const AxesType& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        CX_ (x.CX_, f, this),
        CY_ (x.CY_, f, this),
        CZ_ (x.CZ_, f, this),
        Rotation_ (x.Rotation_, f, this)
      {
      }

      AxesType::
      AxesType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        CX_ (f, this),
        CY_ (f, this),
        CZ_ (f, this),
        Rotation_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void AxesType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // CX
          //
          if (n.name () == L"CX" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< CX_type > r (
              CX_traits::create (i, f, this));

            if (!CX_.present ())
            {
              this->CX (r);
              continue;
            }
          }

          // CY
          //
          if (n.name () == L"CY" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< CY_type > r (
              CY_traits::create (i, f, this));

            if (!CY_.present ())
            {
              this->CY (r);
              continue;
            }
          }

          // CZ
          //
          if (n.name () == L"CZ" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< CZ_type > r (
              CZ_traits::create (i, f, this));

            if (!CZ_.present ())
            {
              this->CZ (r);
              continue;
            }
          }

          // Rotation
          //
          if (n.name () == L"Rotation" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Rotation_type > r (
              Rotation_traits::create (i, f, this));

            if (!this->Rotation ())
            {
              this->Rotation (r);
              continue;
            }
          }

          break;
        }

        if (!CX_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"CX",
            L"");
        }

        if (!CY_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"CY",
            L"");
        }

        if (!CZ_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"CZ",
            L"");
        }
      }

      AxesType* AxesType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new AxesType (*this, f, c);
      }

      bool
      operator== (const AxesType& x, const AxesType& y)
      {
        return x.CX () == y.CX () &&
        x.CY () == y.CY () &&
        x.CZ () == y.CZ () &&
        x.Rotation () == y.Rotation ();
      }

      bool
      operator!= (const AxesType& x, const AxesType& y)
      {
        return !(x == y);
      }

      // AxisDescriptionType
      //

      AxisDescriptionType::
      AxisDescriptionType (const AxisType_type& AxisType)
      : ::xml_schema::type (),
        AxisType_ (AxisType, ::xml_schema::flags (), this),
        DataType_ (::xml_schema::flags (), this),
        Increment_ (::xml_schema::flags (), this),
        Offset_ (::xml_schema::flags (), this)
      {
      }

      AxisDescriptionType::
      AxisDescriptionType (const AxisDescriptionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        AxisType_ (x.AxisType_, f, this),
        DataType_ (x.DataType_, f, this),
        Increment_ (x.Increment_, f, this),
        Offset_ (x.Offset_, f, this)
      {
      }

      AxisDescriptionType::
      AxisDescriptionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        AxisType_ (f, this),
        DataType_ (f, this),
        Increment_ (f, this),
        Offset_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void AxisDescriptionType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // AxisType
          //
          if (n.name () == L"AxisType" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< AxisType_type > r (
              AxisType_traits::create (i, f, this));

            if (!AxisType_.present ())
            {
              this->AxisType (r);
              continue;
            }
          }

          // DataType
          //
          if (n.name () == L"DataType" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< DataType_type > r (
              DataType_traits::create (i, f, this));

            if (!this->DataType ())
            {
              this->DataType (r);
              continue;
            }
          }

          // Increment
          //
          if (n.name () == L"Increment" && n.namespace_ ().empty ())
          {
            if (!this->Increment ())
            {
              this->Increment (Increment_traits::create (i, f, this));
              continue;
            }
          }

          // Offset
          //
          if (n.name () == L"Offset" && n.namespace_ ().empty ())
          {
            if (!this->Offset ())
            {
              this->Offset (Offset_traits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!AxisType_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"AxisType",
            L"");
        }
      }

      AxisDescriptionType* AxisDescriptionType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new AxisDescriptionType (*this, f, c);
      }

      bool
      operator== (const AxisDescriptionType& x, const AxisDescriptionType& y)
      {
        return x.AxisType () == y.AxisType () &&
        x.DataType () == y.DataType () &&
        x.Increment () == y.Increment () &&
        x.Offset () == y.Offset ();
      }

      bool
      operator!= (const AxisDescriptionType& x, const AxisDescriptionType& y)
      {
        return !(x == y);
      }

      // InstrumentType
      //

      InstrumentType::
      InstrumentType (const Manufacturer_type& Manufacturer,
                      const Model_type& Model,
                      const Serial_type& Serial,
                      const Version_type& Version)
      : ::xml_schema::type (),
        Manufacturer_ (Manufacturer, ::xml_schema::flags (), this),
        Model_ (Model, ::xml_schema::flags (), this),
        Serial_ (Serial, ::xml_schema::flags (), this),
        Version_ (Version, ::xml_schema::flags (), this)
      {
      }

      InstrumentType::
      InstrumentType (const InstrumentType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        Manufacturer_ (x.Manufacturer_, f, this),
        Model_ (x.Model_, f, this),
        Serial_ (x.Serial_, f, this),
        Version_ (x.Version_, f, this)
      {
      }

      InstrumentType::
      InstrumentType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Manufacturer_ (f, this),
        Model_ (f, this),
        Serial_ (f, this),
        Version_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void InstrumentType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Manufacturer
          //
          if (n.name () == L"Manufacturer" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Manufacturer_type > r (
              Manufacturer_traits::create (i, f, this));

            if (!Manufacturer_.present ())
            {
              this->Manufacturer (r);
              continue;
            }
          }

          // Model
          //
          if (n.name () == L"Model" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Model_type > r (
              Model_traits::create (i, f, this));

            if (!Model_.present ())
            {
              this->Model (r);
              continue;
            }
          }

          // Serial
          //
          if (n.name () == L"Serial" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Serial_type > r (
              Serial_traits::create (i, f, this));

            if (!Serial_.present ())
            {
              this->Serial (r);
              continue;
            }
          }

          // Version
          //
          if (n.name () == L"Version" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Version_type > r (
              Version_traits::create (i, f, this));

            if (!Version_.present ())
            {
              this->Version (r);
              continue;
            }
          }

          break;
        }

        if (!Manufacturer_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Manufacturer",
            L"");
        }

        if (!Model_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Model",
            L"");
        }

        if (!Serial_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Serial",
            L"");
        }

        if (!Version_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Version",
            L"");
        }
      }

      InstrumentType* InstrumentType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new InstrumentType (*this, f, c);
      }

      bool
      operator== (const InstrumentType& x, const InstrumentType& y)
      {
        return x.Manufacturer () == y.Manufacturer () &&
        x.Model () == y.Model () &&
        x.Serial () == y.Serial () &&
        x.Version () == y.Version ();
      }

      bool
      operator!= (const InstrumentType& x, const InstrumentType& y)
      {
        return !(x == y);
      }

      // ProbingSystemType
      //

      ProbingSystemType::
      ProbingSystemType (const Type_type& Type,
                         const Identification_type& Identification)
      : ::xml_schema::type (),
        Type_ (Type, ::xml_schema::flags (), this),
        Identification_ (Identification, ::xml_schema::flags (), this)
      {
      }

      ProbingSystemType::
      ProbingSystemType (const ProbingSystemType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        Type_ (x.Type_, f, this),
        Identification_ (x.Identification_, f, this)
      {
      }

      ProbingSystemType::
      ProbingSystemType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Type_ (f, this),
        Identification_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void ProbingSystemType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Type
          //
          if (n.name () == L"Type" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Type_type > r (
              Type_traits::create (i, f, this));

            if (!Type_.present ())
            {
              this->Type (r);
              continue;
            }
          }

          // Identification
          //
          if (n.name () == L"Identification" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Identification_type > r (
              Identification_traits::create (i, f, this));

            if (!Identification_.present ())
            {
              this->Identification (r);
              continue;
            }
          }

          break;
        }

        if (!Type_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Type",
            L"");
        }

        if (!Identification_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Identification",
            L"");
        }
      }

      ProbingSystemType* ProbingSystemType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new ProbingSystemType (*this, f, c);
      }

      bool
      operator== (const ProbingSystemType& x, const ProbingSystemType& y)
      {
        return x.Type () == y.Type () &&
        x.Identification () == y.Identification ();
      }

      bool
      operator!= (const ProbingSystemType& x, const ProbingSystemType& y)
      {
        return !(x == y);
      }

      // DataListType
      //

      DataListType::
      DataListType ()
      : ::xml_schema::type (),
        Datum_ (::xml_schema::flags (), this)
      {
      }

      DataListType::
      DataListType (const DataListType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        Datum_ (x.Datum_, f, this)
      {
      }

      DataListType::
      DataListType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Datum_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void DataListType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Datum
          //
          if (n.name () == L"Datum" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Datum_type > r (
              Datum_traits::create (i, f, this));

            this->Datum ().push_back (r);
            continue;
          }

          break;
        }
      }

      DataListType* DataListType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new DataListType (*this, f, c);
      }

      bool
      operator== (const DataListType& x, const DataListType& y)
      {
        return x.Datum () == y.Datum ();
      }

      bool
      operator!= (const DataListType& x, const DataListType& y)
      {
        return !(x == y);
      }

      // DataLinkType
      //

      DataLinkType::
      DataLinkType (const PointDataLink_type& PointDataLink,
                    const MD5ChecksumPointData_type& MD5ChecksumPointData)
      : ::xml_schema::type (),
        PointDataLink_ (PointDataLink, ::xml_schema::flags (), this),
        MD5ChecksumPointData_ (MD5ChecksumPointData, ::xml_schema::flags (), this),
        ValidPointsLink_ (::xml_schema::flags (), this),
        MD5ChecksumValidPoints_ (::xml_schema::flags (), this)
      {
      }

      DataLinkType::
      DataLinkType (const DataLinkType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        PointDataLink_ (x.PointDataLink_, f, this),
        MD5ChecksumPointData_ (x.MD5ChecksumPointData_, f, this),
        ValidPointsLink_ (x.ValidPointsLink_, f, this),
        MD5ChecksumValidPoints_ (x.MD5ChecksumValidPoints_, f, this)
      {
      }

      DataLinkType::
      DataLinkType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        PointDataLink_ (f, this),
        MD5ChecksumPointData_ (f, this),
        ValidPointsLink_ (f, this),
        MD5ChecksumValidPoints_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void DataLinkType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // PointDataLink
          //
          if (n.name () == L"PointDataLink" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< PointDataLink_type > r (
              PointDataLink_traits::create (i, f, this));

            if (!PointDataLink_.present ())
            {
              this->PointDataLink (r);
              continue;
            }
          }

          // MD5ChecksumPointData
          //
          if (n.name () == L"MD5ChecksumPointData" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< MD5ChecksumPointData_type > r (
              MD5ChecksumPointData_traits::create (i, f, this));

            if (!MD5ChecksumPointData_.present ())
            {
              this->MD5ChecksumPointData (r);
              continue;
            }
          }

          // ValidPointsLink
          //
          if (n.name () == L"ValidPointsLink" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< ValidPointsLink_type > r (
              ValidPointsLink_traits::create (i, f, this));

            if (!this->ValidPointsLink ())
            {
              this->ValidPointsLink (r);
              continue;
            }
          }

          // MD5ChecksumValidPoints
          //
          if (n.name () == L"MD5ChecksumValidPoints" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< MD5ChecksumValidPoints_type > r (
              MD5ChecksumValidPoints_traits::create (i, f, this));

            if (!this->MD5ChecksumValidPoints ())
            {
              this->MD5ChecksumValidPoints (r);
              continue;
            }
          }

          break;
        }

        if (!PointDataLink_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"PointDataLink",
            L"");
        }

        if (!MD5ChecksumPointData_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"MD5ChecksumPointData",
            L"");
        }
      }

      DataLinkType* DataLinkType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new DataLinkType (*this, f, c);
      }

      bool
      operator== (const DataLinkType& x, const DataLinkType& y)
      {
        return x.PointDataLink () == y.PointDataLink () &&
        x.MD5ChecksumPointData () == y.MD5ChecksumPointData () &&
        x.ValidPointsLink () == y.ValidPointsLink () &&
        x.MD5ChecksumValidPoints () == y.MD5ChecksumValidPoints ();
      }

      bool
      operator!= (const DataLinkType& x, const DataLinkType& y)
      {
        return !(x == y);
      }

      // MatrixDimensionType
      //

      MatrixDimensionType::
      MatrixDimensionType (const SizeX_type& SizeX,
                           const SizeY_type& SizeY,
                           const SizeZ_type& SizeZ)
      : ::xml_schema::type (),
        SizeX_ (SizeX, ::xml_schema::flags (), this),
        SizeY_ (SizeY, ::xml_schema::flags (), this),
        SizeZ_ (SizeZ, ::xml_schema::flags (), this)
      {
      }

      MatrixDimensionType::
      MatrixDimensionType (const MatrixDimensionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        SizeX_ (x.SizeX_, f, this),
        SizeY_ (x.SizeY_, f, this),
        SizeZ_ (x.SizeZ_, f, this)
      {
      }

      MatrixDimensionType::
      MatrixDimensionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        SizeX_ (f, this),
        SizeY_ (f, this),
        SizeZ_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void MatrixDimensionType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // SizeX
          //
          if (n.name () == L"SizeX" && n.namespace_ ().empty ())
          {
            if (!SizeX_.present ())
            {
              this->SizeX (SizeX_traits::create (i, f, this));
              continue;
            }
          }

          // SizeY
          //
          if (n.name () == L"SizeY" && n.namespace_ ().empty ())
          {
            if (!SizeY_.present ())
            {
              this->SizeY (SizeY_traits::create (i, f, this));
              continue;
            }
          }

          // SizeZ
          //
          if (n.name () == L"SizeZ" && n.namespace_ ().empty ())
          {
            if (!SizeZ_.present ())
            {
              this->SizeZ (SizeZ_traits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!SizeX_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"SizeX",
            L"");
        }

        if (!SizeY_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"SizeY",
            L"");
        }

        if (!SizeZ_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"SizeZ",
            L"");
        }
      }

      MatrixDimensionType* MatrixDimensionType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new MatrixDimensionType (*this, f, c);
      }

      bool
      operator== (const MatrixDimensionType& x, const MatrixDimensionType& y)
      {
        return x.SizeX () == y.SizeX () &&
        x.SizeY () == y.SizeY () &&
        x.SizeZ () == y.SizeZ ();
      }

      bool
      operator!= (const MatrixDimensionType& x, const MatrixDimensionType& y)
      {
        return !(x == y);
      }

      // RotationType
      //

      RotationType::
      RotationType (const r11_type& r11,
                    const r12_type& r12,
                    const r13_type& r13,
                    const r21_type& r21,
                    const r22_type& r22,
                    const r23_type& r23,
                    const r31_type& r31,
                    const r32_type& r32,
                    const r33_type& r33)
      : ::xml_schema::type (),
        r11_ (r11, ::xml_schema::flags (), this),
        r12_ (r12, ::xml_schema::flags (), this),
        r13_ (r13, ::xml_schema::flags (), this),
        r21_ (r21, ::xml_schema::flags (), this),
        r22_ (r22, ::xml_schema::flags (), this),
        r23_ (r23, ::xml_schema::flags (), this),
        r31_ (r31, ::xml_schema::flags (), this),
        r32_ (r32, ::xml_schema::flags (), this),
        r33_ (r33, ::xml_schema::flags (), this)
      {
      }

      RotationType::
      RotationType (const RotationType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        r11_ (x.r11_, f, this),
        r12_ (x.r12_, f, this),
        r13_ (x.r13_, f, this),
        r21_ (x.r21_, f, this),
        r22_ (x.r22_, f, this),
        r23_ (x.r23_, f, this),
        r31_ (x.r31_, f, this),
        r32_ (x.r32_, f, this),
        r33_ (x.r33_, f, this)
      {
      }

      RotationType::
      RotationType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        r11_ (f, this),
        r12_ (f, this),
        r13_ (f, this),
        r21_ (f, this),
        r22_ (f, this),
        r23_ (f, this),
        r31_ (f, this),
        r32_ (f, this),
        r33_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
          this->parse (p, f);
        }
      }

      void RotationType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // r11
          //
          if (n.name () == L"r11" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r11_type > r (
              r11_traits::create (i, f, this));

            if (!r11_.present ())
            {
              this->r11 (r);
              continue;
            }
          }

          // r12
          //
          if (n.name () == L"r12" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r12_type > r (
              r12_traits::create (i, f, this));

            if (!r12_.present ())
            {
              this->r12 (r);
              continue;
            }
          }

          // r13
          //
          if (n.name () == L"r13" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r13_type > r (
              r13_traits::create (i, f, this));

            if (!r13_.present ())
            {
              this->r13 (r);
              continue;
            }
          }

          // r21
          //
          if (n.name () == L"r21" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r21_type > r (
              r21_traits::create (i, f, this));

            if (!r21_.present ())
            {
              this->r21 (r);
              continue;
            }
          }

          // r22
          //
          if (n.name () == L"r22" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r22_type > r (
              r22_traits::create (i, f, this));

            if (!r22_.present ())
            {
              this->r22 (r);
              continue;
            }
          }

          // r23
          //
          if (n.name () == L"r23" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r23_type > r (
              r23_traits::create (i, f, this));

            if (!r23_.present ())
            {
              this->r23 (r);
              continue;
            }
          }

          // r31
          //
          if (n.name () == L"r31" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r31_type > r (
              r31_traits::create (i, f, this));

            if (!r31_.present ())
            {
              this->r31 (r);
              continue;
            }
          }

          // r32
          //
          if (n.name () == L"r32" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r32_type > r (
              r32_traits::create (i, f, this));

            if (!r32_.present ())
            {
              this->r32 (r);
              continue;
            }
          }

          // r33
          //
          if (n.name () == L"r33" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r33_type > r (
              r33_traits::create (i, f, this));

            if (!r33_.present ())
            {
              this->r33 (r);
              continue;
            }
          }

          break;
        }

        if (!r11_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r11",
            L"");
        }

        if (!r12_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r12",
            L"");
        }

        if (!r13_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r13",
            L"");
        }

        if (!r21_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r21",
            L"");
        }

        if (!r22_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r22",
            L"");
        }

        if (!r23_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r23",
            L"");
        }

        if (!r31_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r31",
            L"");
        }

        if (!r32_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r32",
            L"");
        }

        if (!r33_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r33",
            L"");
        }
      }

      RotationType* RotationType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new RotationType (*this, f, c);
      }

      bool
      operator== (const RotationType& x, const RotationType& y)
      {
        return x.r11 () == y.r11 () &&
        x.r12 () == y.r12 () &&
        x.r13 () == y.r13 () &&
        x.r21 () == y.r21 () &&
        x.r22 () == y.r22 () &&
        x.r23 () == y.r23 () &&
        x.r31 () == y.r31 () &&
        x.r32 () == y.r32 () &&
        x.r33 () == y.r33 ();
      }

      bool
      operator!= (const RotationType& x, const RotationType& y)
      {
        return !(x == y);
      }

      // RotationMatrixElementType
      //

      RotationMatrixElementType::
      RotationMatrixElementType (const ::xml_schema::double_& double_)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (double_)
      {
      }

      RotationMatrixElementType::
      RotationMatrixElementType (const RotationMatrixElementType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (x, f, c)
      {
      }

      RotationMatrixElementType::
      RotationMatrixElementType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (e, f, c)
      {
      }

      RotationMatrixElementType::
      RotationMatrixElementType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (a, f, c)
      {
      }

      RotationMatrixElementType::
      RotationMatrixElementType (const ::std::wstring& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type > (s, e, f, c)
      {
      }

      RotationMatrixElementType* RotationMatrixElementType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new RotationMatrixElementType (*this, f, c);
      }

      // FeatureType
      //

      FeatureType::
      FeatureType ()
      : ::xml_schema::token ()
      {
      }

      FeatureType::
      FeatureType (const ::xml_schema::token& token)
      : ::xml_schema::token (token)
      {
      }

      FeatureType::
      FeatureType (const FeatureType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::token (x, f, c)
      {
      }

      FeatureType::
      FeatureType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::token (e, f, c)
      {
      }

      FeatureType::
      FeatureType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::token (a, f, c)
      {
      }

      FeatureType::
      FeatureType (const ::std::wstring& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
      : ::xml_schema::token (s, e, f, c)
      {
      }

      FeatureType* FeatureType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new FeatureType (*this, f, c);
      }

      // AxisType
      //

      AxisType::
      AxisType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::token (e, f, c)
      {
        _xsd_AxisType_convert ();
      }

      AxisType::
      AxisType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::token (a, f, c)
      {
        _xsd_AxisType_convert ();
      }

      AxisType::
      AxisType (const ::std::wstring& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::token (s, e, f, c)
      {
        _xsd_AxisType_convert ();
      }

      AxisType* AxisType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new AxisType (*this, f, c);
      }

      AxisType::value AxisType::
      _xsd_AxisType_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AxisType_literals_);
        const value* i (::std::lower_bound (
                          _xsd_AxisType_indexes_,
                          _xsd_AxisType_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_AxisType_indexes_ + 2 || _xsd_AxisType_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
        }

        return *i;
      }

      const wchar_t* const AxisType::
      _xsd_AxisType_literals_[2] =
      {
        L"A",
        L"I"
      };

      const AxisType::value AxisType::
      _xsd_AxisType_indexes_[2] =
      {
        ::OpenGPS::Schemas::ISO5436_2::AxisType::A,
        ::OpenGPS::Schemas::ISO5436_2::AxisType::I
      };

      // DataType
      //

      DataType::
      DataType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::token (e, f, c)
      {
        _xsd_DataType_convert ();
      }

      DataType::
      DataType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::token (a, f, c)
      {
        _xsd_DataType_convert ();
      }

      DataType::
      DataType (const ::std::wstring& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::token (s, e, f, c)
      {
        _xsd_DataType_convert ();
      }

      DataType* DataType::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new DataType (*this, f, c);
      }

      DataType::value DataType::
      _xsd_DataType_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DataType_literals_);
        const value* i (::std::lower_bound (
                          _xsd_DataType_indexes_,
                          _xsd_DataType_indexes_ + 4,
                          *this,
                          c));

        if (i == _xsd_DataType_indexes_ + 4 || _xsd_DataType_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
        }

        return *i;
      }

      const wchar_t* const DataType::
      _xsd_DataType_literals_[4] =
      {
        L"I",
        L"L",
        L"F",
        L"D"
      };

      const DataType::value DataType::
      _xsd_DataType_indexes_[4] =
      {
        ::OpenGPS::Schemas::ISO5436_2::DataType::D,
        ::OpenGPS::Schemas::ISO5436_2::DataType::F,
        ::OpenGPS::Schemas::ISO5436_2::DataType::I,
        ::OpenGPS::Schemas::ISO5436_2::DataType::L
      };

      // Type
      //

      Type::
      Type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::token (e, f, c)
      {
        _xsd_Type_convert ();
      }

      Type::
      Type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::token (a, f, c)
      {
        _xsd_Type_convert ();
      }

      Type::
      Type (const ::std::wstring& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::token (s, e, f, c)
      {
        _xsd_Type_convert ();
      }

      Type* Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Type (*this, f, c);
      }

      Type::value Type::
      _xsd_Type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_Type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_Type_indexes_,
                          _xsd_Type_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_Type_indexes_ + 2 || _xsd_Type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
        }

        return *i;
      }

      const wchar_t* const Type::
      _xsd_Type_literals_[2] =
      {
        L"Contacting",
        L"NonContacting"
      };

      const Type::value Type::
      _xsd_Type_indexes_[2] =
      {
        ::OpenGPS::Schemas::ISO5436_2::Type::Contacting,
        ::OpenGPS::Schemas::ISO5436_2::Type::NonContacting
      };

      // Datum
      //

      Datum::
      Datum ()
      : ::xml_schema::token ()
      {
      }

      Datum::
      Datum (const ::xml_schema::token& token)
      : ::xml_schema::token (token)
      {
      }

      Datum::
      Datum (const Datum& x,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::token (x, f, c)
      {
      }

      Datum::
      Datum (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::token (e, f, c)
      {
      }

      Datum::
      Datum (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::token (a, f, c)
      {
      }

      Datum::
      Datum (const ::std::wstring& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::token (s, e, f, c)
      {
      }

      Datum* Datum::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Datum (*this, f, c);
      }
    }
  }
}

#include <ostream>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      ::std::wostream&
      operator<< (::std::wostream& o, const Record1Type& i)
      {
        o << ::std::endl << L"Revision: " << i.Revision ();
        o << ::std::endl << L"FeatureType: " << i.FeatureType ();
        o << ::std::endl << L"Axes: " << i.Axes ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const ISO5436_2Type& i)
      {
        o << ::std::endl << L"Record1: " << i.Record1 ();
        if (i.Record2 ())
        {
          o << ::std::endl << L"Record2: " << *i.Record2 ();
        }

        o << ::std::endl << L"Record3: " << i.Record3 ();
        o << ::std::endl << L"Record4: " << i.Record4 ();
        if (i.VendorSpecificID ())
        {
          o << ::std::endl << L"VendorSpecificID: " << *i.VendorSpecificID ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Record2Type& i)
      {
        o << ::std::endl << L"Date: " << i.Date ();
        if (i.Creator ())
        {
          o << ::std::endl << L"Creator: " << *i.Creator ();
        }

        o << ::std::endl << L"Instrument: " << i.Instrument ();
        o << ::std::endl << L"CalibrationDate: " << i.CalibrationDate ();
        o << ::std::endl << L"ProbingSystem: " << i.ProbingSystem ();
        if (i.Comment ())
        {
          o << ::std::endl << L"Comment: " << *i.Comment ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Record3Type& i)
      {
        if (i.MatrixDimension ())
        {
          o << ::std::endl << L"MatrixDimension: " << *i.MatrixDimension ();
        }

        if (i.ListDimension ())
        {
          o << ::std::endl << L"ListDimension: " << *i.ListDimension ();
        }

        if (i.DataLink ())
        {
          o << ::std::endl << L"DataLink: " << *i.DataLink ();
        }

        if (i.DataList ())
        {
          o << ::std::endl << L"DataList: " << *i.DataList ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Record4Type& i)
      {
        o << ::std::endl << L"ChecksumFile: " << i.ChecksumFile ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const AxesType& i)
      {
        o << ::std::endl << L"CX: " << i.CX ();
        o << ::std::endl << L"CY: " << i.CY ();
        o << ::std::endl << L"CZ: " << i.CZ ();
        if (i.Rotation ())
        {
          o << ::std::endl << L"Rotation: " << *i.Rotation ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const AxisDescriptionType& i)
      {
        o << ::std::endl << L"AxisType: " << i.AxisType ();
        if (i.DataType ())
        {
          o << ::std::endl << L"DataType: " << *i.DataType ();
        }

        if (i.Increment ())
        {
          o << ::std::endl << L"Increment: " << *i.Increment ();
        }

        if (i.Offset ())
        {
          o << ::std::endl << L"Offset: " << *i.Offset ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const InstrumentType& i)
      {
        o << ::std::endl << L"Manufacturer: " << i.Manufacturer ();
        o << ::std::endl << L"Model: " << i.Model ();
        o << ::std::endl << L"Serial: " << i.Serial ();
        o << ::std::endl << L"Version: " << i.Version ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const ProbingSystemType& i)
      {
        o << ::std::endl << L"Type: " << i.Type ();
        o << ::std::endl << L"Identification: " << i.Identification ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const DataListType& i)
      {
        for (DataListType::Datum_const_iterator
             b (i.Datum ().begin ()), e (i.Datum ().end ());
             b != e; ++b)
        {
          o << ::std::endl << L"Datum: " << *b;
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const DataLinkType& i)
      {
        o << ::std::endl << L"PointDataLink: " << i.PointDataLink ();
        o << ::std::endl << L"MD5ChecksumPointData: " << i.MD5ChecksumPointData ();
        if (i.ValidPointsLink ())
        {
          o << ::std::endl << L"ValidPointsLink: " << *i.ValidPointsLink ();
        }

        if (i.MD5ChecksumValidPoints ())
        {
          o << ::std::endl << L"MD5ChecksumValidPoints: " << *i.MD5ChecksumValidPoints ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const MatrixDimensionType& i)
      {
        o << ::std::endl << L"SizeX: " << i.SizeX ();
        o << ::std::endl << L"SizeY: " << i.SizeY ();
        o << ::std::endl << L"SizeZ: " << i.SizeZ ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const RotationType& i)
      {
        o << ::std::endl << L"r11: " << i.r11 ();
        o << ::std::endl << L"r12: " << i.r12 ();
        o << ::std::endl << L"r13: " << i.r13 ();
        o << ::std::endl << L"r21: " << i.r21 ();
        o << ::std::endl << L"r22: " << i.r22 ();
        o << ::std::endl << L"r23: " << i.r23 ();
        o << ::std::endl << L"r31: " << i.r31 ();
        o << ::std::endl << L"r32: " << i.r32 ();
        o << ::std::endl << L"r33: " << i.r33 ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const RotationMatrixElementType& i)
      {
        o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type >& > (i);
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const FeatureType& i)
      {
        o << static_cast< const ::xml_schema::token& > (i);
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, AxisType::value i)
      {
        return o << AxisType::_xsd_AxisType_literals_[i];
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const AxisType& i)
      {
        return o << static_cast< const ::xml_schema::token& > (i);
      }

      ::std::wostream&
      operator<< (::std::wostream& o, DataType::value i)
      {
        return o << DataType::_xsd_DataType_literals_[i];
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const DataType& i)
      {
        return o << static_cast< const ::xml_schema::token& > (i);
      }

      ::std::wostream&
      operator<< (::std::wostream& o, Type::value i)
      {
        return o << Type::_xsd_Type_literals_[i];
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Type& i)
      {
        return o << static_cast< const ::xml_schema::token& > (i);
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Datum& i)
      {
        o << static_cast< const ::xml_schema::token& > (i);
        return o;
      }
    }
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::std::wstring& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< wchar_t > h;

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::std::wstring& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

        if (!d)
          throw ::xsd::cxx::tree::parsing< wchar_t > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::std::wstring& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

        if (!d)
          throw ::xsd::cxx::tree::parsing< wchar_t > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (wrap, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (wrap, h, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (wrap, h, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (wrap, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (wrap, h, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (wrap, h, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::tree::error_handler< wchar_t > h;

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

        if (!d)
          throw ::xsd::cxx::tree::parsing< wchar_t > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::xercesc::DOMInputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

        if (!d)
          throw ::xsd::cxx::tree::parsing< wchar_t > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        if (f & ::xml_schema::flags::keep_dom)
        {
          ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
            static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

          ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
            ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
              c.get (), f | ::xml_schema::flags::own_dom, p));

          c.release ();
          return r;
        }

        const ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (e));

        if (n.name () == L"ISO5436_2" &&
            n.namespace_ () == L"http://www.opengps.eu/2008/ISO5436_2")
        {
          ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
            ::xsd::cxx::tree::traits< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type, wchar_t >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
          n.name (),
          n.namespace_ (),
          L"ISO5436_2",
          L"http://www.opengps.eu/2008/ISO5436_2");
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::xercesc::DOMDocument* d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          ((f & ::xml_schema::flags::keep_dom) &&
           !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        const ::xercesc::DOMElement& e (
          c.get ()
          ? *c->getDocumentElement ()
          : *d->getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (e));

        if (n.name () == L"ISO5436_2" &&
            n.namespace_ () == L"http://www.opengps.eu/2008/ISO5436_2")
        {
          ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
            ::xsd::cxx::tree::traits< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type, wchar_t >::create (
              e, f, 0));
          c.release ();
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
          n.name (),
          n.namespace_ (),
          L"ISO5436_2",
          L"http://www.opengps.eu/2008/ISO5436_2");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      void
      ISO5436_2 (::std::ostream& o,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));

        ::xsd::cxx::tree::error_handler< wchar_t > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
        }
      }

      void
      ISO5436_2 (::std::ostream& o,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< wchar_t > ();
        }
      }

      void
      ISO5436_2 (::std::ostream& o,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< wchar_t > ();
        }
      }

      void
      ISO5436_2 (::xercesc::XMLFormatTarget& t,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));

        ::xsd::cxx::tree::error_handler< wchar_t > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
        }
      }

      void
      ISO5436_2 (::xercesc::XMLFormatTarget& t,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< wchar_t > ();
        }
      }

      void
      ISO5436_2 (::xercesc::XMLFormatTarget& t,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< wchar_t > ();
        }
      }

      void
      ISO5436_2 (::xercesc::DOMDocument& d,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 ::xml_schema::flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (e));

        if (n.name () == L"ISO5436_2" &&
            n.namespace_ () == L"http://www.opengps.eu/2008/ISO5436_2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ISO5436_2",
            L"http://www.opengps.eu/2008/ISO5436_2");
        }
      }

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
      ISO5436_2 (const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
      {
        try
        {
          ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::serialize< wchar_t > (
              L"ISO5436_2",
              L"http://www.opengps.eu/2008/ISO5436_2",
              m, f));

          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (*d, s, f);
          return d;
        }
        catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
        {
          throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
        }
        catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
        {
          throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Record1Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Revision
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Revision",
              e));

          s << i.Revision ();
        }

        // FeatureType
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"FeatureType",
              e));

          s << i.FeatureType ();
        }

        // Axes
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Axes",
              e));

          s << i.Axes ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ISO5436_2Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Record1
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Record1",
              e));

          s << i.Record1 ();
        }

        // Record2
        //
        if (i.Record2 ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Record2",
              e));

          s << *i.Record2 ();
        }

        // Record3
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Record3",
              e));

          s << i.Record3 ();
        }

        // Record4
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Record4",
              e));

          s << i.Record4 ();
        }

        // VendorSpecificID
        //
        if (i.VendorSpecificID ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"VendorSpecificID",
              e));

          s << *i.VendorSpecificID ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Record2Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Date
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Date",
              e));

          s << i.Date ();
        }

        // Creator
        //
        if (i.Creator ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Creator",
              e));

          s << *i.Creator ();
        }

        // Instrument
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Instrument",
              e));

          s << i.Instrument ();
        }

        // CalibrationDate
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CalibrationDate",
              e));

          s << i.CalibrationDate ();
        }

        // ProbingSystem
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ProbingSystem",
              e));

          s << i.ProbingSystem ();
        }

        // Comment
        //
        if (i.Comment ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Comment",
              e));

          s << *i.Comment ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Record3Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // MatrixDimension
        //
        if (i.MatrixDimension ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"MatrixDimension",
              e));

          s << *i.MatrixDimension ();
        }

        // ListDimension
        //
        if (i.ListDimension ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ListDimension",
              e));

          s << *i.ListDimension ();
        }

        // DataLink
        //
        if (i.DataLink ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"DataLink",
              e));

          s << *i.DataLink ();
        }

        // DataList
        //
        if (i.DataList ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"DataList",
              e));

          s << *i.DataList ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Record4Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // ChecksumFile
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ChecksumFile",
              e));

          s << i.ChecksumFile ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const AxesType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // CX
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CX",
              e));

          s << i.CX ();
        }

        // CY
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CY",
              e));

          s << i.CY ();
        }

        // CZ
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CZ",
              e));

          s << i.CZ ();
        }

        // Rotation
        //
        if (i.Rotation ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Rotation",
              e));

          s << *i.Rotation ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const AxisDescriptionType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // AxisType
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"AxisType",
              e));

          s << i.AxisType ();
        }

        // DataType
        //
        if (i.DataType ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"DataType",
              e));

          s << *i.DataType ();
        }

        // Increment
        //
        if (i.Increment ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Increment",
              e));

          s << *i.Increment ();
        }

        // Offset
        //
        if (i.Offset ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Offset",
              e));

          s << *i.Offset ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const InstrumentType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Manufacturer
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Manufacturer",
              e));

          s << i.Manufacturer ();
        }

        // Model
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Model",
              e));

          s << i.Model ();
        }

        // Serial
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Serial",
              e));

          s << i.Serial ();
        }

        // Version
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Version",
              e));

          s << i.Version ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ProbingSystemType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Type
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Type",
              e));

          s << i.Type ();
        }

        // Identification
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Identification",
              e));

          s << i.Identification ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const DataListType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Datum
        //
        for (DataListType::Datum_const_iterator
             b (i.Datum ().begin ()), n (i.Datum ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Datum",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const DataLinkType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // PointDataLink
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"PointDataLink",
              e));

          s << i.PointDataLink ();
        }

        // MD5ChecksumPointData
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"MD5ChecksumPointData",
              e));

          s << i.MD5ChecksumPointData ();
        }

        // ValidPointsLink
        //
        if (i.ValidPointsLink ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ValidPointsLink",
              e));

          s << *i.ValidPointsLink ();
        }

        // MD5ChecksumValidPoints
        //
        if (i.MD5ChecksumValidPoints ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"MD5ChecksumValidPoints",
              e));

          s << *i.MD5ChecksumValidPoints ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const MatrixDimensionType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // SizeX
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"SizeX",
              e));

          s << i.SizeX ();
        }

        // SizeY
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"SizeY",
              e));

          s << i.SizeY ();
        }

        // SizeZ
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"SizeZ",
              e));

          s << i.SizeZ ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const RotationType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // r11
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r11",
              e));

          s << i.r11 ();
        }

        // r12
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r12",
              e));

          s << i.r12 ();
        }

        // r13
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r13",
              e));

          s << i.r13 ();
        }

        // r21
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r21",
              e));

          s << i.r21 ();
        }

        // r22
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r22",
              e));

          s << i.r22 ();
        }

        // r23
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r23",
              e));

          s << i.r23 ();
        }

        // r31
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r31",
              e));

          s << i.r31 ();
        }

        // r32
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r32",
              e));

          s << i.r32 ();
        }

        // r33
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r33",
              e));

          s << i.r33 ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const RotationMatrixElementType& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type >& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a,const RotationMatrixElementType& i)
      {
        a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type >& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                  const RotationMatrixElementType& i)
      {
        l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type >& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const FeatureType& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a,const FeatureType& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                  const FeatureType& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const AxisType& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const AxisType& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                  const AxisType& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const DataType& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const DataType& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                  const DataType& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const Type& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const Type& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                  const Type& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const Datum& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a,const Datum& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                  const Datum& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

