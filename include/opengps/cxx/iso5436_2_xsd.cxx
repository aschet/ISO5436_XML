// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
/***************************************************************************
 *   Copyright by                                                          *
 *   Georg Wiora (NanoFocus AG) 2007                                       *
 *   Joerg Seewig (Uni Hannover),                                           *
 *   Andreas Walther (NanoFocus AG),                                       *
 *   Mark A. Weber (NanoFocus AG) 2007                                     *
 *   Johannes Herwig (Uni Duisburg-Essen) 2007                             *
 *                                                                         *
 *   This file is part of the openGPS (R)[TM] software library.            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License (LGPL)    *
 *   as published by the Free Software Foundation; either version 3 of     *
 *   the License, or (at your option) any later version.                   *
 *   for detail see the files "licence_LGPL-3.0.txt" and                   *
 *   "licence_GPL-3.0.txt".                                                *
 *                                                                         *
 *   openGPS is distributed in the hope that it will be useful,            *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU Lesser General Public License for more details.                   *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 *                                                                         *
 *   The name "openGPS" and the logo are registered as                     *
 *   European trade mark No. 006178354 for                                 *
 *   Physikalisch Technische Bundesanstalt (PTB)                           *
 *   http://www.ptb.de/                                                    *
 *                                                                         *
 *   More information about openGPS can be found at                        *
 *   http://www.opengps.eu/                                                *
 ***************************************************************************/

#include <opengps/opengps.h>
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "iso5436_2_xsd.hxx"

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      // Record1Type
      // 

      const Record1Type::Revision_type& Record1Type::
      Revision () const
      {
        return this->Revision_.get ();
      }

      Record1Type::Revision_type& Record1Type::
      Revision ()
      {
        return this->Revision_.get ();
      }

      void Record1Type::
      Revision (const Revision_type& x)
      {
        this->Revision_.set (x);
      }

      void Record1Type::
      Revision (::std::auto_ptr< Revision_type > x)
      {
        this->Revision_.set (x);
      }

      const Record1Type::FeatureType_type& Record1Type::
      FeatureType () const
      {
        return this->FeatureType_.get ();
      }

      Record1Type::FeatureType_type& Record1Type::
      FeatureType ()
      {
        return this->FeatureType_.get ();
      }

      void Record1Type::
      FeatureType (const FeatureType_type& x)
      {
        this->FeatureType_.set (x);
      }

      void Record1Type::
      FeatureType (::std::auto_ptr< FeatureType_type > x)
      {
        this->FeatureType_.set (x);
      }

      const Record1Type::Axes_type& Record1Type::
      Axes () const
      {
        return this->Axes_.get ();
      }

      Record1Type::Axes_type& Record1Type::
      Axes ()
      {
        return this->Axes_.get ();
      }

      void Record1Type::
      Axes (const Axes_type& x)
      {
        this->Axes_.set (x);
      }

      void Record1Type::
      Axes (::std::auto_ptr< Axes_type > x)
      {
        this->Axes_.set (x);
      }


      // ISO5436_2Type
      // 

      const ISO5436_2Type::Record1_type& ISO5436_2Type::
      Record1 () const
      {
        return this->Record1_.get ();
      }

      ISO5436_2Type::Record1_type& ISO5436_2Type::
      Record1 ()
      {
        return this->Record1_.get ();
      }

      void ISO5436_2Type::
      Record1 (const Record1_type& x)
      {
        this->Record1_.set (x);
      }

      void ISO5436_2Type::
      Record1 (::std::auto_ptr< Record1_type > x)
      {
        this->Record1_.set (x);
      }

      const ISO5436_2Type::Record2_optional& ISO5436_2Type::
      Record2 () const
      {
        return this->Record2_;
      }

      ISO5436_2Type::Record2_optional& ISO5436_2Type::
      Record2 ()
      {
        return this->Record2_;
      }

      void ISO5436_2Type::
      Record2 (const Record2_type& x)
      {
        this->Record2_.set (x);
      }

      void ISO5436_2Type::
      Record2 (const Record2_optional& x)
      {
        this->Record2_ = x;
      }

      void ISO5436_2Type::
      Record2 (::std::auto_ptr< Record2_type > x)
      {
        this->Record2_.set (x);
      }

      const ISO5436_2Type::Record3_type& ISO5436_2Type::
      Record3 () const
      {
        return this->Record3_.get ();
      }

      ISO5436_2Type::Record3_type& ISO5436_2Type::
      Record3 ()
      {
        return this->Record3_.get ();
      }

      void ISO5436_2Type::
      Record3 (const Record3_type& x)
      {
        this->Record3_.set (x);
      }

      void ISO5436_2Type::
      Record3 (::std::auto_ptr< Record3_type > x)
      {
        this->Record3_.set (x);
      }

      const ISO5436_2Type::Record4_type& ISO5436_2Type::
      Record4 () const
      {
        return this->Record4_.get ();
      }

      ISO5436_2Type::Record4_type& ISO5436_2Type::
      Record4 ()
      {
        return this->Record4_.get ();
      }

      void ISO5436_2Type::
      Record4 (const Record4_type& x)
      {
        this->Record4_.set (x);
      }

      void ISO5436_2Type::
      Record4 (::std::auto_ptr< Record4_type > x)
      {
        this->Record4_.set (x);
      }

      const ISO5436_2Type::VendorSpecificID_optional& ISO5436_2Type::
      VendorSpecificID () const
      {
        return this->VendorSpecificID_;
      }

      ISO5436_2Type::VendorSpecificID_optional& ISO5436_2Type::
      VendorSpecificID ()
      {
        return this->VendorSpecificID_;
      }

      void ISO5436_2Type::
      VendorSpecificID (const VendorSpecificID_type& x)
      {
        this->VendorSpecificID_.set (x);
      }

      void ISO5436_2Type::
      VendorSpecificID (const VendorSpecificID_optional& x)
      {
        this->VendorSpecificID_ = x;
      }

      void ISO5436_2Type::
      VendorSpecificID (::std::auto_ptr< VendorSpecificID_type > x)
      {
        this->VendorSpecificID_.set (x);
      }


      // Record2Type
      // 

      const Record2Type::Date_type& Record2Type::
      Date () const
      {
        return this->Date_.get ();
      }

      Record2Type::Date_type& Record2Type::
      Date ()
      {
        return this->Date_.get ();
      }

      void Record2Type::
      Date (const Date_type& x)
      {
        this->Date_.set (x);
      }

      void Record2Type::
      Date (::std::auto_ptr< Date_type > x)
      {
        this->Date_.set (x);
      }

      const Record2Type::Creator_optional& Record2Type::
      Creator () const
      {
        return this->Creator_;
      }

      Record2Type::Creator_optional& Record2Type::
      Creator ()
      {
        return this->Creator_;
      }

      void Record2Type::
      Creator (const Creator_type& x)
      {
        this->Creator_.set (x);
      }

      void Record2Type::
      Creator (const Creator_optional& x)
      {
        this->Creator_ = x;
      }

      void Record2Type::
      Creator (::std::auto_ptr< Creator_type > x)
      {
        this->Creator_.set (x);
      }

      const Record2Type::Instrument_type& Record2Type::
      Instrument () const
      {
        return this->Instrument_.get ();
      }

      Record2Type::Instrument_type& Record2Type::
      Instrument ()
      {
        return this->Instrument_.get ();
      }

      void Record2Type::
      Instrument (const Instrument_type& x)
      {
        this->Instrument_.set (x);
      }

      void Record2Type::
      Instrument (::std::auto_ptr< Instrument_type > x)
      {
        this->Instrument_.set (x);
      }

      const Record2Type::CalibrationDate_type& Record2Type::
      CalibrationDate () const
      {
        return this->CalibrationDate_.get ();
      }

      Record2Type::CalibrationDate_type& Record2Type::
      CalibrationDate ()
      {
        return this->CalibrationDate_.get ();
      }

      void Record2Type::
      CalibrationDate (const CalibrationDate_type& x)
      {
        this->CalibrationDate_.set (x);
      }

      void Record2Type::
      CalibrationDate (::std::auto_ptr< CalibrationDate_type > x)
      {
        this->CalibrationDate_.set (x);
      }

      const Record2Type::ProbingSystem_type& Record2Type::
      ProbingSystem () const
      {
        return this->ProbingSystem_.get ();
      }

      Record2Type::ProbingSystem_type& Record2Type::
      ProbingSystem ()
      {
        return this->ProbingSystem_.get ();
      }

      void Record2Type::
      ProbingSystem (const ProbingSystem_type& x)
      {
        this->ProbingSystem_.set (x);
      }

      void Record2Type::
      ProbingSystem (::std::auto_ptr< ProbingSystem_type > x)
      {
        this->ProbingSystem_.set (x);
      }

      const Record2Type::Comment_optional& Record2Type::
      Comment () const
      {
        return this->Comment_;
      }

      Record2Type::Comment_optional& Record2Type::
      Comment ()
      {
        return this->Comment_;
      }

      void Record2Type::
      Comment (const Comment_type& x)
      {
        this->Comment_.set (x);
      }

      void Record2Type::
      Comment (const Comment_optional& x)
      {
        this->Comment_ = x;
      }

      void Record2Type::
      Comment (::std::auto_ptr< Comment_type > x)
      {
        this->Comment_.set (x);
      }


      // Record3Type
      // 

      const Record3Type::MatrixDimension_optional& Record3Type::
      MatrixDimension () const
      {
        return this->MatrixDimension_;
      }

      Record3Type::MatrixDimension_optional& Record3Type::
      MatrixDimension ()
      {
        return this->MatrixDimension_;
      }

      void Record3Type::
      MatrixDimension (const MatrixDimension_type& x)
      {
        this->MatrixDimension_.set (x);
      }

      void Record3Type::
      MatrixDimension (const MatrixDimension_optional& x)
      {
        this->MatrixDimension_ = x;
      }

      void Record3Type::
      MatrixDimension (::std::auto_ptr< MatrixDimension_type > x)
      {
        this->MatrixDimension_.set (x);
      }

      const Record3Type::ListDimension_optional& Record3Type::
      ListDimension () const
      {
        return this->ListDimension_;
      }

      Record3Type::ListDimension_optional& Record3Type::
      ListDimension ()
      {
        return this->ListDimension_;
      }

      void Record3Type::
      ListDimension (const ListDimension_type& x)
      {
        this->ListDimension_.set (x);
      }

      void Record3Type::
      ListDimension (const ListDimension_optional& x)
      {
        this->ListDimension_ = x;
      }

      const Record3Type::DataLink_optional& Record3Type::
      DataLink () const
      {
        return this->DataLink_;
      }

      Record3Type::DataLink_optional& Record3Type::
      DataLink ()
      {
        return this->DataLink_;
      }

      void Record3Type::
      DataLink (const DataLink_type& x)
      {
        this->DataLink_.set (x);
      }

      void Record3Type::
      DataLink (const DataLink_optional& x)
      {
        this->DataLink_ = x;
      }

      void Record3Type::
      DataLink (::std::auto_ptr< DataLink_type > x)
      {
        this->DataLink_.set (x);
      }

      const Record3Type::DataList_optional& Record3Type::
      DataList () const
      {
        return this->DataList_;
      }

      Record3Type::DataList_optional& Record3Type::
      DataList ()
      {
        return this->DataList_;
      }

      void Record3Type::
      DataList (const DataList_type& x)
      {
        this->DataList_.set (x);
      }

      void Record3Type::
      DataList (const DataList_optional& x)
      {
        this->DataList_ = x;
      }

      void Record3Type::
      DataList (::std::auto_ptr< DataList_type > x)
      {
        this->DataList_.set (x);
      }


      // Record4Type
      // 

      const Record4Type::ChecksumFile_type& Record4Type::
      ChecksumFile () const
      {
        return this->ChecksumFile_.get ();
      }

      Record4Type::ChecksumFile_type& Record4Type::
      ChecksumFile ()
      {
        return this->ChecksumFile_.get ();
      }

      void Record4Type::
      ChecksumFile (const ChecksumFile_type& x)
      {
        this->ChecksumFile_.set (x);
      }

      void Record4Type::
      ChecksumFile (::std::auto_ptr< ChecksumFile_type > x)
      {
        this->ChecksumFile_.set (x);
      }


      // AxesType
      // 

      const AxesType::CX_type& AxesType::
      CX () const
      {
        return this->CX_.get ();
      }

      AxesType::CX_type& AxesType::
      CX ()
      {
        return this->CX_.get ();
      }

      void AxesType::
      CX (const CX_type& x)
      {
        this->CX_.set (x);
      }

      void AxesType::
      CX (::std::auto_ptr< CX_type > x)
      {
        this->CX_.set (x);
      }

      const AxesType::CY_type& AxesType::
      CY () const
      {
        return this->CY_.get ();
      }

      AxesType::CY_type& AxesType::
      CY ()
      {
        return this->CY_.get ();
      }

      void AxesType::
      CY (const CY_type& x)
      {
        this->CY_.set (x);
      }

      void AxesType::
      CY (::std::auto_ptr< CY_type > x)
      {
        this->CY_.set (x);
      }

      const AxesType::CZ_type& AxesType::
      CZ () const
      {
        return this->CZ_.get ();
      }

      AxesType::CZ_type& AxesType::
      CZ ()
      {
        return this->CZ_.get ();
      }

      void AxesType::
      CZ (const CZ_type& x)
      {
        this->CZ_.set (x);
      }

      void AxesType::
      CZ (::std::auto_ptr< CZ_type > x)
      {
        this->CZ_.set (x);
      }

      const AxesType::Rotation_optional& AxesType::
      Rotation () const
      {
        return this->Rotation_;
      }

      AxesType::Rotation_optional& AxesType::
      Rotation ()
      {
        return this->Rotation_;
      }

      void AxesType::
      Rotation (const Rotation_type& x)
      {
        this->Rotation_.set (x);
      }

      void AxesType::
      Rotation (const Rotation_optional& x)
      {
        this->Rotation_ = x;
      }

      void AxesType::
      Rotation (::std::auto_ptr< Rotation_type > x)
      {
        this->Rotation_.set (x);
      }


      // AxisDescriptionType
      // 

      const AxisDescriptionType::AxisType_type& AxisDescriptionType::
      AxisType () const
      {
        return this->AxisType_.get ();
      }

      AxisDescriptionType::AxisType_type& AxisDescriptionType::
      AxisType ()
      {
        return this->AxisType_.get ();
      }

      void AxisDescriptionType::
      AxisType (const AxisType_type& x)
      {
        this->AxisType_.set (x);
      }

      void AxisDescriptionType::
      AxisType (::std::auto_ptr< AxisType_type > x)
      {
        this->AxisType_.set (x);
      }

      const AxisDescriptionType::DataType_optional& AxisDescriptionType::
      DataType () const
      {
        return this->DataType_;
      }

      AxisDescriptionType::DataType_optional& AxisDescriptionType::
      DataType ()
      {
        return this->DataType_;
      }

      void AxisDescriptionType::
      DataType (const DataType_type& x)
      {
        this->DataType_.set (x);
      }

      void AxisDescriptionType::
      DataType (const DataType_optional& x)
      {
        this->DataType_ = x;
      }

      void AxisDescriptionType::
      DataType (::std::auto_ptr< DataType_type > x)
      {
        this->DataType_.set (x);
      }

      const AxisDescriptionType::Increment_optional& AxisDescriptionType::
      Increment () const
      {
        return this->Increment_;
      }

      AxisDescriptionType::Increment_optional& AxisDescriptionType::
      Increment ()
      {
        return this->Increment_;
      }

      void AxisDescriptionType::
      Increment (const Increment_type& x)
      {
        this->Increment_.set (x);
      }

      void AxisDescriptionType::
      Increment (const Increment_optional& x)
      {
        this->Increment_ = x;
      }

      const AxisDescriptionType::Offset_optional& AxisDescriptionType::
      Offset () const
      {
        return this->Offset_;
      }

      AxisDescriptionType::Offset_optional& AxisDescriptionType::
      Offset ()
      {
        return this->Offset_;
      }

      void AxisDescriptionType::
      Offset (const Offset_type& x)
      {
        this->Offset_.set (x);
      }

      void AxisDescriptionType::
      Offset (const Offset_optional& x)
      {
        this->Offset_ = x;
      }


      // InstrumentType
      // 

      const InstrumentType::Manufacturer_type& InstrumentType::
      Manufacturer () const
      {
        return this->Manufacturer_.get ();
      }

      InstrumentType::Manufacturer_type& InstrumentType::
      Manufacturer ()
      {
        return this->Manufacturer_.get ();
      }

      void InstrumentType::
      Manufacturer (const Manufacturer_type& x)
      {
        this->Manufacturer_.set (x);
      }

      void InstrumentType::
      Manufacturer (::std::auto_ptr< Manufacturer_type > x)
      {
        this->Manufacturer_.set (x);
      }

      const InstrumentType::Model_type& InstrumentType::
      Model () const
      {
        return this->Model_.get ();
      }

      InstrumentType::Model_type& InstrumentType::
      Model ()
      {
        return this->Model_.get ();
      }

      void InstrumentType::
      Model (const Model_type& x)
      {
        this->Model_.set (x);
      }

      void InstrumentType::
      Model (::std::auto_ptr< Model_type > x)
      {
        this->Model_.set (x);
      }

      const InstrumentType::Serial_type& InstrumentType::
      Serial () const
      {
        return this->Serial_.get ();
      }

      InstrumentType::Serial_type& InstrumentType::
      Serial ()
      {
        return this->Serial_.get ();
      }

      void InstrumentType::
      Serial (const Serial_type& x)
      {
        this->Serial_.set (x);
      }

      void InstrumentType::
      Serial (::std::auto_ptr< Serial_type > x)
      {
        this->Serial_.set (x);
      }

      const InstrumentType::Version_type& InstrumentType::
      Version () const
      {
        return this->Version_.get ();
      }

      InstrumentType::Version_type& InstrumentType::
      Version ()
      {
        return this->Version_.get ();
      }

      void InstrumentType::
      Version (const Version_type& x)
      {
        this->Version_.set (x);
      }

      void InstrumentType::
      Version (::std::auto_ptr< Version_type > x)
      {
        this->Version_.set (x);
      }


      // ProbingSystemType
      // 

      const ProbingSystemType::Type_type& ProbingSystemType::
      Type () const
      {
        return this->Type_.get ();
      }

      ProbingSystemType::Type_type& ProbingSystemType::
      Type ()
      {
        return this->Type_.get ();
      }

      void ProbingSystemType::
      Type (const Type_type& x)
      {
        this->Type_.set (x);
      }

      void ProbingSystemType::
      Type (::std::auto_ptr< Type_type > x)
      {
        this->Type_.set (x);
      }

      const ProbingSystemType::Identification_type& ProbingSystemType::
      Identification () const
      {
        return this->Identification_.get ();
      }

      ProbingSystemType::Identification_type& ProbingSystemType::
      Identification ()
      {
        return this->Identification_.get ();
      }

      void ProbingSystemType::
      Identification (const Identification_type& x)
      {
        this->Identification_.set (x);
      }

      void ProbingSystemType::
      Identification (::std::auto_ptr< Identification_type > x)
      {
        this->Identification_.set (x);
      }


      // DataListType
      // 

      const DataListType::Datum_sequence& DataListType::
      Datum () const
      {
        return this->Datum_;
      }

      DataListType::Datum_sequence& DataListType::
      Datum ()
      {
        return this->Datum_;
      }

      void DataListType::
      Datum (const Datum_sequence& s)
      {
        this->Datum_ = s;
      }


      // DataLinkType
      // 

      const DataLinkType::PointDataLink_type& DataLinkType::
      PointDataLink () const
      {
        return this->PointDataLink_.get ();
      }

      DataLinkType::PointDataLink_type& DataLinkType::
      PointDataLink ()
      {
        return this->PointDataLink_.get ();
      }

      void DataLinkType::
      PointDataLink (const PointDataLink_type& x)
      {
        this->PointDataLink_.set (x);
      }

      void DataLinkType::
      PointDataLink (::std::auto_ptr< PointDataLink_type > x)
      {
        this->PointDataLink_.set (x);
      }

      const DataLinkType::MD5ChecksumPointData_type& DataLinkType::
      MD5ChecksumPointData () const
      {
        return this->MD5ChecksumPointData_.get ();
      }

      DataLinkType::MD5ChecksumPointData_type& DataLinkType::
      MD5ChecksumPointData ()
      {
        return this->MD5ChecksumPointData_.get ();
      }

      void DataLinkType::
      MD5ChecksumPointData (const MD5ChecksumPointData_type& x)
      {
        this->MD5ChecksumPointData_.set (x);
      }

      void DataLinkType::
      MD5ChecksumPointData (::std::auto_ptr< MD5ChecksumPointData_type > x)
      {
        this->MD5ChecksumPointData_.set (x);
      }

      const DataLinkType::ValidPointsLink_optional& DataLinkType::
      ValidPointsLink () const
      {
        return this->ValidPointsLink_;
      }

      DataLinkType::ValidPointsLink_optional& DataLinkType::
      ValidPointsLink ()
      {
        return this->ValidPointsLink_;
      }

      void DataLinkType::
      ValidPointsLink (const ValidPointsLink_type& x)
      {
        this->ValidPointsLink_.set (x);
      }

      void DataLinkType::
      ValidPointsLink (const ValidPointsLink_optional& x)
      {
        this->ValidPointsLink_ = x;
      }

      void DataLinkType::
      ValidPointsLink (::std::auto_ptr< ValidPointsLink_type > x)
      {
        this->ValidPointsLink_.set (x);
      }

      const DataLinkType::MD5ChecksumValidPoints_optional& DataLinkType::
      MD5ChecksumValidPoints () const
      {
        return this->MD5ChecksumValidPoints_;
      }

      DataLinkType::MD5ChecksumValidPoints_optional& DataLinkType::
      MD5ChecksumValidPoints ()
      {
        return this->MD5ChecksumValidPoints_;
      }

      void DataLinkType::
      MD5ChecksumValidPoints (const MD5ChecksumValidPoints_type& x)
      {
        this->MD5ChecksumValidPoints_.set (x);
      }

      void DataLinkType::
      MD5ChecksumValidPoints (const MD5ChecksumValidPoints_optional& x)
      {
        this->MD5ChecksumValidPoints_ = x;
      }

      void DataLinkType::
      MD5ChecksumValidPoints (::std::auto_ptr< MD5ChecksumValidPoints_type > x)
      {
        this->MD5ChecksumValidPoints_.set (x);
      }


      // MatrixDimensionType
      // 

      const MatrixDimensionType::SizeX_type& MatrixDimensionType::
      SizeX () const
      {
        return this->SizeX_.get ();
      }

      MatrixDimensionType::SizeX_type& MatrixDimensionType::
      SizeX ()
      {
        return this->SizeX_.get ();
      }

      void MatrixDimensionType::
      SizeX (const SizeX_type& x)
      {
        this->SizeX_.set (x);
      }

      const MatrixDimensionType::SizeY_type& MatrixDimensionType::
      SizeY () const
      {
        return this->SizeY_.get ();
      }

      MatrixDimensionType::SizeY_type& MatrixDimensionType::
      SizeY ()
      {
        return this->SizeY_.get ();
      }

      void MatrixDimensionType::
      SizeY (const SizeY_type& x)
      {
        this->SizeY_.set (x);
      }

      const MatrixDimensionType::SizeZ_type& MatrixDimensionType::
      SizeZ () const
      {
        return this->SizeZ_.get ();
      }

      MatrixDimensionType::SizeZ_type& MatrixDimensionType::
      SizeZ ()
      {
        return this->SizeZ_.get ();
      }

      void MatrixDimensionType::
      SizeZ (const SizeZ_type& x)
      {
        this->SizeZ_.set (x);
      }


      // RotationType
      // 

      const RotationType::r11_type& RotationType::
      r11 () const
      {
        return this->r11_.get ();
      }

      RotationType::r11_type& RotationType::
      r11 ()
      {
        return this->r11_.get ();
      }

      void RotationType::
      r11 (const r11_type& x)
      {
        this->r11_.set (x);
      }

      void RotationType::
      r11 (::std::auto_ptr< r11_type > x)
      {
        this->r11_.set (x);
      }

      const RotationType::r12_type& RotationType::
      r12 () const
      {
        return this->r12_.get ();
      }

      RotationType::r12_type& RotationType::
      r12 ()
      {
        return this->r12_.get ();
      }

      void RotationType::
      r12 (const r12_type& x)
      {
        this->r12_.set (x);
      }

      void RotationType::
      r12 (::std::auto_ptr< r12_type > x)
      {
        this->r12_.set (x);
      }

      const RotationType::r13_type& RotationType::
      r13 () const
      {
        return this->r13_.get ();
      }

      RotationType::r13_type& RotationType::
      r13 ()
      {
        return this->r13_.get ();
      }

      void RotationType::
      r13 (const r13_type& x)
      {
        this->r13_.set (x);
      }

      void RotationType::
      r13 (::std::auto_ptr< r13_type > x)
      {
        this->r13_.set (x);
      }

      const RotationType::r21_type& RotationType::
      r21 () const
      {
        return this->r21_.get ();
      }

      RotationType::r21_type& RotationType::
      r21 ()
      {
        return this->r21_.get ();
      }

      void RotationType::
      r21 (const r21_type& x)
      {
        this->r21_.set (x);
      }

      void RotationType::
      r21 (::std::auto_ptr< r21_type > x)
      {
        this->r21_.set (x);
      }

      const RotationType::r22_type& RotationType::
      r22 () const
      {
        return this->r22_.get ();
      }

      RotationType::r22_type& RotationType::
      r22 ()
      {
        return this->r22_.get ();
      }

      void RotationType::
      r22 (const r22_type& x)
      {
        this->r22_.set (x);
      }

      void RotationType::
      r22 (::std::auto_ptr< r22_type > x)
      {
        this->r22_.set (x);
      }

      const RotationType::r23_type& RotationType::
      r23 () const
      {
        return this->r23_.get ();
      }

      RotationType::r23_type& RotationType::
      r23 ()
      {
        return this->r23_.get ();
      }

      void RotationType::
      r23 (const r23_type& x)
      {
        this->r23_.set (x);
      }

      void RotationType::
      r23 (::std::auto_ptr< r23_type > x)
      {
        this->r23_.set (x);
      }

      const RotationType::r31_type& RotationType::
      r31 () const
      {
        return this->r31_.get ();
      }

      RotationType::r31_type& RotationType::
      r31 ()
      {
        return this->r31_.get ();
      }

      void RotationType::
      r31 (const r31_type& x)
      {
        this->r31_.set (x);
      }

      void RotationType::
      r31 (::std::auto_ptr< r31_type > x)
      {
        this->r31_.set (x);
      }

      const RotationType::r32_type& RotationType::
      r32 () const
      {
        return this->r32_.get ();
      }

      RotationType::r32_type& RotationType::
      r32 ()
      {
        return this->r32_.get ();
      }

      void RotationType::
      r32 (const r32_type& x)
      {
        this->r32_.set (x);
      }

      void RotationType::
      r32 (::std::auto_ptr< r32_type > x)
      {
        this->r32_.set (x);
      }

      const RotationType::r33_type& RotationType::
      r33 () const
      {
        return this->r33_.get ();
      }

      RotationType::r33_type& RotationType::
      r33 ()
      {
        return this->r33_.get ();
      }

      void RotationType::
      r33 (const r33_type& x)
      {
        this->r33_.set (x);
      }

      void RotationType::
      r33 (::std::auto_ptr< r33_type > x)
      {
        this->r33_.set (x);
      }


      // RotationMatrixElementType
      // 


      // FeatureType
      // 

      FeatureType::
      FeatureType (value v)
      : ::xml_schema::token (_xsd_FeatureType_literals_[v])
      {
      }

      FeatureType::
      FeatureType (const wchar_t* v)
      : ::xml_schema::token (v)
      {
      }

      FeatureType::
      FeatureType (const ::std::wstring& v)
      : ::xml_schema::token (v)
      {
      }

      FeatureType::
      FeatureType (const ::xml_schema::token& v)
      : ::xml_schema::token (v)
      {
      }

      FeatureType::
      FeatureType (const FeatureType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::token (v, f, c)
      {
      }

      FeatureType& FeatureType::
      operator= (value v)
      {
        static_cast< ::xml_schema::token& > (*this) = 
        ::xml_schema::token (_xsd_FeatureType_literals_[v]);

        return *this;
      }


      // AxisType
      // 

      AxisType::
      AxisType (value v)
      : ::xml_schema::token (_xsd_AxisType_literals_[v])
      {
      }

      AxisType::
      AxisType (const wchar_t* v)
      : ::xml_schema::token (v)
      {
      }

      AxisType::
      AxisType (const ::std::wstring& v)
      : ::xml_schema::token (v)
      {
      }

      AxisType::
      AxisType (const ::xml_schema::token& v)
      : ::xml_schema::token (v)
      {
      }

      AxisType::
      AxisType (const AxisType& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::token (v, f, c)
      {
      }

      AxisType& AxisType::
      operator= (value v)
      {
        static_cast< ::xml_schema::token& > (*this) = 
        ::xml_schema::token (_xsd_AxisType_literals_[v]);

        return *this;
      }


      // DataType
      // 

      DataType::
      DataType (value v)
      : ::xml_schema::token (_xsd_DataType_literals_[v])
      {
      }

      DataType::
      DataType (const wchar_t* v)
      : ::xml_schema::token (v)
      {
      }

      DataType::
      DataType (const ::std::wstring& v)
      : ::xml_schema::token (v)
      {
      }

      DataType::
      DataType (const ::xml_schema::token& v)
      : ::xml_schema::token (v)
      {
      }

      DataType::
      DataType (const DataType& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::token (v, f, c)
      {
      }

      DataType& DataType::
      operator= (value v)
      {
        static_cast< ::xml_schema::token& > (*this) = 
        ::xml_schema::token (_xsd_DataType_literals_[v]);

        return *this;
      }


      // Type
      // 

      Type::
      Type (value v)
      : ::xml_schema::token (_xsd_Type_literals_[v])
      {
      }

      Type::
      Type (const wchar_t* v)
      : ::xml_schema::token (v)
      {
      }

      Type::
      Type (const ::std::wstring& v)
      : ::xml_schema::token (v)
      {
      }

      Type::
      Type (const ::xml_schema::token& v)
      : ::xml_schema::token (v)
      {
      }

      Type::
      Type (const Type& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
      : ::xml_schema::token (v, f, c)
      {
      }

      Type& Type::
      operator= (value v)
      {
        static_cast< ::xml_schema::token& > (*this) = 
        ::xml_schema::token (_xsd_Type_literals_[v]);

        return *this;
      }


      // Datum
      // 
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      // Record1Type
      //

      Record1Type::
      Record1Type (const Revision_type& Revision,
                   const FeatureType_type& FeatureType,
                   const Axes_type& Axes)
      : ::xml_schema::type (),
        Revision_ (Revision, ::xml_schema::flags (), this),
        FeatureType_ (FeatureType, ::xml_schema::flags (), this),
        Axes_ (Axes, ::xml_schema::flags (), this)
      {
      }

      Record1Type::
      Record1Type (const Revision_type& Revision,
                   const FeatureType_type& FeatureType,
                   ::std::auto_ptr< Axes_type >& Axes)
      : ::xml_schema::type (),
        Revision_ (Revision, ::xml_schema::flags (), this),
        FeatureType_ (FeatureType, ::xml_schema::flags (), this),
        Axes_ (Axes, ::xml_schema::flags (), this)
      {
      }

      Record1Type::
      Record1Type (const Record1Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Revision_ (x.Revision_, f, this),
        FeatureType_ (x.FeatureType_, f, this),
        Axes_ (x.Axes_, f, this)
      {
      }

      Record1Type::
      Record1Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Revision_ (f, this),
        FeatureType_ (f, this),
        Axes_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void Record1Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Revision
          //
          if (n.name () == L"Revision" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Revision_type > r (
              Revision_traits::create (i, f, this));

            if (!Revision_.present ())
            {
              this->Revision_.set (r);
              continue;
            }
          }

          // FeatureType
          //
          if (n.name () == L"FeatureType" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< FeatureType_type > r (
              FeatureType_traits::create (i, f, this));

            if (!FeatureType_.present ())
            {
              this->FeatureType_.set (r);
              continue;
            }
          }

          // Axes
          //
          if (n.name () == L"Axes" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Axes_type > r (
              Axes_traits::create (i, f, this));

            if (!Axes_.present ())
            {
              this->Axes_.set (r);
              continue;
            }
          }

          break;
        }

        if (!Revision_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Revision",
            L"");
        }

        if (!FeatureType_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"FeatureType",
            L"");
        }

        if (!Axes_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Axes",
            L"");
        }
      }

      Record1Type* Record1Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class Record1Type (*this, f, c);
      }

      Record1Type::
      ~Record1Type ()
      {
      }

      bool
      operator== (const Record1Type& x, const Record1Type& y)
      {
        if (!(x.Revision () == y.Revision ()))
          return false;

        if (!(x.FeatureType () == y.FeatureType ()))
          return false;

        if (!(x.Axes () == y.Axes ()))
          return false;

        return true;
      }

      bool
      operator!= (const Record1Type& x, const Record1Type& y)
      {
        return !(x == y);
      }

      // ISO5436_2Type
      //

      ISO5436_2Type::
      ISO5436_2Type (const Record1_type& Record1,
                     const Record3_type& Record3,
                     const Record4_type& Record4)
      : ::xml_schema::type (),
        Record1_ (Record1, ::xml_schema::flags (), this),
        Record2_ (::xml_schema::flags (), this),
        Record3_ (Record3, ::xml_schema::flags (), this),
        Record4_ (Record4, ::xml_schema::flags (), this),
        VendorSpecificID_ (::xml_schema::flags (), this)
      {
      }

      ISO5436_2Type::
      ISO5436_2Type (::std::auto_ptr< Record1_type >& Record1,
                     ::std::auto_ptr< Record3_type >& Record3,
                     ::std::auto_ptr< Record4_type >& Record4)
      : ::xml_schema::type (),
        Record1_ (Record1, ::xml_schema::flags (), this),
        Record2_ (::xml_schema::flags (), this),
        Record3_ (Record3, ::xml_schema::flags (), this),
        Record4_ (Record4, ::xml_schema::flags (), this),
        VendorSpecificID_ (::xml_schema::flags (), this)
      {
      }

      ISO5436_2Type::
      ISO5436_2Type (const ISO5436_2Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Record1_ (x.Record1_, f, this),
        Record2_ (x.Record2_, f, this),
        Record3_ (x.Record3_, f, this),
        Record4_ (x.Record4_, f, this),
        VendorSpecificID_ (x.VendorSpecificID_, f, this)
      {
      }

      ISO5436_2Type::
      ISO5436_2Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Record1_ (f, this),
        Record2_ (f, this),
        Record3_ (f, this),
        Record4_ (f, this),
        VendorSpecificID_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void ISO5436_2Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Record1
          //
          if (n.name () == L"Record1" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Record1_type > r (
              Record1_traits::create (i, f, this));

            if (!Record1_.present ())
            {
              this->Record1_.set (r);
              continue;
            }
          }

          // Record2
          //
          if (n.name () == L"Record2" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Record2_type > r (
              Record2_traits::create (i, f, this));

            if (!this->Record2_)
            {
              this->Record2_.set (r);
              continue;
            }
          }

          // Record3
          //
          if (n.name () == L"Record3" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Record3_type > r (
              Record3_traits::create (i, f, this));

            if (!Record3_.present ())
            {
              this->Record3_.set (r);
              continue;
            }
          }

          // Record4
          //
          if (n.name () == L"Record4" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Record4_type > r (
              Record4_traits::create (i, f, this));

            if (!Record4_.present ())
            {
              this->Record4_.set (r);
              continue;
            }
          }

          // VendorSpecificID
          //
          if (n.name () == L"VendorSpecificID" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< VendorSpecificID_type > r (
              VendorSpecificID_traits::create (i, f, this));

            if (!this->VendorSpecificID_)
            {
              this->VendorSpecificID_.set (r);
              continue;
            }
          }

          break;
        }

        if (!Record1_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Record1",
            L"");
        }

        if (!Record3_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Record3",
            L"");
        }

        if (!Record4_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Record4",
            L"");
        }
      }

      ISO5436_2Type* ISO5436_2Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ISO5436_2Type (*this, f, c);
      }

      ISO5436_2Type::
      ~ISO5436_2Type ()
      {
      }

      bool
      operator== (const ISO5436_2Type& x, const ISO5436_2Type& y)
      {
        if (!(x.Record1 () == y.Record1 ()))
          return false;

        if (!(x.Record2 () == y.Record2 ()))
          return false;

        if (!(x.Record3 () == y.Record3 ()))
          return false;

        if (!(x.Record4 () == y.Record4 ()))
          return false;

        if (!(x.VendorSpecificID () == y.VendorSpecificID ()))
          return false;

        return true;
      }

      bool
      operator!= (const ISO5436_2Type& x, const ISO5436_2Type& y)
      {
        return !(x == y);
      }

      // Record2Type
      //

      Record2Type::
      Record2Type (const Date_type& Date,
                   const Instrument_type& Instrument,
                   const CalibrationDate_type& CalibrationDate,
                   const ProbingSystem_type& ProbingSystem)
      : ::xml_schema::type (),
        Date_ (Date, ::xml_schema::flags (), this),
        Creator_ (::xml_schema::flags (), this),
        Instrument_ (Instrument, ::xml_schema::flags (), this),
        CalibrationDate_ (CalibrationDate, ::xml_schema::flags (), this),
        ProbingSystem_ (ProbingSystem, ::xml_schema::flags (), this),
        Comment_ (::xml_schema::flags (), this)
      {
      }

      Record2Type::
      Record2Type (const Date_type& Date,
                   ::std::auto_ptr< Instrument_type >& Instrument,
                   const CalibrationDate_type& CalibrationDate,
                   ::std::auto_ptr< ProbingSystem_type >& ProbingSystem)
      : ::xml_schema::type (),
        Date_ (Date, ::xml_schema::flags (), this),
        Creator_ (::xml_schema::flags (), this),
        Instrument_ (Instrument, ::xml_schema::flags (), this),
        CalibrationDate_ (CalibrationDate, ::xml_schema::flags (), this),
        ProbingSystem_ (ProbingSystem, ::xml_schema::flags (), this),
        Comment_ (::xml_schema::flags (), this)
      {
      }

      Record2Type::
      Record2Type (const Record2Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Date_ (x.Date_, f, this),
        Creator_ (x.Creator_, f, this),
        Instrument_ (x.Instrument_, f, this),
        CalibrationDate_ (x.CalibrationDate_, f, this),
        ProbingSystem_ (x.ProbingSystem_, f, this),
        Comment_ (x.Comment_, f, this)
      {
      }

      Record2Type::
      Record2Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Date_ (f, this),
        Creator_ (f, this),
        Instrument_ (f, this),
        CalibrationDate_ (f, this),
        ProbingSystem_ (f, this),
        Comment_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void Record2Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Date
          //
          if (n.name () == L"Date" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Date_type > r (
              Date_traits::create (i, f, this));

            if (!Date_.present ())
            {
              this->Date_.set (r);
              continue;
            }
          }

          // Creator
          //
          if (n.name () == L"Creator" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Creator_type > r (
              Creator_traits::create (i, f, this));

            if (!this->Creator_)
            {
              this->Creator_.set (r);
              continue;
            }
          }

          // Instrument
          //
          if (n.name () == L"Instrument" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Instrument_type > r (
              Instrument_traits::create (i, f, this));

            if (!Instrument_.present ())
            {
              this->Instrument_.set (r);
              continue;
            }
          }

          // CalibrationDate
          //
          if (n.name () == L"CalibrationDate" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< CalibrationDate_type > r (
              CalibrationDate_traits::create (i, f, this));

            if (!CalibrationDate_.present ())
            {
              this->CalibrationDate_.set (r);
              continue;
            }
          }

          // ProbingSystem
          //
          if (n.name () == L"ProbingSystem" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< ProbingSystem_type > r (
              ProbingSystem_traits::create (i, f, this));

            if (!ProbingSystem_.present ())
            {
              this->ProbingSystem_.set (r);
              continue;
            }
          }

          // Comment
          //
          if (n.name () == L"Comment" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Comment_type > r (
              Comment_traits::create (i, f, this));

            if (!this->Comment_)
            {
              this->Comment_.set (r);
              continue;
            }
          }

          break;
        }

        if (!Date_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Date",
            L"");
        }

        if (!Instrument_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Instrument",
            L"");
        }

        if (!CalibrationDate_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"CalibrationDate",
            L"");
        }

        if (!ProbingSystem_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"ProbingSystem",
            L"");
        }
      }

      Record2Type* Record2Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class Record2Type (*this, f, c);
      }

      Record2Type::
      ~Record2Type ()
      {
      }

      bool
      operator== (const Record2Type& x, const Record2Type& y)
      {
        if (!(x.Date () == y.Date ()))
          return false;

        if (!(x.Creator () == y.Creator ()))
          return false;

        if (!(x.Instrument () == y.Instrument ()))
          return false;

        if (!(x.CalibrationDate () == y.CalibrationDate ()))
          return false;

        if (!(x.ProbingSystem () == y.ProbingSystem ()))
          return false;

        if (!(x.Comment () == y.Comment ()))
          return false;

        return true;
      }

      bool
      operator!= (const Record2Type& x, const Record2Type& y)
      {
        return !(x == y);
      }

      // Record3Type
      //

      Record3Type::
      Record3Type ()
      : ::xml_schema::type (),
        MatrixDimension_ (::xml_schema::flags (), this),
        ListDimension_ (::xml_schema::flags (), this),
        DataLink_ (::xml_schema::flags (), this),
        DataList_ (::xml_schema::flags (), this)
      {
      }

      Record3Type::
      Record3Type (const Record3Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        MatrixDimension_ (x.MatrixDimension_, f, this),
        ListDimension_ (x.ListDimension_, f, this),
        DataLink_ (x.DataLink_, f, this),
        DataList_ (x.DataList_, f, this)
      {
      }

      Record3Type::
      Record3Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        MatrixDimension_ (f, this),
        ListDimension_ (f, this),
        DataLink_ (f, this),
        DataList_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void Record3Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // MatrixDimension
          //
          if (n.name () == L"MatrixDimension" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< MatrixDimension_type > r (
              MatrixDimension_traits::create (i, f, this));

            if (!this->MatrixDimension_)
            {
              this->MatrixDimension_.set (r);
              continue;
            }
          }

          // ListDimension
          //
          if (n.name () == L"ListDimension" && n.namespace_ ().empty ())
          {
            if (!this->ListDimension_)
            {
              this->ListDimension_.set (ListDimension_traits::create (i, f, this));
              continue;
            }
          }

          // DataLink
          //
          if (n.name () == L"DataLink" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< DataLink_type > r (
              DataLink_traits::create (i, f, this));

            if (!this->DataLink_)
            {
              this->DataLink_.set (r);
              continue;
            }
          }

          // DataList
          //
          if (n.name () == L"DataList" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< DataList_type > r (
              DataList_traits::create (i, f, this));

            if (!this->DataList_)
            {
              this->DataList_.set (r);
              continue;
            }
          }

          break;
        }
      }

      Record3Type* Record3Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class Record3Type (*this, f, c);
      }

      Record3Type::
      ~Record3Type ()
      {
      }

      bool
      operator== (const Record3Type& x, const Record3Type& y)
      {
        if (!(x.MatrixDimension () == y.MatrixDimension ()))
          return false;

        if (!(x.ListDimension () == y.ListDimension ()))
          return false;

        if (!(x.DataLink () == y.DataLink ()))
          return false;

        if (!(x.DataList () == y.DataList ()))
          return false;

        return true;
      }

      bool
      operator!= (const Record3Type& x, const Record3Type& y)
      {
        return !(x == y);
      }

      // Record4Type
      //

      Record4Type::
      Record4Type (const ChecksumFile_type& ChecksumFile)
      : ::xml_schema::type (),
        ChecksumFile_ (ChecksumFile, ::xml_schema::flags (), this)
      {
      }

      Record4Type::
      Record4Type (const Record4Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        ChecksumFile_ (x.ChecksumFile_, f, this)
      {
      }

      Record4Type::
      Record4Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        ChecksumFile_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void Record4Type::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // ChecksumFile
          //
          if (n.name () == L"ChecksumFile" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< ChecksumFile_type > r (
              ChecksumFile_traits::create (i, f, this));

            if (!ChecksumFile_.present ())
            {
              this->ChecksumFile_.set (r);
              continue;
            }
          }

          break;
        }

        if (!ChecksumFile_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"ChecksumFile",
            L"");
        }
      }

      Record4Type* Record4Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class Record4Type (*this, f, c);
      }

      Record4Type::
      ~Record4Type ()
      {
      }

      bool
      operator== (const Record4Type& x, const Record4Type& y)
      {
        if (!(x.ChecksumFile () == y.ChecksumFile ()))
          return false;

        return true;
      }

      bool
      operator!= (const Record4Type& x, const Record4Type& y)
      {
        return !(x == y);
      }

      // AxesType
      //

      AxesType::
      AxesType (const CX_type& CX,
                const CY_type& CY,
                const CZ_type& CZ)
      : ::xml_schema::type (),
        CX_ (CX, ::xml_schema::flags (), this),
        CY_ (CY, ::xml_schema::flags (), this),
        CZ_ (CZ, ::xml_schema::flags (), this),
        Rotation_ (::xml_schema::flags (), this)
      {
      }

      AxesType::
      AxesType (::std::auto_ptr< CX_type >& CX,
                ::std::auto_ptr< CY_type >& CY,
                ::std::auto_ptr< CZ_type >& CZ)
      : ::xml_schema::type (),
        CX_ (CX, ::xml_schema::flags (), this),
        CY_ (CY, ::xml_schema::flags (), this),
        CZ_ (CZ, ::xml_schema::flags (), this),
        Rotation_ (::xml_schema::flags (), this)
      {
      }

      AxesType::
      AxesType (const AxesType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        CX_ (x.CX_, f, this),
        CY_ (x.CY_, f, this),
        CZ_ (x.CZ_, f, this),
        Rotation_ (x.Rotation_, f, this)
      {
      }

      AxesType::
      AxesType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        CX_ (f, this),
        CY_ (f, this),
        CZ_ (f, this),
        Rotation_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void AxesType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // CX
          //
          if (n.name () == L"CX" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< CX_type > r (
              CX_traits::create (i, f, this));

            if (!CX_.present ())
            {
              this->CX_.set (r);
              continue;
            }
          }

          // CY
          //
          if (n.name () == L"CY" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< CY_type > r (
              CY_traits::create (i, f, this));

            if (!CY_.present ())
            {
              this->CY_.set (r);
              continue;
            }
          }

          // CZ
          //
          if (n.name () == L"CZ" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< CZ_type > r (
              CZ_traits::create (i, f, this));

            if (!CZ_.present ())
            {
              this->CZ_.set (r);
              continue;
            }
          }

          // Rotation
          //
          if (n.name () == L"Rotation" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Rotation_type > r (
              Rotation_traits::create (i, f, this));

            if (!this->Rotation_)
            {
              this->Rotation_.set (r);
              continue;
            }
          }

          break;
        }

        if (!CX_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"CX",
            L"");
        }

        if (!CY_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"CY",
            L"");
        }

        if (!CZ_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"CZ",
            L"");
        }
      }

      AxesType* AxesType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class AxesType (*this, f, c);
      }

      AxesType::
      ~AxesType ()
      {
      }

      bool
      operator== (const AxesType& x, const AxesType& y)
      {
        if (!(x.CX () == y.CX ()))
          return false;

        if (!(x.CY () == y.CY ()))
          return false;

        if (!(x.CZ () == y.CZ ()))
          return false;

        if (!(x.Rotation () == y.Rotation ()))
          return false;

        return true;
      }

      bool
      operator!= (const AxesType& x, const AxesType& y)
      {
        return !(x == y);
      }

      // AxisDescriptionType
      //

      AxisDescriptionType::
      AxisDescriptionType (const AxisType_type& AxisType)
      : ::xml_schema::type (),
        AxisType_ (AxisType, ::xml_schema::flags (), this),
        DataType_ (::xml_schema::flags (), this),
        Increment_ (::xml_schema::flags (), this),
        Offset_ (::xml_schema::flags (), this)
      {
      }

      AxisDescriptionType::
      AxisDescriptionType (const AxisDescriptionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        AxisType_ (x.AxisType_, f, this),
        DataType_ (x.DataType_, f, this),
        Increment_ (x.Increment_, f, this),
        Offset_ (x.Offset_, f, this)
      {
      }

      AxisDescriptionType::
      AxisDescriptionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        AxisType_ (f, this),
        DataType_ (f, this),
        Increment_ (f, this),
        Offset_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void AxisDescriptionType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // AxisType
          //
          if (n.name () == L"AxisType" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< AxisType_type > r (
              AxisType_traits::create (i, f, this));

            if (!AxisType_.present ())
            {
              this->AxisType_.set (r);
              continue;
            }
          }

          // DataType
          //
          if (n.name () == L"DataType" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< DataType_type > r (
              DataType_traits::create (i, f, this));

            if (!this->DataType_)
            {
              this->DataType_.set (r);
              continue;
            }
          }

          // Increment
          //
          if (n.name () == L"Increment" && n.namespace_ ().empty ())
          {
            if (!this->Increment_)
            {
              this->Increment_.set (Increment_traits::create (i, f, this));
              continue;
            }
          }

          // Offset
          //
          if (n.name () == L"Offset" && n.namespace_ ().empty ())
          {
            if (!this->Offset_)
            {
              this->Offset_.set (Offset_traits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!AxisType_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"AxisType",
            L"");
        }
      }

      AxisDescriptionType* AxisDescriptionType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class AxisDescriptionType (*this, f, c);
      }

      AxisDescriptionType::
      ~AxisDescriptionType ()
      {
      }

      bool
      operator== (const AxisDescriptionType& x, const AxisDescriptionType& y)
      {
        if (!(x.AxisType () == y.AxisType ()))
          return false;

        if (!(x.DataType () == y.DataType ()))
          return false;

        if (!(x.Increment () == y.Increment ()))
          return false;

        if (!(x.Offset () == y.Offset ()))
          return false;

        return true;
      }

      bool
      operator!= (const AxisDescriptionType& x, const AxisDescriptionType& y)
      {
        return !(x == y);
      }

      // InstrumentType
      //

      InstrumentType::
      InstrumentType (const Manufacturer_type& Manufacturer,
                      const Model_type& Model,
                      const Serial_type& Serial,
                      const Version_type& Version)
      : ::xml_schema::type (),
        Manufacturer_ (Manufacturer, ::xml_schema::flags (), this),
        Model_ (Model, ::xml_schema::flags (), this),
        Serial_ (Serial, ::xml_schema::flags (), this),
        Version_ (Version, ::xml_schema::flags (), this)
      {
      }

      InstrumentType::
      InstrumentType (const InstrumentType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Manufacturer_ (x.Manufacturer_, f, this),
        Model_ (x.Model_, f, this),
        Serial_ (x.Serial_, f, this),
        Version_ (x.Version_, f, this)
      {
      }

      InstrumentType::
      InstrumentType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Manufacturer_ (f, this),
        Model_ (f, this),
        Serial_ (f, this),
        Version_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void InstrumentType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Manufacturer
          //
          if (n.name () == L"Manufacturer" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Manufacturer_type > r (
              Manufacturer_traits::create (i, f, this));

            if (!Manufacturer_.present ())
            {
              this->Manufacturer_.set (r);
              continue;
            }
          }

          // Model
          //
          if (n.name () == L"Model" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Model_type > r (
              Model_traits::create (i, f, this));

            if (!Model_.present ())
            {
              this->Model_.set (r);
              continue;
            }
          }

          // Serial
          //
          if (n.name () == L"Serial" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Serial_type > r (
              Serial_traits::create (i, f, this));

            if (!Serial_.present ())
            {
              this->Serial_.set (r);
              continue;
            }
          }

          // Version
          //
          if (n.name () == L"Version" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Version_type > r (
              Version_traits::create (i, f, this));

            if (!Version_.present ())
            {
              this->Version_.set (r);
              continue;
            }
          }

          break;
        }

        if (!Manufacturer_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Manufacturer",
            L"");
        }

        if (!Model_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Model",
            L"");
        }

        if (!Serial_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Serial",
            L"");
        }

        if (!Version_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Version",
            L"");
        }
      }

      InstrumentType* InstrumentType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class InstrumentType (*this, f, c);
      }

      InstrumentType::
      ~InstrumentType ()
      {
      }

      bool
      operator== (const InstrumentType& x, const InstrumentType& y)
      {
        if (!(x.Manufacturer () == y.Manufacturer ()))
          return false;

        if (!(x.Model () == y.Model ()))
          return false;

        if (!(x.Serial () == y.Serial ()))
          return false;

        if (!(x.Version () == y.Version ()))
          return false;

        return true;
      }

      bool
      operator!= (const InstrumentType& x, const InstrumentType& y)
      {
        return !(x == y);
      }

      // ProbingSystemType
      //

      ProbingSystemType::
      ProbingSystemType (const Type_type& Type,
                         const Identification_type& Identification)
      : ::xml_schema::type (),
        Type_ (Type, ::xml_schema::flags (), this),
        Identification_ (Identification, ::xml_schema::flags (), this)
      {
      }

      ProbingSystemType::
      ProbingSystemType (const ProbingSystemType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Type_ (x.Type_, f, this),
        Identification_ (x.Identification_, f, this)
      {
      }

      ProbingSystemType::
      ProbingSystemType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Type_ (f, this),
        Identification_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void ProbingSystemType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Type
          //
          if (n.name () == L"Type" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Type_type > r (
              Type_traits::create (i, f, this));

            if (!Type_.present ())
            {
              this->Type_.set (r);
              continue;
            }
          }

          // Identification
          //
          if (n.name () == L"Identification" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Identification_type > r (
              Identification_traits::create (i, f, this));

            if (!Identification_.present ())
            {
              this->Identification_.set (r);
              continue;
            }
          }

          break;
        }

        if (!Type_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Type",
            L"");
        }

        if (!Identification_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"Identification",
            L"");
        }
      }

      ProbingSystemType* ProbingSystemType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class ProbingSystemType (*this, f, c);
      }

      ProbingSystemType::
      ~ProbingSystemType ()
      {
      }

      bool
      operator== (const ProbingSystemType& x, const ProbingSystemType& y)
      {
        if (!(x.Type () == y.Type ()))
          return false;

        if (!(x.Identification () == y.Identification ()))
          return false;

        return true;
      }

      bool
      operator!= (const ProbingSystemType& x, const ProbingSystemType& y)
      {
        return !(x == y);
      }

      // DataListType
      //

      DataListType::
      DataListType ()
      : ::xml_schema::type (),
        Datum_ (::xml_schema::flags (), this)
      {
      }

      DataListType::
      DataListType (const DataListType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        Datum_ (x.Datum_, f, this)
      {
      }

      DataListType::
      DataListType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        Datum_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void DataListType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // Datum
          //
          if (n.name () == L"Datum" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< Datum_type > r (
              Datum_traits::create (i, f, this));

            this->Datum_.push_back (r);
            continue;
          }

          break;
        }
      }

      DataListType* DataListType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class DataListType (*this, f, c);
      }

      DataListType::
      ~DataListType ()
      {
      }

      bool
      operator== (const DataListType& x, const DataListType& y)
      {
        if (!(x.Datum () == y.Datum ()))
          return false;

        return true;
      }

      bool
      operator!= (const DataListType& x, const DataListType& y)
      {
        return !(x == y);
      }

      // DataLinkType
      //

      DataLinkType::
      DataLinkType (const PointDataLink_type& PointDataLink,
                    const MD5ChecksumPointData_type& MD5ChecksumPointData)
      : ::xml_schema::type (),
        PointDataLink_ (PointDataLink, ::xml_schema::flags (), this),
        MD5ChecksumPointData_ (MD5ChecksumPointData, ::xml_schema::flags (), this),
        ValidPointsLink_ (::xml_schema::flags (), this),
        MD5ChecksumValidPoints_ (::xml_schema::flags (), this)
      {
      }

      DataLinkType::
      DataLinkType (const DataLinkType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        PointDataLink_ (x.PointDataLink_, f, this),
        MD5ChecksumPointData_ (x.MD5ChecksumPointData_, f, this),
        ValidPointsLink_ (x.ValidPointsLink_, f, this),
        MD5ChecksumValidPoints_ (x.MD5ChecksumValidPoints_, f, this)
      {
      }

      DataLinkType::
      DataLinkType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        PointDataLink_ (f, this),
        MD5ChecksumPointData_ (f, this),
        ValidPointsLink_ (f, this),
        MD5ChecksumValidPoints_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void DataLinkType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // PointDataLink
          //
          if (n.name () == L"PointDataLink" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< PointDataLink_type > r (
              PointDataLink_traits::create (i, f, this));

            if (!PointDataLink_.present ())
            {
              this->PointDataLink_.set (r);
              continue;
            }
          }

          // MD5ChecksumPointData
          //
          if (n.name () == L"MD5ChecksumPointData" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< MD5ChecksumPointData_type > r (
              MD5ChecksumPointData_traits::create (i, f, this));

            if (!MD5ChecksumPointData_.present ())
            {
              this->MD5ChecksumPointData_.set (r);
              continue;
            }
          }

          // ValidPointsLink
          //
          if (n.name () == L"ValidPointsLink" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< ValidPointsLink_type > r (
              ValidPointsLink_traits::create (i, f, this));

            if (!this->ValidPointsLink_)
            {
              this->ValidPointsLink_.set (r);
              continue;
            }
          }

          // MD5ChecksumValidPoints
          //
          if (n.name () == L"MD5ChecksumValidPoints" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< MD5ChecksumValidPoints_type > r (
              MD5ChecksumValidPoints_traits::create (i, f, this));

            if (!this->MD5ChecksumValidPoints_)
            {
              this->MD5ChecksumValidPoints_.set (r);
              continue;
            }
          }

          break;
        }

        if (!PointDataLink_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"PointDataLink",
            L"");
        }

        if (!MD5ChecksumPointData_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"MD5ChecksumPointData",
            L"");
        }
      }

      DataLinkType* DataLinkType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class DataLinkType (*this, f, c);
      }

      DataLinkType::
      ~DataLinkType ()
      {
      }

      bool
      operator== (const DataLinkType& x, const DataLinkType& y)
      {
        if (!(x.PointDataLink () == y.PointDataLink ()))
          return false;

        if (!(x.MD5ChecksumPointData () == y.MD5ChecksumPointData ()))
          return false;

        if (!(x.ValidPointsLink () == y.ValidPointsLink ()))
          return false;

        if (!(x.MD5ChecksumValidPoints () == y.MD5ChecksumValidPoints ()))
          return false;

        return true;
      }

      bool
      operator!= (const DataLinkType& x, const DataLinkType& y)
      {
        return !(x == y);
      }

      // MatrixDimensionType
      //

      MatrixDimensionType::
      MatrixDimensionType (const SizeX_type& SizeX,
                           const SizeY_type& SizeY,
                           const SizeZ_type& SizeZ)
      : ::xml_schema::type (),
        SizeX_ (SizeX, ::xml_schema::flags (), this),
        SizeY_ (SizeY, ::xml_schema::flags (), this),
        SizeZ_ (SizeZ, ::xml_schema::flags (), this)
      {
      }

      MatrixDimensionType::
      MatrixDimensionType (const MatrixDimensionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        SizeX_ (x.SizeX_, f, this),
        SizeY_ (x.SizeY_, f, this),
        SizeZ_ (x.SizeZ_, f, this)
      {
      }

      MatrixDimensionType::
      MatrixDimensionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        SizeX_ (f, this),
        SizeY_ (f, this),
        SizeZ_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void MatrixDimensionType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // SizeX
          //
          if (n.name () == L"SizeX" && n.namespace_ ().empty ())
          {
            if (!SizeX_.present ())
            {
              this->SizeX_.set (SizeX_traits::create (i, f, this));
              continue;
            }
          }

          // SizeY
          //
          if (n.name () == L"SizeY" && n.namespace_ ().empty ())
          {
            if (!SizeY_.present ())
            {
              this->SizeY_.set (SizeY_traits::create (i, f, this));
              continue;
            }
          }

          // SizeZ
          //
          if (n.name () == L"SizeZ" && n.namespace_ ().empty ())
          {
            if (!SizeZ_.present ())
            {
              this->SizeZ_.set (SizeZ_traits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!SizeX_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"SizeX",
            L"");
        }

        if (!SizeY_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"SizeY",
            L"");
        }

        if (!SizeZ_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"SizeZ",
            L"");
        }
      }

      MatrixDimensionType* MatrixDimensionType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class MatrixDimensionType (*this, f, c);
      }

      MatrixDimensionType::
      ~MatrixDimensionType ()
      {
      }

      bool
      operator== (const MatrixDimensionType& x, const MatrixDimensionType& y)
      {
        if (!(x.SizeX () == y.SizeX ()))
          return false;

        if (!(x.SizeY () == y.SizeY ()))
          return false;

        if (!(x.SizeZ () == y.SizeZ ()))
          return false;

        return true;
      }

      bool
      operator!= (const MatrixDimensionType& x, const MatrixDimensionType& y)
      {
        return !(x == y);
      }

      // RotationType
      //

      RotationType::
      RotationType (const r11_type& r11,
                    const r12_type& r12,
                    const r13_type& r13,
                    const r21_type& r21,
                    const r22_type& r22,
                    const r23_type& r23,
                    const r31_type& r31,
                    const r32_type& r32,
                    const r33_type& r33)
      : ::xml_schema::type (),
        r11_ (r11, ::xml_schema::flags (), this),
        r12_ (r12, ::xml_schema::flags (), this),
        r13_ (r13, ::xml_schema::flags (), this),
        r21_ (r21, ::xml_schema::flags (), this),
        r22_ (r22, ::xml_schema::flags (), this),
        r23_ (r23, ::xml_schema::flags (), this),
        r31_ (r31, ::xml_schema::flags (), this),
        r32_ (r32, ::xml_schema::flags (), this),
        r33_ (r33, ::xml_schema::flags (), this)
      {
      }

      RotationType::
      RotationType (const RotationType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (x, f, c),
        r11_ (x.r11_, f, this),
        r12_ (x.r12_, f, this),
        r13_ (x.r13_, f, this),
        r21_ (x.r21_, f, this),
        r22_ (x.r22_, f, this),
        r23_ (x.r23_, f, this),
        r31_ (x.r31_, f, this),
        r32_ (x.r32_, f, this),
        r33_ (x.r33_, f, this)
      {
      }

      RotationType::
      RotationType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        r11_ (f, this),
        r12_ (f, this),
        r13_ (f, this),
        r21_ (f, this),
        r22_ (f, this),
        r23_ (f, this),
        r31_ (f, this),
        r32_ (f, this),
        r33_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
          this->parse (p, f);
        }
      }

      void RotationType::
      parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< wchar_t > n (
            ::xsd::cxx::xml::dom::name< wchar_t > (i));

          // r11
          //
          if (n.name () == L"r11" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r11_type > r (
              r11_traits::create (i, f, this));

            if (!r11_.present ())
            {
              this->r11_.set (r);
              continue;
            }
          }

          // r12
          //
          if (n.name () == L"r12" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r12_type > r (
              r12_traits::create (i, f, this));

            if (!r12_.present ())
            {
              this->r12_.set (r);
              continue;
            }
          }

          // r13
          //
          if (n.name () == L"r13" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r13_type > r (
              r13_traits::create (i, f, this));

            if (!r13_.present ())
            {
              this->r13_.set (r);
              continue;
            }
          }

          // r21
          //
          if (n.name () == L"r21" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r21_type > r (
              r21_traits::create (i, f, this));

            if (!r21_.present ())
            {
              this->r21_.set (r);
              continue;
            }
          }

          // r22
          //
          if (n.name () == L"r22" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r22_type > r (
              r22_traits::create (i, f, this));

            if (!r22_.present ())
            {
              this->r22_.set (r);
              continue;
            }
          }

          // r23
          //
          if (n.name () == L"r23" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r23_type > r (
              r23_traits::create (i, f, this));

            if (!r23_.present ())
            {
              this->r23_.set (r);
              continue;
            }
          }

          // r31
          //
          if (n.name () == L"r31" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r31_type > r (
              r31_traits::create (i, f, this));

            if (!r31_.present ())
            {
              this->r31_.set (r);
              continue;
            }
          }

          // r32
          //
          if (n.name () == L"r32" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r32_type > r (
              r32_traits::create (i, f, this));

            if (!r32_.present ())
            {
              this->r32_.set (r);
              continue;
            }
          }

          // r33
          //
          if (n.name () == L"r33" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< r33_type > r (
              r33_traits::create (i, f, this));

            if (!r33_.present ())
            {
              this->r33_.set (r);
              continue;
            }
          }

          break;
        }

        if (!r11_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r11",
            L"");
        }

        if (!r12_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r12",
            L"");
        }

        if (!r13_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r13",
            L"");
        }

        if (!r21_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r21",
            L"");
        }

        if (!r22_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r22",
            L"");
        }

        if (!r23_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r23",
            L"");
        }

        if (!r31_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r31",
            L"");
        }

        if (!r32_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r32",
            L"");
        }

        if (!r33_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< wchar_t > (
            L"r33",
            L"");
        }
      }

      RotationType* RotationType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class RotationType (*this, f, c);
      }

      RotationType::
      ~RotationType ()
      {
      }

      bool
      operator== (const RotationType& x, const RotationType& y)
      {
        if (!(x.r11 () == y.r11 ()))
          return false;

        if (!(x.r12 () == y.r12 ()))
          return false;

        if (!(x.r13 () == y.r13 ()))
          return false;

        if (!(x.r21 () == y.r21 ()))
          return false;

        if (!(x.r22 () == y.r22 ()))
          return false;

        if (!(x.r23 () == y.r23 ()))
          return false;

        if (!(x.r31 () == y.r31 ()))
          return false;

        if (!(x.r32 () == y.r32 ()))
          return false;

        if (!(x.r33 () == y.r33 ()))
          return false;

        return true;
      }

      bool
      operator!= (const RotationType& x, const RotationType& y)
      {
        return !(x == y);
      }

      // RotationMatrixElementType
      //

      RotationMatrixElementType::
      RotationMatrixElementType (const ::xml_schema::double_& _xsd_double__base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
      {
      }

      RotationMatrixElementType::
      RotationMatrixElementType (const RotationMatrixElementType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
      {
      }

      RotationMatrixElementType::
      RotationMatrixElementType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
      {
      }

      RotationMatrixElementType::
      RotationMatrixElementType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
      {
      }

      RotationMatrixElementType::
      RotationMatrixElementType (const ::std::wstring& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
      {
      }

      RotationMatrixElementType* RotationMatrixElementType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class RotationMatrixElementType (*this, f, c);
      }

      RotationMatrixElementType::
      ~RotationMatrixElementType ()
      {
      }

      // FeatureType
      //

      FeatureType::
      FeatureType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::token (e, f, c)
      {
        _xsd_FeatureType_convert ();
      }

      FeatureType::
      FeatureType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::token (a, f, c)
      {
        _xsd_FeatureType_convert ();
      }

      FeatureType::
      FeatureType (const ::std::wstring& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
      : ::xml_schema::token (s, e, f, c)
      {
        _xsd_FeatureType_convert ();
      }

      FeatureType* FeatureType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class FeatureType (*this, f, c);
      }

      FeatureType::value FeatureType::
      _xsd_FeatureType_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_FeatureType_literals_);
        const value* i (::std::lower_bound (
                          _xsd_FeatureType_indexes_,
                          _xsd_FeatureType_indexes_ + 3,
                          *this,
                          c));

        if (i == _xsd_FeatureType_indexes_ + 3 || _xsd_FeatureType_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
        }

        return *i;
      }

      const wchar_t* const FeatureType::
      _xsd_FeatureType_literals_[3] =
      {
        L"PRF",
        L"SUR",
        L"PCL"
      };

      const FeatureType::value FeatureType::
      _xsd_FeatureType_indexes_[3] =
      {
        ::OpenGPS::Schemas::ISO5436_2::FeatureType::PCL,
        ::OpenGPS::Schemas::ISO5436_2::FeatureType::PRF,
        ::OpenGPS::Schemas::ISO5436_2::FeatureType::SUR
      };

      // AxisType
      //

      AxisType::
      AxisType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::token (e, f, c)
      {
        _xsd_AxisType_convert ();
      }

      AxisType::
      AxisType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::token (a, f, c)
      {
        _xsd_AxisType_convert ();
      }

      AxisType::
      AxisType (const ::std::wstring& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::token (s, e, f, c)
      {
        _xsd_AxisType_convert ();
      }

      AxisType* AxisType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class AxisType (*this, f, c);
      }

      AxisType::value AxisType::
      _xsd_AxisType_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AxisType_literals_);
        const value* i (::std::lower_bound (
                          _xsd_AxisType_indexes_,
                          _xsd_AxisType_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_AxisType_indexes_ + 2 || _xsd_AxisType_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
        }

        return *i;
      }

      const wchar_t* const AxisType::
      _xsd_AxisType_literals_[2] =
      {
        L"A",
        L"I"
      };

      const AxisType::value AxisType::
      _xsd_AxisType_indexes_[2] =
      {
        ::OpenGPS::Schemas::ISO5436_2::AxisType::A,
        ::OpenGPS::Schemas::ISO5436_2::AxisType::I
      };

      // DataType
      //

      DataType::
      DataType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::token (e, f, c)
      {
        _xsd_DataType_convert ();
      }

      DataType::
      DataType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::token (a, f, c)
      {
        _xsd_DataType_convert ();
      }

      DataType::
      DataType (const ::std::wstring& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
      : ::xml_schema::token (s, e, f, c)
      {
        _xsd_DataType_convert ();
      }

      DataType* DataType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class DataType (*this, f, c);
      }

      DataType::value DataType::
      _xsd_DataType_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DataType_literals_);
        const value* i (::std::lower_bound (
                          _xsd_DataType_indexes_,
                          _xsd_DataType_indexes_ + 4,
                          *this,
                          c));

        if (i == _xsd_DataType_indexes_ + 4 || _xsd_DataType_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
        }

        return *i;
      }

      const wchar_t* const DataType::
      _xsd_DataType_literals_[4] =
      {
        L"I",
        L"L",
        L"F",
        L"D"
      };

      const DataType::value DataType::
      _xsd_DataType_indexes_[4] =
      {
        ::OpenGPS::Schemas::ISO5436_2::DataType::D,
        ::OpenGPS::Schemas::ISO5436_2::DataType::F,
        ::OpenGPS::Schemas::ISO5436_2::DataType::I,
        ::OpenGPS::Schemas::ISO5436_2::DataType::L
      };

      // Type
      //

      Type::
      Type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
      : ::xml_schema::token (e, f, c)
      {
        _xsd_Type_convert ();
      }

      Type::
      Type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
      : ::xml_schema::token (a, f, c)
      {
        _xsd_Type_convert ();
      }

      Type::
      Type (const ::std::wstring& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
      : ::xml_schema::token (s, e, f, c)
      {
        _xsd_Type_convert ();
      }

      Type* Type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class Type (*this, f, c);
      }

      Type::value Type::
      _xsd_Type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_Type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_Type_indexes_,
                          _xsd_Type_indexes_ + 3,
                          *this,
                          c));

        if (i == _xsd_Type_indexes_ + 3 || _xsd_Type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
        }

        return *i;
      }

      const wchar_t* const Type::
      _xsd_Type_literals_[3] =
      {
        L"Contacting",
        L"NonContacting",
        L"Software"
      };

      const Type::value Type::
      _xsd_Type_indexes_[3] =
      {
        ::OpenGPS::Schemas::ISO5436_2::Type::Contacting,
        ::OpenGPS::Schemas::ISO5436_2::Type::NonContacting,
        ::OpenGPS::Schemas::ISO5436_2::Type::Software
      };

      // Datum
      //

      Datum::
      Datum ()
      : ::xml_schema::token ()
      {
      }

      Datum::
      Datum (const wchar_t* _xsd_token_base)
      : ::xml_schema::token (_xsd_token_base)
      {
      }

      Datum::
      Datum (const ::std::wstring& _xsd_token_base)
      : ::xml_schema::token (_xsd_token_base)
      {
      }

      Datum::
      Datum (const ::xml_schema::token& _xsd_token_base)
      : ::xml_schema::token (_xsd_token_base)
      {
      }

      Datum::
      Datum (const Datum& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
      : ::xml_schema::token (x, f, c)
      {
      }

      Datum::
      Datum (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
      : ::xml_schema::token (e, f, c)
      {
      }

      Datum::
      Datum (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
      : ::xml_schema::token (a, f, c)
      {
      }

      Datum::
      Datum (const ::std::wstring& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
      : ::xml_schema::token (s, e, f, c)
      {
      }

      Datum* Datum::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class Datum (*this, f, c);
      }

      Datum::
      ~Datum ()
      {
      }
    }
  }
}

#include <ostream>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      ::std::wostream&
      operator<< (::std::wostream& o, const Record1Type& i)
      {
        o << ::std::endl << L"Revision: " << i.Revision ();
        o << ::std::endl << L"FeatureType: " << i.FeatureType ();
        o << ::std::endl << L"Axes: " << i.Axes ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const ISO5436_2Type& i)
      {
        o << ::std::endl << L"Record1: " << i.Record1 ();
        if (i.Record2 ())
        {
          o << ::std::endl << L"Record2: " << *i.Record2 ();
        }

        o << ::std::endl << L"Record3: " << i.Record3 ();
        o << ::std::endl << L"Record4: " << i.Record4 ();
        if (i.VendorSpecificID ())
        {
          o << ::std::endl << L"VendorSpecificID: " << *i.VendorSpecificID ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Record2Type& i)
      {
        o << ::std::endl << L"Date: " << i.Date ();
        if (i.Creator ())
        {
          o << ::std::endl << L"Creator: " << *i.Creator ();
        }

        o << ::std::endl << L"Instrument: " << i.Instrument ();
        o << ::std::endl << L"CalibrationDate: " << i.CalibrationDate ();
        o << ::std::endl << L"ProbingSystem: " << i.ProbingSystem ();
        if (i.Comment ())
        {
          o << ::std::endl << L"Comment: " << *i.Comment ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Record3Type& i)
      {
        if (i.MatrixDimension ())
        {
          o << ::std::endl << L"MatrixDimension: " << *i.MatrixDimension ();
        }

        if (i.ListDimension ())
        {
          o << ::std::endl << L"ListDimension: " << *i.ListDimension ();
        }

        if (i.DataLink ())
        {
          o << ::std::endl << L"DataLink: " << *i.DataLink ();
        }

        if (i.DataList ())
        {
          o << ::std::endl << L"DataList: " << *i.DataList ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Record4Type& i)
      {
        o << ::std::endl << L"ChecksumFile: " << i.ChecksumFile ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const AxesType& i)
      {
        o << ::std::endl << L"CX: " << i.CX ();
        o << ::std::endl << L"CY: " << i.CY ();
        o << ::std::endl << L"CZ: " << i.CZ ();
        if (i.Rotation ())
        {
          o << ::std::endl << L"Rotation: " << *i.Rotation ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const AxisDescriptionType& i)
      {
        o << ::std::endl << L"AxisType: " << i.AxisType ();
        if (i.DataType ())
        {
          o << ::std::endl << L"DataType: " << *i.DataType ();
        }

        if (i.Increment ())
        {
          o << ::std::endl << L"Increment: " << *i.Increment ();
        }

        if (i.Offset ())
        {
          o << ::std::endl << L"Offset: " << *i.Offset ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const InstrumentType& i)
      {
        o << ::std::endl << L"Manufacturer: " << i.Manufacturer ();
        o << ::std::endl << L"Model: " << i.Model ();
        o << ::std::endl << L"Serial: " << i.Serial ();
        o << ::std::endl << L"Version: " << i.Version ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const ProbingSystemType& i)
      {
        o << ::std::endl << L"Type: " << i.Type ();
        o << ::std::endl << L"Identification: " << i.Identification ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const DataListType& i)
      {
        for (DataListType::Datum_const_iterator
             b (i.Datum ().begin ()), e (i.Datum ().end ());
             b != e; ++b)
        {
          o << ::std::endl << L"Datum: " << *b;
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const DataLinkType& i)
      {
        o << ::std::endl << L"PointDataLink: " << i.PointDataLink ();
        o << ::std::endl << L"MD5ChecksumPointData: " << i.MD5ChecksumPointData ();
        if (i.ValidPointsLink ())
        {
          o << ::std::endl << L"ValidPointsLink: " << *i.ValidPointsLink ();
        }

        if (i.MD5ChecksumValidPoints ())
        {
          o << ::std::endl << L"MD5ChecksumValidPoints: " << *i.MD5ChecksumValidPoints ();
        }

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const MatrixDimensionType& i)
      {
        o << ::std::endl << L"SizeX: " << i.SizeX ();
        o << ::std::endl << L"SizeY: " << i.SizeY ();
        o << ::std::endl << L"SizeZ: " << i.SizeZ ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const RotationType& i)
      {
        o << ::std::endl << L"r11: " << i.r11 ();
        o << ::std::endl << L"r12: " << i.r12 ();
        o << ::std::endl << L"r13: " << i.r13 ();
        o << ::std::endl << L"r21: " << i.r21 ();
        o << ::std::endl << L"r22: " << i.r22 ();
        o << ::std::endl << L"r23: " << i.r23 ();
        o << ::std::endl << L"r31: " << i.r31 ();
        o << ::std::endl << L"r32: " << i.r32 ();
        o << ::std::endl << L"r33: " << i.r33 ();
        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const RotationMatrixElementType& i)
      {
        o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

        return o;
      }

      ::std::wostream&
      operator<< (::std::wostream& o, FeatureType::value i)
      {
        return o << FeatureType::_xsd_FeatureType_literals_[i];
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const FeatureType& i)
      {
        return o << static_cast< const ::xml_schema::token& > (i);
      }

      ::std::wostream&
      operator<< (::std::wostream& o, AxisType::value i)
      {
        return o << AxisType::_xsd_AxisType_literals_[i];
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const AxisType& i)
      {
        return o << static_cast< const ::xml_schema::token& > (i);
      }

      ::std::wostream&
      operator<< (::std::wostream& o, DataType::value i)
      {
        return o << DataType::_xsd_DataType_literals_[i];
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const DataType& i)
      {
        return o << static_cast< const ::xml_schema::token& > (i);
      }

      ::std::wostream&
      operator<< (::std::wostream& o, Type::value i)
      {
        return o << Type::_xsd_Type_literals_[i];
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Type& i)
      {
        return o << static_cast< const ::xml_schema::token& > (i);
      }

      ::std::wostream&
      operator<< (::std::wostream& o, const Datum& i)
      {
        o << static_cast< const ::xml_schema::token& > (i);

        return o;
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::std::wstring& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< wchar_t > h;

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::std::wstring& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< wchar_t > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::std::wstring& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< wchar_t > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (isrc, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (isrc, h, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (isrc, h, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (isrc, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (isrc, h, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (isrc, h, f, p);
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xsd::cxx::tree::error_handler< wchar_t > h;

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< wchar_t > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< wchar_t > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< wchar_t > ();

        ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
            d, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
      {
        if (f & ::xml_schema::flags::keep_dom)
        {
          ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
            static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

          ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
            ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (
              c, f | ::xml_schema::flags::own_dom, p));

          return r;
        }

        const ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (e));

        if (n.name () == L"ISO5436_2" &&
            n.namespace_ () == L"http://www.opengps.eu/2008/ISO5436_2")
        {
          ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
            ::xsd::cxx::tree::traits< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type, wchar_t >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
          n.name (),
          n.namespace_ (),
          L"ISO5436_2",
          L"http://www.opengps.eu/2008/ISO5436_2");
      }

      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          ((f & ::xml_schema::flags::keep_dom) &&
           !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (e));

        if (f & ::xml_schema::flags::keep_dom)
          doc.setUserData (::xml_schema::dom::tree_node_key,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == L"ISO5436_2" &&
            n.namespace_ () == L"http://www.opengps.eu/2008/ISO5436_2")
        {
          ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type > r (
            ::xsd::cxx::tree::traits< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type, wchar_t >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
          n.name (),
          n.namespace_ (),
          L"ISO5436_2",
          L"http://www.opengps.eu/2008/ISO5436_2");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      void
      ISO5436_2 (::std::ostream& o,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));

        ::xsd::cxx::tree::error_handler< wchar_t > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
        }
      }

      void
      ISO5436_2 (::std::ostream& o,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< wchar_t > ();
        }
      }

      void
      ISO5436_2 (::std::ostream& o,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< wchar_t > ();
        }
      }

      void
      ISO5436_2 (::xercesc::XMLFormatTarget& t,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));

        ::xsd::cxx::tree::error_handler< wchar_t > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
        }
      }

      void
      ISO5436_2 (::xercesc::XMLFormatTarget& t,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< wchar_t > ();
        }
      }

      void
      ISO5436_2 (::xercesc::XMLFormatTarget& t,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< wchar_t > ();
        }
      }

      void
      ISO5436_2 (::xercesc::DOMDocument& d,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 ::xml_schema::flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (e));

        if (n.name () == L"ISO5436_2" &&
            n.namespace_ () == L"http://www.opengps.eu/2008/ISO5436_2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ISO5436_2",
            L"http://www.opengps.eu/2008/ISO5436_2");
        }
      }

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
      ISO5436_2 (const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ISO5436_2",
            L"http://www.opengps.eu/2008/ISO5436_2",
            m, f));

        ::OpenGPS::Schemas::ISO5436_2::ISO5436_2 (*d, s, f);
        return d;
      }

      void
      operator<< (::xercesc::DOMElement& e, const Record1Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Revision
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Revision",
              e));

          s << i.Revision ();
        }

        // FeatureType
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"FeatureType",
              e));

          s << i.FeatureType ();
        }

        // Axes
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Axes",
              e));

          s << i.Axes ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ISO5436_2Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Record1
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Record1",
              e));

          s << i.Record1 ();
        }

        // Record2
        //
        if (i.Record2 ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Record2",
              e));

          s << *i.Record2 ();
        }

        // Record3
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Record3",
              e));

          s << i.Record3 ();
        }

        // Record4
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Record4",
              e));

          s << i.Record4 ();
        }

        // VendorSpecificID
        //
        if (i.VendorSpecificID ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"VendorSpecificID",
              e));

          s << *i.VendorSpecificID ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Record2Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Date
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Date",
              e));

          s << i.Date ();
        }

        // Creator
        //
        if (i.Creator ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Creator",
              e));

          s << *i.Creator ();
        }

        // Instrument
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Instrument",
              e));

          s << i.Instrument ();
        }

        // CalibrationDate
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CalibrationDate",
              e));

          s << i.CalibrationDate ();
        }

        // ProbingSystem
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ProbingSystem",
              e));

          s << i.ProbingSystem ();
        }

        // Comment
        //
        if (i.Comment ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Comment",
              e));

          s << *i.Comment ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Record3Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // MatrixDimension
        //
        if (i.MatrixDimension ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"MatrixDimension",
              e));

          s << *i.MatrixDimension ();
        }

        // ListDimension
        //
        if (i.ListDimension ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ListDimension",
              e));

          s << *i.ListDimension ();
        }

        // DataLink
        //
        if (i.DataLink ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"DataLink",
              e));

          s << *i.DataLink ();
        }

        // DataList
        //
        if (i.DataList ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"DataList",
              e));

          s << *i.DataList ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Record4Type& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // ChecksumFile
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ChecksumFile",
              e));

          s << i.ChecksumFile ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const AxesType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // CX
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CX",
              e));

          s << i.CX ();
        }

        // CY
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CY",
              e));

          s << i.CY ();
        }

        // CZ
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CZ",
              e));

          s << i.CZ ();
        }

        // Rotation
        //
        if (i.Rotation ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Rotation",
              e));

          s << *i.Rotation ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const AxisDescriptionType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // AxisType
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"AxisType",
              e));

          s << i.AxisType ();
        }

        // DataType
        //
        if (i.DataType ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"DataType",
              e));

          s << *i.DataType ();
        }

        // Increment
        //
        if (i.Increment ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Increment",
              e));

          s << ::xml_schema::as_double(*i.Increment ());
        }

        // Offset
        //
        if (i.Offset ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Offset",
              e));

          s << ::xml_schema::as_double(*i.Offset ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const InstrumentType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Manufacturer
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Manufacturer",
              e));

          s << i.Manufacturer ();
        }

        // Model
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Model",
              e));

          s << i.Model ();
        }

        // Serial
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Serial",
              e));

          s << i.Serial ();
        }

        // Version
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Version",
              e));

          s << i.Version ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ProbingSystemType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Type
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Type",
              e));

          s << i.Type ();
        }

        // Identification
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Identification",
              e));

          s << i.Identification ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const DataListType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // Datum
        //
        for (DataListType::Datum_const_iterator
             b (i.Datum ().begin ()), n (i.Datum ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Datum",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const DataLinkType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // PointDataLink
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"PointDataLink",
              e));

          s << i.PointDataLink ();
        }

        // MD5ChecksumPointData
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"MD5ChecksumPointData",
              e));

          s << i.MD5ChecksumPointData ();
        }

        // ValidPointsLink
        //
        if (i.ValidPointsLink ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ValidPointsLink",
              e));

          s << *i.ValidPointsLink ();
        }

        // MD5ChecksumValidPoints
        //
        if (i.MD5ChecksumValidPoints ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"MD5ChecksumValidPoints",
              e));

          s << *i.MD5ChecksumValidPoints ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const MatrixDimensionType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // SizeX
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"SizeX",
              e));

          s << i.SizeX ();
        }

        // SizeY
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"SizeY",
              e));

          s << i.SizeY ();
        }

        // SizeZ
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"SizeZ",
              e));

          s << i.SizeZ ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const RotationType& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // r11
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r11",
              e));

          s << i.r11 ();
        }

        // r12
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r12",
              e));

          s << i.r12 ();
        }

        // r13
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r13",
              e));

          s << i.r13 ();
        }

        // r21
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r21",
              e));

          s << i.r21 ();
        }

        // r22
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r22",
              e));

          s << i.r22 ();
        }

        // r23
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r23",
              e));

          s << i.r23 ();
        }

        // r31
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r31",
              e));

          s << i.r31 ();
        }

        // r32
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r32",
              e));

          s << i.r32 ();
        }

        // r33
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"r33",
              e));

          s << i.r33 ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const RotationMatrixElementType& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const RotationMatrixElementType& i)
      {
        a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const RotationMatrixElementType& i)
      {
        l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const FeatureType& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const FeatureType& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const FeatureType& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const AxisType& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const AxisType& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const AxisType& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const DataType& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const DataType& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const DataType& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const Type& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const Type& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const Type& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const Datum& i)
      {
        e << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const Datum& i)
      {
        a << static_cast< const ::xml_schema::token& > (i);
      }

      void
      operator<< (::xml_schema::list_stream& l,
                  const Datum& i)
      {
        l << static_cast< const ::xml_schema::token& > (i);
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

