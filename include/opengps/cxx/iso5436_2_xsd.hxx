// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from iso5436_2.xsd.
 */

#ifndef CXX_USERS_MBRUBAKE_PROJECTS_CADRE_X3P_OPEN_GPS_CODE_382_ISO5436_XML_BRANCHES_KOHLER_LINUX_PORT_SRC_ISO5436_2_XML_ISO5436_2_XSD_HXX
#define CXX_USERS_MBRUBAKE_PROJECTS_CADRE_X3P_OPEN_GPS_CODE_382_ISO5436_XML_BRANCHES_KOHLER_LINUX_PORT_SRC_ISO5436_2_XML_ISO5436_2_XSD_HXX

// Begin prologue.
//
/***************************************************************************
 *   Copyright by                                                          *
 *   Georg Wiora (NanoFocus AG) 2007                                       *
 *   Joerg Seewig (Uni Hannover),                                           *
 *   Andreas Walther (NanoFocus AG),                                       *
 *   Mark A. Weber (NanoFocus AG) 2007                                     *
 *   Johannes Herwig (Uni Duisburg-Essen) 2007                             *
 *                                                                         *
 *   This file is part of the openGPS (R)[TM] software library.            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License (LGPL)    *
 *   as published by the Free Software Foundation; either version 3 of     *
 *   the License, or (at your option) any later version.                   *
 *   for detail see the files "licence_LGPL-3.0.txt" and                   *
 *   "licence_GPL-3.0.txt".                                                *
 *                                                                         *
 *   openGPS is distributed in the hope that it will be useful,            *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU Lesser General Public License for more details.                   *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 *                                                                         *
 *   The name "openGPS" and the logo are registered as                     *
 *   European trade mark No. 006178354 for                                 *
 *   Physikalisch Technische Bundesanstalt (PTB)                           *
 *   http://www.ptb.de/                                                    *
 *                                                                         *
 *   More information about openGPS can be found at                        *
 *   http://www.opengps.eu/                                                *
 ***************************************************************************/

#include <opengps/opengps.h>
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;


  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< wchar_t > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      class Record1Type;
      class ISO5436_2Type;
      class Record2Type;
      class Record3Type;
      class Record4Type;
      class AxesType;
      class AxisDescriptionType;
      class InstrumentType;
      class ProbingSystemType;
      class DataListType;
      class DataLinkType;
      class MatrixDimensionType;
      class RotationType;
      class RotationMatrixElementType;
      class FeatureType;
      class AxisType;
      class DataType;
      class Type;
      class Datum;
    }
  }
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace OpenGPS
{
  namespace Schemas
  {
    /**
     * @brief C++ namespace for the %http://www.opengps.eu/2008/ISO5436_2
     * schema namespace.
     */
    namespace ISO5436_2
    {
      /**
       * @brief Class corresponding to the %Record1Type schema type.
       *
       * Record1 contains the axis description
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT Record1Type: public ::xml_schema::type
      {
        public:
        /**
         * @name Revision
         *
         * @brief Accessor and modifier functions for the %Revision
         * required element.
         *
         * Revision of file format. Currently: ISO5436 -
         * 2000
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::token Revision_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Revision_type, wchar_t > Revision_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Revision_type&
        Revision () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Revision_type&
        Revision ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Revision (const Revision_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Revision (::std::auto_ptr< Revision_type > p);

        //@}

        /**
         * @name FeatureType
         *
         * @brief Accessor and modifier functions for the %FeatureType
         * required element.
         *
         * "SUR" for surface type feature, "PRF" for
         * profile type feature or "PCL" for unordered point clouds. Profile
         * features are
         * allways defined as a matrix of size (N,1,M) with
         * N beeing the number of points in the profile and
         * M the number of layers in z-direction.
         * Point clouds have to be stored as list type.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::FeatureType FeatureType_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< FeatureType_type, wchar_t > FeatureType_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const FeatureType_type&
        FeatureType () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        FeatureType_type&
        FeatureType ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        FeatureType (const FeatureType_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        FeatureType (::std::auto_ptr< FeatureType_type > p);

        //@}

        /**
         * @name Axes
         *
         * @brief Accessor and modifier functions for the %Axes
         * required element.
         *
         * Axis description
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::AxesType Axes_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Axes_type, wchar_t > Axes_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Axes_type&
        Axes () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Axes_type&
        Axes ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Axes (const Axes_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Axes (::std::auto_ptr< Axes_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        Record1Type (const Revision_type&,
                     const FeatureType_type&,
                     const Axes_type&);

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes
         * (auto_ptr version).
         *
         * This constructor will try to use the passed values directly
         * instead of making copies.
         */
        Record1Type (const Revision_type&,
                     const FeatureType_type&,
                     ::std::auto_ptr< Axes_type >&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Record1Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        Record1Type (const Record1Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual Record1Type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~Record1Type ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< Revision_type > Revision_;
        ::xsd::cxx::tree::one< FeatureType_type > FeatureType_;
        ::xsd::cxx::tree::one< Axes_type > Axes_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const Record1Type&, const Record1Type&);

      _OPENGPS_EXPORT
      bool
      operator!= (const Record1Type&, const Record1Type&);


      /**
       * @brief Class corresponding to the %ISO5436_2Type schema type.
       *
       * This is the top tag of a data file
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT ISO5436_2Type: public ::xml_schema::type
      {
        public:
        /**
         * @name Record1
         *
         * @brief Accessor and modifier functions for the %Record1
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::Record1Type Record1_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Record1_type, wchar_t > Record1_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Record1_type&
        Record1 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Record1_type&
        Record1 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Record1 (const Record1_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Record1 (::std::auto_ptr< Record1_type > p);

        //@}

        /**
         * @name Record2
         *
         * @brief Accessor and modifier functions for the %Record2
         * optional element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::Record2Type Record2_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< Record2_type > Record2_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Record2_type, wchar_t > Record2_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const Record2_optional&
        Record2 () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        Record2_optional&
        Record2 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Record2 (const Record2_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        Record2 (const Record2_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        Record2 (::std::auto_ptr< Record2_type > p);

        //@}

        /**
         * @name Record3
         *
         * @brief Accessor and modifier functions for the %Record3
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::Record3Type Record3_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Record3_type, wchar_t > Record3_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Record3_type&
        Record3 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Record3_type&
        Record3 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Record3 (const Record3_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Record3 (::std::auto_ptr< Record3_type > p);

        //@}

        /**
         * @name Record4
         *
         * @brief Accessor and modifier functions for the %Record4
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::Record4Type Record4_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Record4_type, wchar_t > Record4_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Record4_type&
        Record4 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Record4_type&
        Record4 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Record4 (const Record4_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Record4 (::std::auto_ptr< Record4_type > p);

        //@}

        /**
         * @name VendorSpecificID
         *
         * @brief Accessor and modifier functions for the %VendorSpecificID
         * optional element.
         *
         * This is an extension hook for vendor specific data formats derived
         * from ISO5436_2_XML
         * This tag contains a vendor specific ID which is the URL of the vendor.
         * It does not need to be valid
         * but it must be worldwide unique!
         * Example: http://www.example-inc.com/myformat
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::uri VendorSpecificID_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< VendorSpecificID_type > VendorSpecificID_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< VendorSpecificID_type, wchar_t > VendorSpecificID_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const VendorSpecificID_optional&
        VendorSpecificID () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        VendorSpecificID_optional&
        VendorSpecificID ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        VendorSpecificID (const VendorSpecificID_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        VendorSpecificID (const VendorSpecificID_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        VendorSpecificID (::std::auto_ptr< VendorSpecificID_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        ISO5436_2Type (const Record1_type&,
                       const Record3_type&,
                       const Record4_type&);

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes
         * (auto_ptr version).
         *
         * This constructor will try to use the passed values directly
         * instead of making copies.
         */
        ISO5436_2Type (::std::auto_ptr< Record1_type >&,
                       ::std::auto_ptr< Record3_type >&,
                       ::std::auto_ptr< Record4_type >&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        ISO5436_2Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        ISO5436_2Type (const ISO5436_2Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual ISO5436_2Type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~ISO5436_2Type ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< Record1_type > Record1_;
        Record2_optional Record2_;
        ::xsd::cxx::tree::one< Record3_type > Record3_;
        ::xsd::cxx::tree::one< Record4_type > Record4_;
        VendorSpecificID_optional VendorSpecificID_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const ISO5436_2Type&, const ISO5436_2Type&);

      _OPENGPS_EXPORT
      bool
      operator!= (const ISO5436_2Type&, const ISO5436_2Type&);


      /**
       * @brief Class corresponding to the %Record2Type schema type.
       *
       * Record2 is optional and contains the metadata of the
       * data set.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT Record2Type: public ::xml_schema::type
      {
        public:
        /**
         * @name Date
         *
         * @brief Accessor and modifier functions for the %Date
         * required element.
         *
         * Date and time of file creation.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::date_time Date_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Date_type, wchar_t > Date_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Date_type&
        Date () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Date_type&
        Date ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Date (const Date_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Date (::std::auto_ptr< Date_type > p);

        //@}

        /**
         * @name Creator
         *
         * @brief Accessor and modifier functions for the %Creator
         * optional element.
         *
         * Optional name of the creator of the file: Name
         * of the measuring person.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::token Creator_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< Creator_type > Creator_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Creator_type, wchar_t > Creator_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const Creator_optional&
        Creator () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        Creator_optional&
        Creator ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Creator (const Creator_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        Creator (const Creator_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        Creator (::std::auto_ptr< Creator_type > p);

        //@}

        /**
         * @name Instrument
         *
         * @brief Accessor and modifier functions for the %Instrument
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::InstrumentType Instrument_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Instrument_type, wchar_t > Instrument_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Instrument_type&
        Instrument () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Instrument_type&
        Instrument ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Instrument (const Instrument_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Instrument (::std::auto_ptr< Instrument_type > p);

        //@}

        /**
         * @name CalibrationDate
         *
         * @brief Accessor and modifier functions for the %CalibrationDate
         * required element.
         *
         * Date of currently used calibration
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::date_time CalibrationDate_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< CalibrationDate_type, wchar_t > CalibrationDate_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const CalibrationDate_type&
        CalibrationDate () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        CalibrationDate_type&
        CalibrationDate ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        CalibrationDate (const CalibrationDate_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        CalibrationDate (::std::auto_ptr< CalibrationDate_type > p);

        //@}

        /**
         * @name ProbingSystem
         *
         * @brief Accessor and modifier functions for the %ProbingSystem
         * required element.
         *
         * Type of probing system: This can be contacting, non contacting or
         * software
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::ProbingSystemType ProbingSystem_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< ProbingSystem_type, wchar_t > ProbingSystem_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const ProbingSystem_type&
        ProbingSystem () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        ProbingSystem_type&
        ProbingSystem ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        ProbingSystem (const ProbingSystem_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        ProbingSystem (::std::auto_ptr< ProbingSystem_type > p);

        //@}

        /**
         * @name Comment
         *
         * @brief Accessor and modifier functions for the %Comment
         * optional element.
         *
         * User comment to this data set
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::string Comment_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< Comment_type > Comment_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Comment_type, wchar_t > Comment_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const Comment_optional&
        Comment () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        Comment_optional&
        Comment ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Comment (const Comment_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        Comment (const Comment_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        Comment (::std::auto_ptr< Comment_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        Record2Type (const Date_type&,
                     const Instrument_type&,
                     const CalibrationDate_type&,
                     const ProbingSystem_type&);

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes
         * (auto_ptr version).
         *
         * This constructor will try to use the passed values directly
         * instead of making copies.
         */
        Record2Type (const Date_type&,
                     ::std::auto_ptr< Instrument_type >&,
                     const CalibrationDate_type&,
                     ::std::auto_ptr< ProbingSystem_type >&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Record2Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        Record2Type (const Record2Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual Record2Type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~Record2Type ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< Date_type > Date_;
        Creator_optional Creator_;
        ::xsd::cxx::tree::one< Instrument_type > Instrument_;
        ::xsd::cxx::tree::one< CalibrationDate_type > CalibrationDate_;
        ::xsd::cxx::tree::one< ProbingSystem_type > ProbingSystem_;
        Comment_optional Comment_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const Record2Type&, const Record2Type&);

      _OPENGPS_EXPORT
      bool
      operator!= (const Record2Type&, const Record2Type&);


      /**
       * @brief Class corresponding to the %Record3Type schema type.
       *
       * Record 3 contains the measured data.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT Record3Type: public ::xml_schema::type
      {
        public:
        /**
         * @name MatrixDimension
         *
         * @brief Accessor and modifier functions for the %MatrixDimension
         * optional element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::MatrixDimensionType MatrixDimension_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< MatrixDimension_type > MatrixDimension_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< MatrixDimension_type, wchar_t > MatrixDimension_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const MatrixDimension_optional&
        MatrixDimension () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        MatrixDimension_optional&
        MatrixDimension ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        MatrixDimension (const MatrixDimension_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        MatrixDimension (const MatrixDimension_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        MatrixDimension (::std::auto_ptr< MatrixDimension_type > p);

        //@}

        /**
         * @name ListDimension
         *
         * @brief Accessor and modifier functions for the %ListDimension
         * optional element.
         *
         * A list does specify an unordered data set
         * like a point cloud which does not contain
         * topologic information.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::unsigned_long ListDimension_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< ListDimension_type > ListDimension_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< ListDimension_type, wchar_t > ListDimension_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const ListDimension_optional&
        ListDimension () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        ListDimension_optional&
        ListDimension ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        ListDimension (const ListDimension_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        ListDimension (const ListDimension_optional& x);

        //@}

        /**
         * @name DataLink
         *
         * @brief Accessor and modifier functions for the %DataLink
         * optional element.
         *
         * Link specification to an external binary
         * data file.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::DataLinkType DataLink_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< DataLink_type > DataLink_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< DataLink_type, wchar_t > DataLink_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const DataLink_optional&
        DataLink () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        DataLink_optional&
        DataLink ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        DataLink (const DataLink_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        DataLink (const DataLink_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        DataLink (::std::auto_ptr< DataLink_type > p);

        //@}

        /**
         * @name DataList
         *
         * @brief Accessor and modifier functions for the %DataList
         * optional element.
         *
         * Data list is ordered like specified in
         * DataOrder: Z-Index is empty (only one sample
         * per pixel) X is fastest index, Y is slower,
         * Z is slowest:
         * (x1,y1),(x2,y1),(x3,y1),(x4,y1),(x1,y2)...
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::DataListType DataList_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< DataList_type > DataList_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< DataList_type, wchar_t > DataList_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const DataList_optional&
        DataList () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        DataList_optional&
        DataList ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        DataList (const DataList_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        DataList (const DataList_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        DataList (::std::auto_ptr< DataList_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        Record3Type ();

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Record3Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        Record3Type (const Record3Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual Record3Type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~Record3Type ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        MatrixDimension_optional MatrixDimension_;
        ListDimension_optional ListDimension_;
        DataLink_optional DataLink_;
        DataList_optional DataList_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const Record3Type&, const Record3Type&);

      _OPENGPS_EXPORT
      bool
      operator!= (const Record3Type&, const Record3Type&);


      /**
       * @brief Class corresponding to the %Record4Type schema type.
       *
       * Record4 contains only the checksum of the xml file.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT Record4Type: public ::xml_schema::type
      {
        public:
        /**
         * @name ChecksumFile
         *
         * @brief Accessor and modifier functions for the %ChecksumFile
         * required element.
         *
         * An URI pointing to an external ascii file
         * containting an MD5 digest with a 32 byte
         * hexadecimal MD5Checksum of the whole XML-file
         * and its filename as produced by the unix command
         * "md5sum". The checksum can be calculated by the
         * unix command "md5sum main.xml >md5checksum.hex"
         * and checked by the command "md5sum -c
         * md5checksum.hex". Default name of the checksum
         * file is "md5checksum.hex".
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::string ChecksumFile_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< ChecksumFile_type, wchar_t > ChecksumFile_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const ChecksumFile_type&
        ChecksumFile () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        ChecksumFile_type&
        ChecksumFile ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        ChecksumFile (const ChecksumFile_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        ChecksumFile (::std::auto_ptr< ChecksumFile_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        Record4Type (const ChecksumFile_type&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Record4Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        Record4Type (const Record4Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual Record4Type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~Record4Type ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< ChecksumFile_type > ChecksumFile_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const Record4Type&, const Record4Type&);

      _OPENGPS_EXPORT
      bool
      operator!= (const Record4Type&, const Record4Type&);


      /**
       * @brief Class corresponding to the %AxesType schema type.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT AxesType: public ::xml_schema::type
      {
        public:
        /**
         * @name CX
         *
         * @brief Accessor and modifier functions for the %CX
         * required element.
         *
         * Description of X-Axis
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::AxisDescriptionType CX_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< CX_type, wchar_t > CX_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const CX_type&
        CX () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        CX_type&
        CX ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        CX (const CX_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        CX (::std::auto_ptr< CX_type > p);

        //@}

        /**
         * @name CY
         *
         * @brief Accessor and modifier functions for the %CY
         * required element.
         *
         * Description of Y-Axis
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::AxisDescriptionType CY_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< CY_type, wchar_t > CY_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const CY_type&
        CY () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        CY_type&
        CY ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        CY (const CY_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        CY (::std::auto_ptr< CY_type > p);

        //@}

        /**
         * @name CZ
         *
         * @brief Accessor and modifier functions for the %CZ
         * required element.
         *
         * Description of Z-Axis
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::AxisDescriptionType CZ_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< CZ_type, wchar_t > CZ_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const CZ_type&
        CZ () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        CZ_type&
        CZ ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        CZ (const CZ_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        CZ (::std::auto_ptr< CZ_type > p);

        //@}

        /**
         * @name Rotation
         *
         * @brief Accessor and modifier functions for the %Rotation
         * optional element.
         *
         * An optional rotation of the data points. If this
         * element is missing a unit transformation is
         * assumed.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationType Rotation_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< Rotation_type > Rotation_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Rotation_type, wchar_t > Rotation_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const Rotation_optional&
        Rotation () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        Rotation_optional&
        Rotation ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Rotation (const Rotation_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        Rotation (const Rotation_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        Rotation (::std::auto_ptr< Rotation_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        AxesType (const CX_type&,
                  const CY_type&,
                  const CZ_type&);

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes
         * (auto_ptr version).
         *
         * This constructor will try to use the passed values directly
         * instead of making copies.
         */
        AxesType (::std::auto_ptr< CX_type >&,
                  ::std::auto_ptr< CY_type >&,
                  ::std::auto_ptr< CZ_type >&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        AxesType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        AxesType (const AxesType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual AxesType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~AxesType ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< CX_type > CX_;
        ::xsd::cxx::tree::one< CY_type > CY_;
        ::xsd::cxx::tree::one< CZ_type > CZ_;
        Rotation_optional Rotation_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const AxesType&, const AxesType&);

      _OPENGPS_EXPORT
      bool
      operator!= (const AxesType&, const AxesType&);


      /**
       * @brief Class corresponding to the %AxisDescriptionType schema type.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT AxisDescriptionType: public ::xml_schema::type
      {
        public:
        /**
         * @name AxisType
         *
         * @brief Accessor and modifier functions for the %AxisType
         * required element.
         *
         * Type of axis can be "I" for Incremental, "A" for
         * Absolute.The z-axis must be absolute!
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::AxisType AxisType_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< AxisType_type, wchar_t > AxisType_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const AxisType_type&
        AxisType () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        AxisType_type&
        AxisType ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        AxisType (const AxisType_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        AxisType (::std::auto_ptr< AxisType_type > p);

        //@}

        /**
         * @name DataType
         *
         * @brief Accessor and modifier functions for the %DataType
         * optional element.
         *
         * Data type for absolute axis: "I" for
         * int16, "L" for int32, "F"
         * for float32, "D" for float64.
         * Incremental axes do not have/need a data type
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::DataType DataType_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< DataType_type > DataType_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< DataType_type, wchar_t > DataType_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const DataType_optional&
        DataType () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        DataType_optional&
        DataType ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        DataType (const DataType_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        DataType (const DataType_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        DataType (::std::auto_ptr< DataType_type > p);

        //@}

        /**
         * @name Increment
         *
         * @brief Accessor and modifier functions for the %Increment
         * optional element.
         *
         * Needed for incremental axis and integer data
         * types: Increment is the multiplyer of the
         * integer coordinate for the computation of the
         * real coordinate: Xreal = Xoffset +
         * Xinteger*XIncrement. The unit of increment and
         * offset is metre.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::double_ Increment_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< Increment_type > Increment_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Increment_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Increment_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const Increment_optional&
        Increment () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        Increment_optional&
        Increment ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Increment (const Increment_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        Increment (const Increment_optional& x);

        //@}

        /**
         * @name Offset
         *
         * @brief Accessor and modifier functions for the %Offset
         * optional element.
         *
         * The offset of axis in meter.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::double_ Offset_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< Offset_type > Offset_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Offset_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Offset_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const Offset_optional&
        Offset () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        Offset_optional&
        Offset ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Offset (const Offset_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        Offset (const Offset_optional& x);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        AxisDescriptionType (const AxisType_type&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        AxisDescriptionType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        AxisDescriptionType (const AxisDescriptionType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual AxisDescriptionType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~AxisDescriptionType ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< AxisType_type > AxisType_;
        DataType_optional DataType_;
        Increment_optional Increment_;
        Offset_optional Offset_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const AxisDescriptionType&, const AxisDescriptionType&);

      _OPENGPS_EXPORT
      bool
      operator!= (const AxisDescriptionType&, const AxisDescriptionType&);


      /**
       * @brief Class corresponding to the %InstrumentType schema type.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT InstrumentType: public ::xml_schema::type
      {
        public:
        /**
         * @name Manufacturer
         *
         * @brief Accessor and modifier functions for the %Manufacturer
         * required element.
         *
         * Name of the equipment manufacturer
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::token Manufacturer_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Manufacturer_type, wchar_t > Manufacturer_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Manufacturer_type&
        Manufacturer () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Manufacturer_type&
        Manufacturer ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Manufacturer (const Manufacturer_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Manufacturer (::std::auto_ptr< Manufacturer_type > p);

        //@}

        /**
         * @name Model
         *
         * @brief Accessor and modifier functions for the %Model
         * required element.
         *
         * Name of the machine model used for the
         * measurement
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::token Model_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Model_type, wchar_t > Model_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Model_type&
        Model () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Model_type&
        Model ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Model (const Model_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Model (::std::auto_ptr< Model_type > p);

        //@}

        /**
         * @name Serial
         *
         * @brief Accessor and modifier functions for the %Serial
         * required element.
         *
         * Serial number of the machine.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::token Serial_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Serial_type, wchar_t > Serial_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Serial_type&
        Serial () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Serial_type&
        Serial ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Serial (const Serial_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Serial (::std::auto_ptr< Serial_type > p);

        //@}

        /**
         * @name Version
         *
         * @brief Accessor and modifier functions for the %Version
         * required element.
         *
         * Software and hardware version strings used to
         * create this file.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::token Version_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Version_type&
        Version () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Version_type&
        Version ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Version (const Version_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Version (::std::auto_ptr< Version_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        InstrumentType (const Manufacturer_type&,
                        const Model_type&,
                        const Serial_type&,
                        const Version_type&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        InstrumentType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        InstrumentType (const InstrumentType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual InstrumentType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~InstrumentType ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< Manufacturer_type > Manufacturer_;
        ::xsd::cxx::tree::one< Model_type > Model_;
        ::xsd::cxx::tree::one< Serial_type > Serial_;
        ::xsd::cxx::tree::one< Version_type > Version_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const InstrumentType&, const InstrumentType&);

      _OPENGPS_EXPORT
      bool
      operator!= (const InstrumentType&, const InstrumentType&);


      /**
       * @brief Class corresponding to the %ProbingSystemType schema type.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT ProbingSystemType: public ::xml_schema::type
      {
        public:
        /**
         * @name Type
         *
         * @brief Accessor and modifier functions for the %Type
         * required element.
         *
         * one of "NonContacting" or "Contacting" or "Software"
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::Type Type_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Type_type, wchar_t > Type_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Type_type&
        Type () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Type_type&
        Type ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Type (const Type_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Type (::std::auto_ptr< Type_type > p);

        //@}

        /**
         * @name Identification
         *
         * @brief Accessor and modifier functions for the %Identification
         * required element.
         *
         * Vendor specific identification of probe tip,
         * lens, etc...
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::token Identification_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Identification_type, wchar_t > Identification_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const Identification_type&
        Identification () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        Identification_type&
        Identification ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        Identification (const Identification_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        Identification (::std::auto_ptr< Identification_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        ProbingSystemType (const Type_type&,
                           const Identification_type&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        ProbingSystemType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        ProbingSystemType (const ProbingSystemType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual ProbingSystemType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~ProbingSystemType ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< Type_type > Type_;
        ::xsd::cxx::tree::one< Identification_type > Identification_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const ProbingSystemType&, const ProbingSystemType&);

      _OPENGPS_EXPORT
      bool
      operator!= (const ProbingSystemType&, const ProbingSystemType&);


      /**
       * @brief Class corresponding to the %DataListType schema type.
       *
       * The datalist contains the point coordinates in ASCII. A
       * list can by definition not contain invalid points,
       * because it does not define a topological neighbourship.
       * A list is allways ab unsorted list of 3D-points.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT DataListType: public ::xml_schema::type
      {
        public:
        /**
         * @name Datum
         *
         * @brief Accessor and modifier functions for the %Datum
         * sequence element.
         *
         * Datum contains a ";" separated list of X,Y,Z
         * floating point or integer coordinates. An empty
         * Datum tag defines an invalid data point.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::Datum Datum_type;

        /**
         * @brief Element sequence container type.
         */
        typedef ::xsd::cxx::tree::sequence< Datum_type > Datum_sequence;

        /**
         * @brief Element iterator type.
         */
        typedef Datum_sequence::iterator Datum_iterator;

        /**
         * @brief Element constant iterator type.
         */
        typedef Datum_sequence::const_iterator Datum_const_iterator;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< Datum_type, wchar_t > Datum_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * sequence.
         *
         * @return A constant reference to the sequence container.
         */
        const Datum_sequence&
        Datum () const;

        /**
         * @brief Return a read-write reference to the element sequence.
         *
         * @return A reference to the sequence container.
         */
        Datum_sequence&
        Datum ();

        /**
         * @brief Copy elements from a given sequence.
         *
         * @param s A sequence to copy elements from.
         *
         * For each element in @a s this function makes a copy and adds it 
         * to the sequence. Note that this operation completely changes the 
         * sequence and all old elements will be lost.
         */
        void
        Datum (const Datum_sequence& s);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        DataListType ();

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        DataListType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        DataListType (const DataListType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual DataListType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~DataListType ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        Datum_sequence Datum_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const DataListType&, const DataListType&);

      _OPENGPS_EXPORT
      bool
      operator!= (const DataListType&, const DataListType&);


      /**
       * @brief Class corresponding to the %DataLinkType schema type.
       *
       * Defines a Link to a binary data file and a binary file
       * containing the information about valid points.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT DataLinkType: public ::xml_schema::type
      {
        public:
        /**
         * @name PointDataLink
         *
         * @brief Accessor and modifier functions for the %PointDataLink
         * required element.
         *
         * Relative filename in unix notation to a binary
         * file with point data. Data can be specified
         * directly in the xml file or with a link be
         * stored in an external binary file. The Binary
         * file has the same organisation as the DataList
         * and has the datatypes specified in the axis
         * description.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::string PointDataLink_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< PointDataLink_type, wchar_t > PointDataLink_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const PointDataLink_type&
        PointDataLink () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        PointDataLink_type&
        PointDataLink ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        PointDataLink (const PointDataLink_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        PointDataLink (::std::auto_ptr< PointDataLink_type > p);

        //@}

        /**
         * @name MD5ChecksumPointData
         *
         * @brief Accessor and modifier functions for the %MD5ChecksumPointData
         * required element.
         *
         * An MD5Checksum of the point data file like
         * calculated by the unix command "md5sum". It
         * consists of 32 hexadecimal digits. The binary
         * representation is a 128 bit number.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::hex_binary MD5ChecksumPointData_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< MD5ChecksumPointData_type, wchar_t > MD5ChecksumPointData_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const MD5ChecksumPointData_type&
        MD5ChecksumPointData () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        MD5ChecksumPointData_type&
        MD5ChecksumPointData ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        MD5ChecksumPointData (const MD5ChecksumPointData_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        MD5ChecksumPointData (::std::auto_ptr< MD5ChecksumPointData_type > p);

        //@}

        /**
         * @name ValidPointsLink
         *
         * @brief Accessor and modifier functions for the %ValidPointsLink
         * optional element.
         *
         * Relative filename in unix notation to a binary
         * file that contains a packed array of bools. Each
         * element that is true corresponds to a valid data
         * point in the binary point data file.
         * 
         * If this tag does not exist, all points are valid
         * except for floating point numbers of the special
         * value "NaN" (Not a Number).
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::string ValidPointsLink_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< ValidPointsLink_type > ValidPointsLink_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< ValidPointsLink_type, wchar_t > ValidPointsLink_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const ValidPointsLink_optional&
        ValidPointsLink () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        ValidPointsLink_optional&
        ValidPointsLink ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        ValidPointsLink (const ValidPointsLink_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        ValidPointsLink (const ValidPointsLink_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        ValidPointsLink (::std::auto_ptr< ValidPointsLink_type > p);

        //@}

        /**
         * @name MD5ChecksumValidPoints
         *
         * @brief Accessor and modifier functions for the %MD5ChecksumValidPoints
         * optional element.
         *
         * An MD5Checksum of the valid points file like
         * calculated by the unix command "md5sum". It
         * consists of 32 hexadecimal digits. The binary
         * representation is a 128 bit number.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::hex_binary MD5ChecksumValidPoints_type;

        /**
         * @brief Element optional container type.
         */
        typedef ::xsd::cxx::tree::optional< MD5ChecksumValidPoints_type > MD5ChecksumValidPoints_optional;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< MD5ChecksumValidPoints_type, wchar_t > MD5ChecksumValidPoints_traits;

        /**
         * @brief Return a read-only (constant) reference to the element
         * container.
         *
         * @return A constant reference to the optional container.
         */
        const MD5ChecksumValidPoints_optional&
        MD5ChecksumValidPoints () const;

        /**
         * @brief Return a read-write reference to the element container.
         *
         * @return A reference to the optional container.
         */
        MD5ChecksumValidPoints_optional&
        MD5ChecksumValidPoints ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        MD5ChecksumValidPoints (const MD5ChecksumValidPoints_type& x);

        /**
         * @brief Set the element value.
         *
         * @param x An optional container with the new value to set.
         *
         * If the value is present in @a x then this function makes a copy 
         * of this value and sets it as the new value of the element.
         * Otherwise the element container is set the 'not present' state.
         */
        void
        MD5ChecksumValidPoints (const MD5ChecksumValidPoints_optional& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly instead
         * of making a copy.
         */
        void
        MD5ChecksumValidPoints (::std::auto_ptr< MD5ChecksumValidPoints_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        DataLinkType (const PointDataLink_type&,
                      const MD5ChecksumPointData_type&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        DataLinkType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        DataLinkType (const DataLinkType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual DataLinkType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~DataLinkType ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< PointDataLink_type > PointDataLink_;
        ::xsd::cxx::tree::one< MD5ChecksumPointData_type > MD5ChecksumPointData_;
        ValidPointsLink_optional ValidPointsLink_;
        MD5ChecksumValidPoints_optional MD5ChecksumValidPoints_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const DataLinkType&, const DataLinkType&);

      _OPENGPS_EXPORT
      bool
      operator!= (const DataLinkType&, const DataLinkType&);


      /**
       * @brief Class corresponding to the %MatrixDimensionType schema type.
       *
       * Defines the size of the 3 dimensions of the data matrix.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT MatrixDimensionType: public ::xml_schema::type
      {
        public:
        /**
         * @name SizeX
         *
         * @brief Accessor and modifier functions for the %SizeX
         * required element.
         *
         * Define the size of the first dimension of the
         * data matrix
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::unsigned_long SizeX_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< SizeX_type, wchar_t > SizeX_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const SizeX_type&
        SizeX () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        SizeX_type&
        SizeX ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        SizeX (const SizeX_type& x);

        //@}

        /**
         * @name SizeY
         *
         * @brief Accessor and modifier functions for the %SizeY
         * required element.
         *
         * Define the size of the second dimension of the
         * data matrix
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::unsigned_long SizeY_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< SizeY_type, wchar_t > SizeY_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const SizeY_type&
        SizeY () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        SizeY_type&
        SizeY ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        SizeY (const SizeY_type& x);

        //@}

        /**
         * @name SizeZ
         *
         * @brief Accessor and modifier functions for the %SizeZ
         * required element.
         *
         * Define the size of the third dimension of the
         * data matrix
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::xml_schema::unsigned_long SizeZ_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< SizeZ_type, wchar_t > SizeZ_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const SizeZ_type&
        SizeZ () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        SizeZ_type&
        SizeZ ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        SizeZ (const SizeZ_type& x);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        MatrixDimensionType (const SizeX_type&,
                             const SizeY_type&,
                             const SizeZ_type&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        MatrixDimensionType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        MatrixDimensionType (const MatrixDimensionType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual MatrixDimensionType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~MatrixDimensionType ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< SizeX_type > SizeX_;
        ::xsd::cxx::tree::one< SizeY_type > SizeY_;
        ::xsd::cxx::tree::one< SizeZ_type > SizeZ_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const MatrixDimensionType&, const MatrixDimensionType&);

      _OPENGPS_EXPORT
      bool
      operator!= (const MatrixDimensionType&, const MatrixDimensionType&);


      /**
       * @brief Class corresponding to the %RotationType schema type.
       *
       * The optional transformation contains a 3D rotation
       * matrix R with 3 by 3 elements that is used to rotate the
       * data points in its final orientation. The full
       * transformation consists of a rotation and a following
       * translation that is taken from the
       * AxisDescriptionType.Offset elements: Q = R*P + T With Q
       * beeing the final point, P the coordinate as specified in
       * Record3, R the 3 by 3 rotation matrix and T the
       * 3-element offset vector. The * denotes a matrix product.
       * The formula for the x coordinate is: Qx =
       * r11*Px+r12*Py+r13*Pz + Tx. The formula for the y
       * coordinate is: Qy = r21*Px+r22*Py+r23*Pz + Ty. The
       * formula for the x coordinate is: Qz =
       * r31*Px+r32*Py+r33*Pz + Tz.s
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT RotationType: public ::xml_schema::type
      {
        public:
        /**
         * @name r11
         *
         * @brief Accessor and modifier functions for the %r11
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationMatrixElementType r11_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< r11_type, wchar_t > r11_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const r11_type&
        r11 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        r11_type&
        r11 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        r11 (const r11_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        r11 (::std::auto_ptr< r11_type > p);

        //@}

        /**
         * @name r12
         *
         * @brief Accessor and modifier functions for the %r12
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationMatrixElementType r12_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< r12_type, wchar_t > r12_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const r12_type&
        r12 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        r12_type&
        r12 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        r12 (const r12_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        r12 (::std::auto_ptr< r12_type > p);

        //@}

        /**
         * @name r13
         *
         * @brief Accessor and modifier functions for the %r13
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationMatrixElementType r13_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< r13_type, wchar_t > r13_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const r13_type&
        r13 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        r13_type&
        r13 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        r13 (const r13_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        r13 (::std::auto_ptr< r13_type > p);

        //@}

        /**
         * @name r21
         *
         * @brief Accessor and modifier functions for the %r21
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationMatrixElementType r21_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< r21_type, wchar_t > r21_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const r21_type&
        r21 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        r21_type&
        r21 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        r21 (const r21_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        r21 (::std::auto_ptr< r21_type > p);

        //@}

        /**
         * @name r22
         *
         * @brief Accessor and modifier functions for the %r22
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationMatrixElementType r22_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< r22_type, wchar_t > r22_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const r22_type&
        r22 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        r22_type&
        r22 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        r22 (const r22_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        r22 (::std::auto_ptr< r22_type > p);

        //@}

        /**
         * @name r23
         *
         * @brief Accessor and modifier functions for the %r23
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationMatrixElementType r23_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< r23_type, wchar_t > r23_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const r23_type&
        r23 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        r23_type&
        r23 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        r23 (const r23_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        r23 (::std::auto_ptr< r23_type > p);

        //@}

        /**
         * @name r31
         *
         * @brief Accessor and modifier functions for the %r31
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationMatrixElementType r31_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< r31_type, wchar_t > r31_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const r31_type&
        r31 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        r31_type&
        r31 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        r31 (const r31_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        r31 (::std::auto_ptr< r31_type > p);

        //@}

        /**
         * @name r32
         *
         * @brief Accessor and modifier functions for the %r32
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationMatrixElementType r32_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< r32_type, wchar_t > r32_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const r32_type&
        r32 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        r32_type&
        r32 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        r32 (const r32_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        r32 (::std::auto_ptr< r32_type > p);

        //@}

        /**
         * @name r33
         *
         * @brief Accessor and modifier functions for the %r33
         * required element.
         */
        //@{

        /**
         * @brief Element type.
         */
        typedef ::OpenGPS::Schemas::ISO5436_2::RotationMatrixElementType r33_type;

        /**
         * @brief Element traits type.
         */
        typedef ::xsd::cxx::tree::traits< r33_type, wchar_t > r33_traits;

        /**
         * @brief Return a read-only (constant) reference to the element.
         *
         * @return A constant reference to the element.
         */
        const r33_type&
        r33 () const;

        /**
         * @brief Return a read-write reference to the element.
         *
         * @return A reference to the element.
         */
        r33_type&
        r33 ();

        /**
         * @brief Set the element value.
         *
         * @param x A new value to set.
         *
         * This function makes a copy of its argument and sets it as
         * the new value of the element.
         */
        void
        r33 (const r33_type& x);

        /**
         * @brief Set the element value without copying.
         *
         * @param p A new value to use.
         *
         * This function will try to use the passed value directly
         * instead of making a copy.
         */
        void
        r33 (::std::auto_ptr< r33_type > p);

        //@}

        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        RotationType (const r11_type&,
                      const r12_type&,
                      const r13_type&,
                      const r21_type&,
                      const r22_type&,
                      const r23_type&,
                      const r31_type&,
                      const r32_type&,
                      const r33_type&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        RotationType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        RotationType (const RotationType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual RotationType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~RotationType ();

        // Implementation.
        //

        //@cond

        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< r11_type > r11_;
        ::xsd::cxx::tree::one< r12_type > r12_;
        ::xsd::cxx::tree::one< r13_type > r13_;
        ::xsd::cxx::tree::one< r21_type > r21_;
        ::xsd::cxx::tree::one< r22_type > r22_;
        ::xsd::cxx::tree::one< r23_type > r23_;
        ::xsd::cxx::tree::one< r31_type > r31_;
        ::xsd::cxx::tree::one< r32_type > r32_;
        ::xsd::cxx::tree::one< r33_type > r33_;

        //@endcond
      };

      _OPENGPS_EXPORT
      bool
      operator== (const RotationType&, const RotationType&);

      _OPENGPS_EXPORT
      bool
      operator!= (const RotationType&, const RotationType&);


      /**
       * @brief Class corresponding to the %RotationMatrixElementType schema type.
       *
       * An element of a pure rotation matrix is limited to a
       * value range of [-1..1].
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT RotationMatrixElementType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
      {
        public:
        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        RotationMatrixElementType (const ::xml_schema::double_&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        RotationMatrixElementType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a DOM attribute.
         *
         * @param a A DOM attribute to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        RotationMatrixElementType (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a string fragment.
         *
         * @param s A string fragment to extract the data from.
         * @param e A pointer to DOM element containing the string fragment.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        RotationMatrixElementType (const ::std::wstring& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        RotationMatrixElementType (const RotationMatrixElementType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual RotationMatrixElementType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~RotationMatrixElementType ();
      };

      /**
       * @brief Enumeration class corresponding to the %FeatureType
       * schema type.
       */
      class _OPENGPS_EXPORT FeatureType: public ::xml_schema::token
      {
        public:

        /**
         * @brief Underlying enum type.
         */
        enum value
        {
          PRF,
          SUR,
          PCL
        };

        /**
         * @brief Create an instance from the underlying enum value.
         *
         * @param v A enum value.
         */
        FeatureType (value v);

        /**
         * @brief Create an instance from a C string.
         *
         * @param v A string value.
         */
        FeatureType (const wchar_t* v);

        /**
         * @brief Create an instance from a string.
         *
         * @param v A string value.
         */
        FeatureType (const ::std::wstring& v);

        /**
         * @brief Create an instance from the base value.
         *
         * @param v A base value.
         */
        FeatureType (const ::xml_schema::token& v);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        FeatureType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a DOM attribute.
         *
         * @param a A DOM attribute to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        FeatureType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a string fragment.
         *
         * @param s A string fragment to extract the data from.
         * @param e A pointer to DOM element containing the string fragment.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        FeatureType (const ::std::wstring& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        FeatureType (const FeatureType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual FeatureType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        /**
         * @brief Assign the underlying enum value.
         *
         * @param v A enum value.
         * @return A refernce to the instance.
         */
        FeatureType&
        operator= (value v);

        /**
         * @brief Implicit conversion operator to the underlying
         * enum value.
         *
         * @return A enum value.
         */
        virtual
        operator value () const
        {
          return _xsd_FeatureType_convert ();
        }

        //@cond

        protected:
        value
        _xsd_FeatureType_convert () const;

        public:
        static const wchar_t* const _xsd_FeatureType_literals_[3];
        static const value _xsd_FeatureType_indexes_[3];

        //@endcond
      };

      /**
       * @brief Enumeration class corresponding to the %AxisType
       * schema type.
       */
      class _OPENGPS_EXPORT AxisType: public ::xml_schema::token
      {
        public:

        /**
         * @brief Underlying enum type.
         */
        enum value
        {
          A,
          I
        };

        /**
         * @brief Create an instance from the underlying enum value.
         *
         * @param v A enum value.
         */
        AxisType (value v);

        /**
         * @brief Create an instance from a C string.
         *
         * @param v A string value.
         */
        AxisType (const wchar_t* v);

        /**
         * @brief Create an instance from a string.
         *
         * @param v A string value.
         */
        AxisType (const ::std::wstring& v);

        /**
         * @brief Create an instance from the base value.
         *
         * @param v A base value.
         */
        AxisType (const ::xml_schema::token& v);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        AxisType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a DOM attribute.
         *
         * @param a A DOM attribute to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        AxisType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a string fragment.
         *
         * @param s A string fragment to extract the data from.
         * @param e A pointer to DOM element containing the string fragment.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        AxisType (const ::std::wstring& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        AxisType (const AxisType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual AxisType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        /**
         * @brief Assign the underlying enum value.
         *
         * @param v A enum value.
         * @return A refernce to the instance.
         */
        AxisType&
        operator= (value v);

        /**
         * @brief Implicit conversion operator to the underlying
         * enum value.
         *
         * @return A enum value.
         */
        virtual
        operator value () const
        {
          return _xsd_AxisType_convert ();
        }

        //@cond

        protected:
        value
        _xsd_AxisType_convert () const;

        public:
        static const wchar_t* const _xsd_AxisType_literals_[2];
        static const value _xsd_AxisType_indexes_[2];

        //@endcond
      };

      /**
       * @brief Enumeration class corresponding to the %DataType
       * schema type.
       */
      class _OPENGPS_EXPORT DataType: public ::xml_schema::token
      {
        public:

        /**
         * @brief Underlying enum type.
         */
        enum value
        {
          I,
          L,
          F,
          D
        };

        /**
         * @brief Create an instance from the underlying enum value.
         *
         * @param v A enum value.
         */
        DataType (value v);

        /**
         * @brief Create an instance from a C string.
         *
         * @param v A string value.
         */
        DataType (const wchar_t* v);

        /**
         * @brief Create an instance from a string.
         *
         * @param v A string value.
         */
        DataType (const ::std::wstring& v);

        /**
         * @brief Create an instance from the base value.
         *
         * @param v A base value.
         */
        DataType (const ::xml_schema::token& v);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        DataType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a DOM attribute.
         *
         * @param a A DOM attribute to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        DataType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a string fragment.
         *
         * @param s A string fragment to extract the data from.
         * @param e A pointer to DOM element containing the string fragment.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        DataType (const ::std::wstring& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        DataType (const DataType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual DataType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        /**
         * @brief Assign the underlying enum value.
         *
         * @param v A enum value.
         * @return A refernce to the instance.
         */
        DataType&
        operator= (value v);

        /**
         * @brief Implicit conversion operator to the underlying
         * enum value.
         *
         * @return A enum value.
         */
        virtual
        operator value () const
        {
          return _xsd_DataType_convert ();
        }

        //@cond

        protected:
        value
        _xsd_DataType_convert () const;

        public:
        static const wchar_t* const _xsd_DataType_literals_[4];
        static const value _xsd_DataType_indexes_[4];

        //@endcond
      };

      /**
       * @brief Enumeration class corresponding to the %Type
       * schema type.
       */
      class _OPENGPS_EXPORT Type: public ::xml_schema::token
      {
        public:

        /**
         * @brief Underlying enum type.
         */
        enum value
        {
          Contacting,
          NonContacting,
          Software
        };

        /**
         * @brief Create an instance from the underlying enum value.
         *
         * @param v A enum value.
         */
        Type (value v);

        /**
         * @brief Create an instance from a C string.
         *
         * @param v A string value.
         */
        Type (const wchar_t* v);

        /**
         * @brief Create an instance from a string.
         *
         * @param v A string value.
         */
        Type (const ::std::wstring& v);

        /**
         * @brief Create an instance from the base value.
         *
         * @param v A base value.
         */
        Type (const ::xml_schema::token& v);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a DOM attribute.
         *
         * @param a A DOM attribute to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a string fragment.
         *
         * @param s A string fragment to extract the data from.
         * @param e A pointer to DOM element containing the string fragment.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Type (const ::std::wstring& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        Type (const Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual Type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        /**
         * @brief Assign the underlying enum value.
         *
         * @param v A enum value.
         * @return A refernce to the instance.
         */
        Type&
        operator= (value v);

        /**
         * @brief Implicit conversion operator to the underlying
         * enum value.
         *
         * @return A enum value.
         */
        virtual
        operator value () const
        {
          return _xsd_Type_convert ();
        }

        //@cond

        protected:
        value
        _xsd_Type_convert () const;

        public:
        static const wchar_t* const _xsd_Type_literals_[3];
        static const value _xsd_Type_indexes_[3];

        //@endcond
      };

      /**
       * @brief Class corresponding to the %Datum schema type.
       *
       * @nosubgrouping
       */
      class _OPENGPS_EXPORT Datum: public ::xml_schema::token
      {
        public:
        /**
         * @name Constructors
         */
        //@{

        /**
         * @brief Create an instance from initializers for required 
         * elements and attributes.
         */
        Datum ();

        /**
         * @brief Create an instance from a C string and initializers
         * for required elements and attributes.
         */
        Datum (const wchar_t*);

        /**
         * @brief Create an instance from a string andinitializers
         * for required elements and attributes.
         */
        Datum (const ::std::wstring&);

        /**
         * @brief Create an instance from the ultimate base and
         * initializers for required elements and attributes.
         */
        Datum (const ::xml_schema::token&);

        /**
         * @brief Create an instance from a DOM element.
         *
         * @param e A DOM element to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Datum (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a DOM attribute.
         *
         * @param a A DOM attribute to extract the data from.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Datum (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

        /**
         * @brief Create an instance from a string fragment.
         *
         * @param s A string fragment to extract the data from.
         * @param e A pointer to DOM element containing the string fragment.
         * @param f Flags to create the new instance with.
         * @param c A pointer to the object that will contain the new
         * instance.
         */
        Datum (const ::std::wstring& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

        /**
         * @brief Copy constructor.
         *
         * @param x An instance to make a copy of.
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         *
         * For polymorphic object models use the @c _clone function instead.
         */
        Datum (const Datum& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

        /**
         * @brief Copy the instance polymorphically.
         *
         * @param f Flags to create the copy with.
         * @param c A pointer to the object that will contain the copy.
         * @return A pointer to the dynamically allocated copy.
         *
         * This function ensures that the dynamic type of the instance is
         * used for copying and should be used for polymorphic object
         * models instead of the copy constructor.
         */
        virtual Datum*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        //@}

        /**
         * @brief Destructor.
         */
        virtual 
        ~Datum ();
      };
    }
  }
}

#include <iosfwd>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const Record1Type&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const ISO5436_2Type&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const Record2Type&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const Record3Type&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const Record4Type&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const AxesType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const AxisDescriptionType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const InstrumentType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const ProbingSystemType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const DataListType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const DataLinkType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const MatrixDimensionType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const RotationType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const RotationMatrixElementType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, FeatureType::value);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const FeatureType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, AxisType::value);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const AxisType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, DataType::value);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const DataType&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, Type::value);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const Type&);

      _OPENGPS_EXPORT
      ::std::wostream&
      operator<< (::std::wostream&, const Datum&);
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      /**
       * @name Parsing functions for the %ISO5436_2 document root.
       *
       * The only global element: The root node
       */
      //@{

      /**
       * @brief Parse a URI or a local file.
       *
       * @param uri A URI or a local file name.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function uses exceptions to report parsing errors.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::std::wstring& uri,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a URI or a local file with an error handler.
       *
       * @param uri A URI or a local file name.
       * @param eh An error handler.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function reports parsing errors by calling the error handler.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::std::wstring& uri,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a URI or a local file with a Xerces-C++ DOM error
       * handler.
       *
       * @param uri A URI or a local file name.
       * @param eh A Xerces-C++ DOM error handler.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function reports parsing errors by calling the error handler.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::std::wstring& uri,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a standard input stream.
       *
       * @param is A standrad input stream.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function uses exceptions to report parsing errors.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a standard input stream with an error handler.
       *
       * @param is A standrad input stream.
       * @param eh An error handler.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function reports parsing errors by calling the error handler.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a standard input stream with a Xerces-C++ DOM error
       * handler.
       *
       * @param is A standrad input stream.
       * @param eh A Xerces-C++ DOM error handler.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function reports parsing errors by calling the error handler.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a standard input stream with a resource id.
       *
       * @param is A standrad input stream.
       * @param id A resource id.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * The resource id is used to identify the document being parsed in
       * diagnostics as well as to resolve relative paths.
       *
       * This function uses exceptions to report parsing errors.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 const ::std::wstring& id,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a standard input stream with a resource id and an
       * error handler.
       *
       * @param is A standrad input stream.
       * @param id A resource id.
       * @param eh An error handler.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * The resource id is used to identify the document being parsed in
       * diagnostics as well as to resolve relative paths.
       *
       * This function reports parsing errors by calling the error handler.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 const ::std::wstring& id,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a standard input stream with a resource id and a
       * Xerces-C++ DOM error handler.
       *
       * @param is A standrad input stream.
       * @param id A resource id.
       * @param eh A Xerces-C++ DOM error handler.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * The resource id is used to identify the document being parsed in
       * diagnostics as well as to resolve relative paths.
       *
       * This function reports parsing errors by calling the error handler.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::std::istream& is,
                 const ::std::wstring& id,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a Xerces-C++ input source.
       *
       * @param is A Xerces-C++ input source.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function uses exceptions to report parsing errors.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::xercesc::InputSource& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a Xerces-C++ input source with an error handler.
       *
       * @param is A Xerces-C++ input source.
       * @param eh An error handler.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function reports parsing errors by calling the error handler.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::xercesc::InputSource& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
       * error handler.
       *
       * @param is A Xerces-C++ input source.
       * @param eh A Xerces-C++ DOM error handler.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function reports parsing errors by calling the error handler.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::xercesc::InputSource& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a Xerces-C++ DOM document.
       *
       * @param d A Xerces-C++ DOM document.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      /**
       * @brief Parse a Xerces-C++ DOM document.
       *
       * @param d A pointer to the Xerces-C++ DOM document.
       * @param f Parsing flags.
       * @param p Parsing properties. 
       * @return A pointer to the root of the object model.
       *
       * This function is normally used together with the keep_dom and
       * own_dom parsing flags to assign ownership of the DOM document
       * to the object model.
       */
      _OPENGPS_EXPORT
      ::std::auto_ptr< ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type >
      ISO5436_2 (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

      //@}
    }
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace OpenGPS
{
  namespace Schemas
  {
    namespace ISO5436_2
    {
      /**
       * @name Serialization functions for the %ISO5436_2 document root.
       *
       * The only global element: The root node
       */
      //@{

      /**
       * @brief Serialize to a standard output stream.
       *
       * @param os A standrad output stream.
       * @param x An object model to serialize.
       * @param m A namespace information map.
       * @param e A character encoding to produce XML in.
       * @param f Serialization flags.
       *
       * This function uses exceptions to report serialization errors.
       */
      _OPENGPS_EXPORT
      void
      ISO5436_2 (::std::ostream& os,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

      /**
       * @brief Serialize to a standard output stream with an error handler.
       *
       * @param os A standrad output stream.
       * @param x An object model to serialize.
       * @param eh An error handler.
       * @param m A namespace information map.
       * @param e A character encoding to produce XML in.
       * @param f Serialization flags.
       *
       * This function reports serialization errors by calling the error
       * handler.
       */
      _OPENGPS_EXPORT
      void
      ISO5436_2 (::std::ostream& os,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

      /**
       * @brief Serialize to a standard output stream with a Xerces-C++ DOM
       * error handler.
       *
       * @param os A standrad output stream.
       * @param x An object model to serialize.
       * @param eh A Xerces-C++ DOM error handler.
       * @param m A namespace information map.
       * @param e A character encoding to produce XML in.
       * @param f Serialization flags.
       *
       * This function reports serialization errors by calling the error
       * handler.
       */
      _OPENGPS_EXPORT
      void
      ISO5436_2 (::std::ostream& os,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

      /**
       * @brief Serialize to a Xerces-C++ XML format target.
       *
       * @param ft A Xerces-C++ XML format target.
       * @param x An object model to serialize.
       * @param m A namespace information map.
       * @param e A character encoding to produce XML in.
       * @param f Serialization flags.
       *
       * This function uses exceptions to report serialization errors.
       */
      _OPENGPS_EXPORT
      void
      ISO5436_2 (::xercesc::XMLFormatTarget& ft,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

      /**
       * @brief Serialize to a Xerces-C++ XML format target with an error
       * handler.
       *
       * @param ft A Xerces-C++ XML format target.
       * @param x An object model to serialize.
       * @param eh An error handler.
       * @param m A namespace information map.
       * @param e A character encoding to produce XML in.
       * @param f Serialization flags.
       *
       * This function reports serialization errors by calling the error
       * handler.
       */
      _OPENGPS_EXPORT
      void
      ISO5436_2 (::xercesc::XMLFormatTarget& ft,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

      /**
       * @brief Serialize to a Xerces-C++ XML format target with a
       * Xerces-C++ DOM error handler.
       *
       * @param ft A Xerces-C++ XML format target.
       * @param x An object model to serialize.
       * @param eh A Xerces-C++ DOM error handler.
       * @param m A namespace information map.
       * @param e A character encoding to produce XML in.
       * @param f Serialization flags.
       *
       * This function reports serialization errors by calling the error
       * handler.
       */
      _OPENGPS_EXPORT
      void
      ISO5436_2 (::xercesc::XMLFormatTarget& ft,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::wstring& e = L"UTF-8",
                 ::xml_schema::flags f = 0);

      /**
       * @brief Serialize to an existing Xerces-C++ DOM document.
       *
       * @param d A Xerces-C++ DOM document.
       * @param x An object model to serialize.
       * @param f Serialization flags.
       *
       * Note that it is your responsibility to create the DOM document
       * with the correct root element as well as set the necessary
       * namespace mapping attributes.
       */
      _OPENGPS_EXPORT
      void
      ISO5436_2 (::xercesc::DOMDocument& d,
                 const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& x,
                 ::xml_schema::flags f = 0);

      /**
       * @brief Serialize to a new Xerces-C++ DOM document.
       *
       * @param x An object model to serialize.
       * @param m A namespace information map.
       * @param f Serialization flags.
       * @return A pointer to the new Xerces-C++ DOM document.
       */
      _OPENGPS_EXPORT
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
      ISO5436_2 (const ::OpenGPS::Schemas::ISO5436_2::ISO5436_2Type& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 ::xml_schema::flags f = 0);

      //@}

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const Record1Type&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const ISO5436_2Type&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const Record2Type&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const Record3Type&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const Record4Type&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const AxesType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const AxisDescriptionType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const InstrumentType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const ProbingSystemType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const DataListType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const DataLinkType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const MatrixDimensionType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const RotationType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const RotationMatrixElementType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMAttr&, const RotationMatrixElementType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xml_schema::list_stream&,
                  const RotationMatrixElementType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const FeatureType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMAttr&, const FeatureType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xml_schema::list_stream&,
                  const FeatureType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const AxisType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMAttr&, const AxisType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xml_schema::list_stream&,
                  const AxisType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const DataType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMAttr&, const DataType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xml_schema::list_stream&,
                  const DataType&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const Type&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMAttr&, const Type&);

      _OPENGPS_EXPORT
      void
      operator<< (::xml_schema::list_stream&,
                  const Type&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMElement&, const Datum&);

      _OPENGPS_EXPORT
      void
      operator<< (::xercesc::DOMAttr&, const Datum&);

      _OPENGPS_EXPORT
      void
      operator<< (::xml_schema::list_stream&,
                  const Datum&);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_USERS_MBRUBAKE_PROJECTS_CADRE_X3P_OPEN_GPS_CODE_382_ISO5436_XML_BRANCHES_KOHLER_LINUX_PORT_SRC_ISO5436_2_XML_ISO5436_2_XSD_HXX
